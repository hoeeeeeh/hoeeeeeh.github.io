<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://hoeeeeeh.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hoeeeeeh.github.io/" rel="alternate" type="text/html" /><updated>2025-11-24T07:01:09+00:00</updated><id>https://hoeeeeeh.github.io/feed.xml</id><title type="html">hoeeeeeh</title><subtitle>HOEH 개발 블로그</subtitle><entry><title type="html">내 큐는 왜 느릴까</title><link href="https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C" rel="alternate" type="text/html" title="내 큐는 왜 느릴까" /><published>2025-09-05T07:50:00+00:00</published><updated>2025-09-05T07:50:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C">&lt;p&gt;자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다.&lt;/p&gt;

&lt;p&gt;일반적인 배열의 shift 메서드는 배열의 맨 앞 원소를 반환하지만 결국 마지막 원소까지 전부 shift 시켜야하기 때문에 O(1) 가 아닌 O(N) 이 소모된다.&lt;/p&gt;

&lt;p&gt;그래서 아주 간단하게 큐를 작성해보면, 아래와 같이 생각해볼 수 있을 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;객체로-간단하게-큐-구현해보기&quot;&gt;객체로 간단하게 큐 구현해보기&lt;/h1&gt;

&lt;p&gt;정확히는 앞이나 뒤에서 모두 원소를 O(1) 로 꺼낼 수 있는 deque 인데,&lt;/p&gt;

&lt;p&gt;간단하게 items 라는 객체에서 left, right 인덱스를 통해 바로 접근할 수 있도록 하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
    left = 0;
    right = 0;
    items = {};
    
    dequeue() {
        if(this.isEmpty()) {
            return null;
        }
        
        const result = this.items[this.left];
        delete this.items[this.left];
        this.left += 1;
        
        this.clean();
        
        return result;
    }
    
    isEmpty() {
        return this.left === this.right;
    }
    
    peek() {
        if(this.isEmpty()) {
            return null;
        }
        return this.items[this.left];
    }
    
    last() {
        if(this.isEmpty()) {
            return null;
        }
        return this.items[this.right - 1];
    }
    
    enqueue(value) {
        this.items[this.right] = value;
        this.right += 1;
    }
    
    
    pop() {
        if(this.isEmpty()) {
            return null;
        }
        
        this.right -= 1;
        
        const result = this.items[this.right];
        delete this.items[this.right];
        
        this.clean();
        
        return result;
    }
    
    clean() {
        if(this.left === this.right) {
            this.left = 0;
            this.right = 0;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;dequeue-delete&quot;&gt;Dequeue, delete&lt;/h2&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dequeue&lt;/code&gt;  메서드를 살펴보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete this.items[this.left]&lt;/code&gt; 를 통해서 items 객체에서 제거하고 있다.&lt;/p&gt;

&lt;p&gt;delete 하는 이유는 당연하게도 메모리를 아끼기 위해서였다. 그리고 delete 하는데 O(1) 밖에 걸리지 않기 때문에 그렇게 큰 문제가 생기지 않을 것이라고 생각했었는데, 뒤에서 이야기하겠지만 굉장히 큰 실수였다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
dequeue() {
    if(this.isEmpty()) {
        return null;
    }
        
    const result = this.items[this.left];
    delete this.items[this.left];
    this.left += 1;
        
    this.clean();
        
    return result;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 점이 왜 잘못되었는지 알려면 우리가 쓰고 있는 node.js 의 엔진에 대해서 알아봐야한다.&lt;/p&gt;

&lt;h1 id=&quot;v8&quot;&gt;V8&lt;/h1&gt;

&lt;h2 id=&quot;turbofan-ignition&quot;&gt;TurboFan, Ignition&lt;/h2&gt;

&lt;p&gt;node.js 의 내부 엔진인 V8 은 우리가 작성한 코드를 내부적으로 최적화하는, 2단계의 실행 파이프라인을 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ignition (바이트코드 인터프리터) : 코드를 빠르게 실행하면서 객체가 어떤 모양과 타입을 가지는지(타입 피드백) 등을 수집&lt;/li&gt;
  &lt;li&gt;TurboFan (최적화 JIT 컴파일러) : Hot(자주 실행되는) 한 함수들을 최적화한 기계어 코드를 생성. 여기서 TurboFan 은 Ignition 에서 얻은 피드백 등을 사용하여 코드를 최적화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-09-05-내_큐는_왜_느릴까.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;89549.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;피드백&lt;/code&gt; 을 통해 코드를 최적화하기 때문에 V8 은 자바스크립트 코드를 훨씬 더 빠르게 실행할 수 있다. 반면, 함수가 너무 복잡하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폴리모픽&lt;/code&gt;(Polymorphic, 다양한 형태를 가진, 즉 예측 하기 힘든) 한 경우에는 코드를 최적화하기 어렵다. 따라서 아예 최적화된 코드가 없거나 최적화된 코드에서 실행이 불가능해서 최적화되지 않은 코드로 실행되는(’탈출’ 혹은 deoptimize 라고 부르는듯 하다) 경우가 많다.&lt;/p&gt;

&lt;p&gt;폴리모픽의 예시를 보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    1 function getX(obj) {
    2   return obj.x; // 이 부분이 폴리모픽 상태가 됨
    3 }
    4 
    5 const obj1 = { x: 1, y: 2 }; // Shape A
    6 const obj2 = { x: 3, z: 4 }; // Shape B (y 대신 z)
    7 
    8 // getX는 Shape A와 Shape B, 두 가지 형태의 객체를 받음
    9 getX(obj1);
   10 getX(obj2);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;obj1 은 x, y 프로퍼티를 가지고 있고, obj2 는 x, z 프로퍼티를 가지고 있다.&lt;/p&gt;

&lt;p&gt;따라서 Shape A (x, y 프로퍼티), Shape B (x, z 프로퍼티) 2가지가 존재하고, getX 는 2가지의 형태를 받을 수 있다.&lt;/p&gt;

&lt;p&gt;obj.x 부분은 Shape A 가 들어올지, Shape B 가 들어올지에 따라 각각 최적화된 코드로 넘어갈 수 있다.&lt;/p&gt;

&lt;p&gt;위의 경우에는 어느정도 최적화를 하는데 큰 문제가 없지만 조금 더 복잡한 상황이면 (보통 4개 이상?) 최적화 하기가 힘들어진다.&lt;/p&gt;

&lt;p&gt;이런 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메가모픽&lt;/code&gt;이라고 부르는 듯 하다.&lt;/p&gt;

&lt;p&gt;반대로 하나의 Shape 으로 고정되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모노모픽&lt;/code&gt; 이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    1 function getX(obj) {
    2   return obj.x; // 이 부분이 메가모픽 상태가 됨
    3 }
    4 
    5 // 매번 다른 Shape의 객체를 생성하여 함수 호출
    6 for (let i = 0; i &amp;lt; 10; i++) {
    7   let obj = { x: i };
    8   if (i % 2 === 0) obj.a = 1;
    9   if (i % 3 === 0) obj.b = 1;
   10   if (i % 4 === 0) obj.c = 1;
   11   // ... 이런 식으로 계속 다른 Shape가 만들어짐
   12   getX(obj);
   13 }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 모노모픽, 혹은 적당한 수준의 폴리모픽은 V8 의 인라인 캐시를 통해 최적화된 코드를 만들고 빠른 경로를 미리 만들어둔다.&lt;/p&gt;

&lt;p&gt;최적화된 코드에서는 런타임에 객체의 히든 클래스를 검사하는 가드가 포함되고, 일치하지 않는다면 디옵트(탈출, 인터프리터로 실행) 된다.&lt;/p&gt;

&lt;h2 id=&quot;hidden-class-shape&quot;&gt;Hidden Class (Shape)&lt;/h2&gt;

&lt;p&gt;자바스크립트는 동적 언어이지만, V8 은 내부적으로 객체에 구조를 부여하기 위해 히든 클래스라는 것을 사용한다. 히든 클래스는 어떤 프로퍼티가 있고, 메모리 어디에 저장되는지 등을 나타내는 내부 디스크립터다.&lt;/p&gt;

&lt;p&gt;코드로 간단하게 살펴보면,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
let o = {};
o.a = &quot;foo&quot;;
o.b = &quot;bar&quot;;
o.c = &quot;baz&quot;;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-09-05-내_큐는_왜_느릴까.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;31421.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 o.a → o.b → o.c 순으로 프로퍼티를 추가했으면 위의 이미지처럼 a → b → c 순으로 디스크립터가 추가되면서 히든 클래스가 만들어진다.&lt;/p&gt;

&lt;h3 id=&quot;히든-클래스는-offset-을-저장한다&quot;&gt;히든 클래스는 Offset 을 저장한다.&lt;/h3&gt;

&lt;p&gt;여기서 주의할 점은 “순서” 이다.&lt;/p&gt;

&lt;p&gt;a → b → c 순으로 프로퍼티를 추가한 객체와, c → b → a 순서로 프로퍼티를 추가한 객체는 서로 다른 히든 클래스를 갖는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
let o = {};
o.a = &quot;foo&quot;;
o.b = &quot;bar&quot;;
o.c = &quot;baz&quot;;

let x = {};
x.c = &quot;baz&quot;;
x.b = &quot;bar&quot;;
x.a = &quot;foo&quot;;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;o 와 x 는 결국 a,b,c 의 프로퍼티를 갖겠지만 서로 다른 히든 클래스를 갖는다. 프로퍼티가 추가될 때마다 새로운 히든 클래스를 만들게 되는데, 그 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로퍼티가 메모리 어디에 저장되어 있는지를 저장하는 오프셋&lt;/code&gt; 을 저장하기 때문이다.&lt;/p&gt;

&lt;p&gt;프로퍼티를 추가할 때를 기준으로 offset 이 정해지는데, a → b → c 순으로 정하는 offset 은 당연히 c → b → a 순으로 정하는 offset 과 다르다.&lt;/p&gt;

&lt;p&gt;이렇게 offset 을 가지고 특정 프로퍼티에 빠르게 접근이 가능하기 때문에 히든 클래스가 중요한 것이고, 히든 클래스에 순서가 영향을 미치는 이유이다.&lt;/p&gt;

&lt;p&gt;히든클래스를 통해 V8 은 매번 딕셔너리에서 프로퍼티를 찾는 대신, 고정 오프셋을 사용해서 프로퍼티에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;o.a, o.b, o.c 처럼 a b c 의 해시값을 딕셔너리에서 검색할 필요가 없이 오프셋을 통해 바로 접근할 수 있게 되는 것이다. (C++ 의 구조체처럼)&lt;/p&gt;

&lt;p&gt;따라서 프로퍼티의 생성 순서와 일관성이 중요하다. 일관된 shape 는 성능에 영향을 줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;딕셔너리-모드&quot;&gt;딕셔너리 모드&lt;/h3&gt;

&lt;p&gt;히든클래스로 프로퍼티의 오프셋을 저장하고 프로퍼티가 추가될 때마다 새로운 히든 클래스로 “전이” 되다가 너무 비효율적이게 되면 해당 객체를 딕셔너리 모드로 전환한다고 한다. 이렇게 딕셔너리 모드로 전환되면 해시 테이블(딕셔너리)에 프로퍼티를 저장하게 되기 때문에 프로퍼티의 추가, 삭제는 유연해진다. 대신 당연히 모든 프로퍼티로의 접근이 느려진다. (인라인 캐시와 고정 오프셋을 사용하지 못하기 때문)&lt;/p&gt;

&lt;p&gt;여기서 딕셔너리 모드로 전환되는 일반적인 방법이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 이다. delete 를 사용하는 경우 V8 은 이 객체가 고정된 구조(모노모픽처럼) 라고 생각하기 보단 동적으로 사용된다고 판단하여 딕셔너리 모드로 들어가게 된다. 결국 여기서 고려해볼수 있는 점은, 속도와 메모리효율의 트레이드오프이다. delete 를 사용하는 대신 null 이나 undefined 로 바꿈으로써 딕셔너리 모드로 전환되는 것을 막을 수 있지만 그만큼 메모리는 지속적으로 사용될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;elements-kind&quot;&gt;Elements Kind&lt;/h2&gt;

&lt;p&gt;자바스크립트에서 배열도 사실 그냥 객체이다. arr[0] 은 키가 0 인 프로퍼티일 뿐이다. 하지만 V8 은 배열에 대해서 조금 더 특별하게 최적화 한다. 정확히는 배열이라고 전부 다 동일하게 최적화하는건 아니고, 규칙성에 맞게 최적화를 한다.&lt;/p&gt;

&lt;p&gt;아래에서 볼, 객체가 가지는 원소의 타입에 맞게 최적화된다. (= Elements Kind 에 맞게 최적화)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.chromium.org/chromium/v8/v8.git/+/ec37390b2ba2b4051f46f153a8cc179ed4656f5d:src/elements-kind.h;l=14&quot;&gt;전체 Elements Kind&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;타입이-달라지면&quot;&gt;타입이 달라지면&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
const array = [1, 2, 3];
// elements kind: PACKED_SMI_ELEMENTS
array.push(4.56);
// elements kind: PACKED_DOUBLE_ELEMENTS

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;엔진의 레벨에서 바라보면, array = [1, 2, 3] 의 경우는 PACKED_SMI_ELEMENTS 로 판별한다. 여기서 SMI 는 Small Integer 이다.&lt;/p&gt;

&lt;p&gt;그런데 array.push(4.56) 을 하고 나면 PACKED_DOUBLE_ELEMENTS 로 바뀐다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
array.push(&apos;x&apos;);
// elements kind: PACKED_ELEMENTS

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 문자열을 넣으면, PACKED_ELEMENTS 로 바뀐다.&lt;/p&gt;

&lt;h2 id=&quot;holey&quot;&gt;Holey&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
const array = [1, 2, 3, 4.56, &apos;x&apos;];
// elements kind: PACKED_ELEMENTS
array.length; // 5
array[9] = 1; // array[5] until array[8] are now holes
// elements kind: HOLEY_ELEMENTS

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;length 가 5인 배열에, 갑자기 9번째 인덱스에 1을 넣고 있다. 이 경우에는 array[5] ~ array[8] 까지 구멍이 생긴다.&lt;/p&gt;

&lt;p&gt;이러면 PACKED_ELEMENTS 에서 HOLEY_ELEMENTS 로 바뀌게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-09-05-내_큐는_왜_느릴까.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;73913.png&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 그림은 2025.02.28 이전의 그림인데 자세히보면 화살표의 방향이 위에서 아래로만 되어있다. 즉, 한 번 HOLEY 가 되면 되돌아갈 수 없다는 의미였는데 2025.02.28 이후에는 예외가 하나 생겼다고 한다.&lt;/p&gt;

  &lt;p&gt;Array.prototype.fill 를 통해서 모든 홀을 채우면, PACKED 로 돌아갈 수 있다고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hole 이 생기게 되면, V8 은 매번 hole 이 있는지 여부를 체크해야하는 로직이 최적화에 포함되고, hole 인지 구분하기 위해 상위 프로토타입까지 거슬러 올라가기때문에 PACKED 보다 최적화가 비효율적이다.&lt;/p&gt;

&lt;h1 id=&quot;더-나은-큐를-만들기&quot;&gt;더 나은 큐를 만들기&lt;/h1&gt;

&lt;p&gt;기존의 큐 방식을 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// 기존 방식(최적화가 잘 되지 않음)
let queue = {};
let head = 0, tail = 0;
function enqueue(x) {
  queue[tail++] = x;
}
function dequeue() {
  if (tail &amp;gt; head) {
    let x = queue[head];
    delete queue[head++];
    return x;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처음에는 queue 안에서 0, 1, 2… 같은 순서로 인덱스가 증가하기 때문에 객체가 배열처럼 동작한다.&lt;/p&gt;

&lt;p&gt;따라서 SMI(Small Integer) elements kind 로 최적화 된다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 를 하게 되면 0부터 hole 이 생기게 된다. 따라서 PACKED → HOLEY 로 최적화 효율이 다소 안좋아지게 된다.&lt;/p&gt;

&lt;p&gt;그러다가 delete 를 많이 하다보면 head 와 tail 의 숫자는 매우 큰 반면 실제로 객체에 저장된 값은 몇 개 없을 수도 있다. 다시 말해, offset 을 통해서 접근하려고 보니까 앞에 hole 이 너무 많아서 매우 큰 offset 을 통해서 접근해야 하는 것이다.&lt;/p&gt;

&lt;p&gt;이럴 때는 V8 이 배열처럼 최적화하는 것은 비효율적이라고 판단해 딕셔너리 모드로 전환해버릴 수 있다. 이렇게 되면 히든 클래스와 offset 을 사용할 수도 없게 되고, 인라인 캐시 입장에서는 매번 offset 을 통해서 접근했는데, 딕셔너리 모드로 전환되다보니 캐싱된 값이 달라지므로 인라인 캐시도 유지할 수 없다.&lt;/p&gt;

&lt;p&gt;이제부터는 최적화 로직은 거의 사용하지 못하게 되므로 속도가 느려진다.&lt;/p&gt;

&lt;h3 id=&quot;delete-를-안쓰는-방법&quot;&gt;Delete 를 안쓰는 방법&lt;/h3&gt;

&lt;p&gt;delete 를 안쓰면서 메모리 효율도 높일 수 있는 방법은 뭐가 있을까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원형 큐(고정 크기)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// 원형 큐
const capacity = 1024;
let queueArr = new Array(capacity);
let head = 0, tail = 0;

function enqueue(x) {
  if ((tail + 1) % capacity === head) throw Error(&quot;queue full&quot;);
  queueArr[tail] = x;
  tail = (tail + 1) % capacity;
}

function dequeue() {
  if (head === tail) return undefined; 
  const x = queueArr[head];
  queueArr[head] = undefined;
  head = (head + 1) % capacity;
  return x;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드와 같은 원형 큐를 한 번 살펴보자.&lt;/p&gt;

&lt;p&gt;고정된 크기의 원형 큐를 한 번 보면, hole 이 생기지 않고 index 도 0부터 쌓이기 때문에 PACKED_SMI 를 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;지금처럼 고정된 큐의 경우에는 리사이징을 할 수 없기 때문에, 리사이징까지 고려하면 아래와 같이 생각해볼 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;대신 아무래도 동적인 크기가 가능해지기 때문에 완전히 모노모픽을 유지하기는 힘들고, 미리 capacity 를 크게 잡아둔다거나 하는 방식으로 너무 빈번한 리사이징이 일어나지 않도록 크기를 잘 잡는게 중요할 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
  constructor(initialCapacity = 16) {
    this.capacity = initialCapacity;
    this.queue = new Array(this.capacity);
    this.head = 0;
    this.tail = 0;
    this.size = 0;
  }

  enqueue(x) {
    if (this.size === this.capacity) {
      this._grow();
    }
    this.queue[this.tail] = x;
    this.tail = (this.tail + 1) % this.capacity;
    this.size++;
  }

  dequeue() {
    if (this.size === 0) return undefined;
    const x = this.queue[this.head];
    this.queue[this.head] = undefined; // 슬롯 정리 (GC-friendly)
    this.head = (this.head + 1) % this.capacity;
    this.size--;

    if (this.capacity &amp;gt; 16 &amp;amp;&amp;amp; this.size &amp;lt;= this.capacity / 4) {
      this._shrink();
    }
    return x;
  }

  peek() {
    return this.size === 0 ? undefined : this.queue[this.head];
  }

  isEmpty() {
    return this.size === 0;
  }

  _grow() {
    const newCapacity = this.capacity * 2;
    this._resize(newCapacity);
  }

  _shrink() {
    const newCapacity = Math.floor(this.capacity / 2);
    this._resize(newCapacity);
  }

  _resize(newCapacity) {
    const newQueue = new Array(newCapacity);
    for (let i = 0; i &amp;lt; this.size; i++) {
      newQueue[i] = this.queue[(this.head + i) % this.capacity];
    }
    this.queue = newQueue;
    this.capacity = newCapacity;
    this.head = 0;
    this.tail = this.size;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="CS" /><category term="Programming" /><category term="JavaScript" /><summary type="html">자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다.</summary></entry><entry><title type="html">gemini-cli notion mcp 연결하기</title><link href="https://hoeeeeeh.github.io/gemini-cli_notion_mcp_%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0" rel="alternate" type="text/html" title="gemini-cli notion mcp 연결하기" /><published>2025-08-01T10:25:00+00:00</published><updated>2025-08-01T10:25:00+00:00</updated><id>https://hoeeeeeh.github.io/gemini-cli_notion_mcp_%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hoeeeeeh.github.io/gemini-cli_notion_mcp_%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0">&lt;p&gt;프로젝트의 루트에 간단하게 .gemini/settings.json 에 아래와 같이 코드를 작성하면 notion mcp 가 추가되어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
  &quot;mcpServers&quot;: {
    &quot;notion&quot;: {
      &quot;command&quot;: &quot;npx&quot;,
      &quot;args&quot;: [&quot;-y&quot;, &quot;@notionhq/notion-mcp-server&quot;],
      &quot;env&quot;: {
        &quot;OPENAPI_MCP_HEADERS&quot;: &quot;{\&quot;Authorization\&quot;: \&quot;Bearer ntn_&amp;lt;key&amp;gt;\&quot;, \&quot;Notion-Version\&quot;: \&quot;2022-06-28\&quot; }&quot;
      }
    }
  }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;근데 내 경우에는 계속 gemini-cli 가 notion mcp 에 disconnected 가 되어 있어서 로그를 봤더니, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeError: fieldValue.toUpperCase is not a function&lt;/code&gt;  라는 에러가 발생하고 있었다.&lt;/p&gt;

&lt;p&gt;구글링을 해보니까 같은 이슈가 이미 올라와있어서 확인해봤다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원인은 genai v1.8.0 쪽의 버그인데, 1.9.0 버전을 사용하면 해결할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;관련된 MR은 있지만, mcp를 사용할 수 없게 만드는 문제는 버전 업그레이드만으로 해결될 것으로 보입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/google-gemini/gemini-cli/issues/1481&quot;&gt;https://github.com/google-gemini/gemini-cli/issues/1481&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그래서 결국 gemini 버전을 업그레이드 해주면 잘 된다..&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Blog&quot;]" /><category term="[&quot;Blog&quot;]" /><category term="Blog" /><category term="mcp" /><summary type="html">프로젝트의 루트에 간단하게 .gemini/settings.json 에 아래와 같이 코드를 작성하면 notion mcp 가 추가되어야 한다.</summary></entry><entry><title type="html">네이버 부스트캠프 멤버십 최종 회고</title><link href="https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0" rel="alternate" type="text/html" title="네이버 부스트캠프 멤버십 최종 회고" /><published>2025-02-21T07:40:00+00:00</published><updated>2025-02-21T07:40:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0">&lt;p&gt;1차 문제 해결력 테스트(2024.06.15) → 베이직 → 챌린지 → 멤버십 학습스프린트 → 멤버십 그룹프로젝트(2024.12.06) 를 진행하면서의 기억&lt;/p&gt;

&lt;h1 id=&quot;회고를-할까-말까&quot;&gt;회고를 할까 말까..&lt;/h1&gt;

&lt;p&gt;멤버십이 12월 6일에 끝났고 리팩토링 기간 3주를 해도 회고를 작성하고 있는 지금(2월 21일)은 한두 달은 지난 시점으로 회고가 조금 늦었다. 사실 회고를 작성할까 말까 고민이 있었는데 6월부터 시작했으니 2024년 절반을 거의 네이버 부스트캠프 하나에만 집중해서 살았었다. 그래서 네이버 부스트캠프의 공식 일정이 마무리되었다는게 나에게 있어서는 꽤나 큰 이슈였고 대단원의 막이 내린듯한 느낌이 들었다. 하지만 사실은 네이버 부스트캠프가 마무리되었다고 내 인생이 갑작스러운 전환점을 맞이하는것도 아니고 이제 진짜 시작일 뿐이다. 그래서 네이버 부스트캠프가 끝나서 붕 뜬 느낌을 받기 보다 열심히 했던 것을 이어가고 싶었다.&lt;/p&gt;

&lt;p&gt;그런데 내 블로그를 한 번 씩 읽어보면서 베이직, 챌린지때의 회고에서 내가 어떤 경험을 했고 또 구현과 학습의 사이에서 고민했던 흔적을 볼 수 있었다. 특히 챌린지때는 매주 내가 다음주에 개선해보면 좋을 것들을 생각하고 적용해봤던 것 같은데 그때 당시에 느꼈던 생생한 감정들은 이제는 회고를 통해서만 느낄 수 있다.&lt;/p&gt;

&lt;p&gt;그래서 늦었지만 더 까먹기전에 전체적인 회고를 한 번 진행해보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;네이버-부스트캠프-9기-웹모바일-지원&quot;&gt;네이버 부스트캠프 9기 웹모바일 지원&lt;/h1&gt;

&lt;p&gt;대학교를 다니면서 하고 싶었던게 중구난방으로 많았던 것 같다. 안드로이드, IOS 개발자가 되고 싶었다가 또 어느샌가 졸업프로젝트를 하면서는 자동화에 관심이 생겼다. 그리고 취업시장에 딱 나가려니 나만의 강점이 무엇인지 갈피를 잡지 못했다. 그래서 일단은 선택의 폭이 가장 넓은 백엔드 개발자가 되는것을 목표로 삼았다. 백엔드 개발자라고 하면 범주가 되게 크다고 느꼈고 추후에 여러 가지의 길 중에서 하나를 선택할 수 있을 것 같았다. 그래서 거의 백엔드 개발자의 바이블로 여겨지는 자바 + 스프링을 하면서 준비를 해야하나? 하고 고민하던 차에 네이버 부스트캠프 웹모바일이 눈에 띄었고 그때 당시는 별 고민없이 안되면 말고! 하고 지원했던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;1차-문제-해결력-테스트&quot;&gt;1차 문제 해결력 테스트&lt;/h1&gt;

&lt;p&gt;여기서부터 고민이었던 것은 역시 언어와 프레임워크이다. 자바 + 스프링은 백엔드 취업에 있어서 안정적이고 굳이 벗어날 필요가 없는 길이었다. 지금이라도 자바스프링을 공부해야할 것 같은데 네부캠은 자바스크립트로, 그것도 풀스택 과정을 밟아야 했다.&lt;/p&gt;

&lt;p&gt;그래서 네이버 부스트캠프를 지원할 당시에는 네이버 부스트캠프를 통해서 node.js 개발자가 될 지, 아니면 그냥 자바 + 스프링을 공부해서 자프링 개발자가 될 지 선택해야하는 느낌을 받았다. 내가 어떤 일을 할 지도 모르는데 언어와 프레임워크로 나의 개발 라이프 사이클을 결정하고 있었다.&lt;/p&gt;

&lt;p&gt;그리고 결국, 그래도 한 번 들어보고 결정하자라는 가벼운 마음으로 지원을 하게 되었다.&lt;/p&gt;

&lt;p&gt;1차 문제 해결력 테스트는 아마 기억상으로는 언어 제한이 크게 없었던 것 같다. 그래서 평소 코딩테스트 준비하던 파이썬으로 응시를 했고 무난하게 풀었던 것 같다.&lt;/p&gt;

&lt;p&gt;이제부터 있을 모든 테스트는 JS로 언어 제한이 되면서 사실상 자바스크립트를 무조건 공부해야한다는 생각이 들었다.&lt;/p&gt;

&lt;h1 id=&quot;베이직-과정&quot;&gt;베이직 과정&lt;/h1&gt;

&lt;p&gt;베이직 과정에서, 그때 당시에는 문제 구현이 어렵지 않다고 생각했다. 지금 생각해보면 운영진분들의 의도를 내가 명확하게 캐치하지 못했던 것 같기도 하다. 문제가 주어지면 나 스스로 어떻게 문제를 정의하고 해결할지에 가장 방점을 두었어야 했던 것 같은데 구현하는데 급급하지 않았나 싶다.&lt;/p&gt;

&lt;p&gt;이때까지는 베이직이 아니라 그냥 네이버 부스트캠프 자체를 제대로 이해하지 못했던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;챌린지-과정&quot;&gt;챌린지 과정&lt;/h1&gt;

&lt;p&gt;베이직 과정을 거치고 챌린지에 들어선 순간 정말 분위기가 너무 달랐다. 일단 100퍼센트 구현한다는 것 자체가 너무 어려워보였고 구현을 하기 위해 학습도 필요했다. 다른 캠퍼들은 어떻게 구현했는지도 배우면서 또 적용도 하고 나만의 학습 방식을 찾아가는 등, 챌린지 과정은 정말 힘들었고 열심히 했고 많이 배웠다.&lt;/p&gt;

&lt;p&gt;이때 아마 작년 기수 선배님들이 오셔서 “챌린지 과정 같은 기간은 다시 오지 않을 기간이다” 라고 했던 것이 아직도 기억에 남는다. 정말로 다시 경험하기 힘들 과정이었지만 많은 걸 배웠다.&lt;/p&gt;

&lt;h1 id=&quot;멤버십-과정&quot;&gt;멤버십 과정&lt;/h1&gt;

&lt;p&gt;챌린지 과정은 따로 작성해둔 회고가 있어서 이제 본론인 멤버십 과정에 대해서 얘기해보려고 한다.&lt;/p&gt;

&lt;p&gt;멤버십 과정은 첫 오프라인 일정이 있기도 했고 마지막에는 그룹프로젝트가 있어서 기대 반, 걱정 반으로 임했던 것 같다.&lt;/p&gt;

&lt;p&gt;멤버십 과정을 전반적으로 요약하자면 자기 주도적인 문제 해결이었던 것 같다. 멤버십 과정도 모든 것을 100퍼센트 구현하는게 매우 어려웠다. 그래서 학습과 구현사이에서 고민하고 문제를 어떻게 해결할 것인지에 대한 고민을 많이 했었다.&lt;/p&gt;

&lt;p&gt;미션을 하면서 어떻게 하면 프론트엔드에서 State, View 의 흐름을 최대한 단순하게 만들 수 있을까? 라는 고민을 했고 Flux 패턴을 처음 사용했던 Facebook 의 레포지토리에 들어가서 소스 코드를 직접 읽어보며 이해했던 것이 기억에 남는다. 나는 백엔드 개발자로 가고 싶다는 생각을 하고 있었음에도 프론트엔드에서 자주 사용하는 Flux 패턴이 백엔드 아키텍처에서도 충분히 도움이 될 것 같았다. 이때부터 조금씩 개발의 경계선이 무너졌다? 라고 해야할까 언어나 분야가 안중요한 것은 아니지만 다양한 경험도 해보고 싶어졌었다.&lt;/p&gt;

&lt;p&gt;그룹 프로젝트를 진행하면서 영상 도메인을 1순위로 선택해서 팀 매칭을 했는데, 다시 생각해보면 좋은 선택이었던 것 같다. 기획 1주, 마지막 코드프리징 1주를 제외하면 약 4주 동안에 빠르게 개발을 진행해야 했었는데 모든 팀원이 다같이 영상 도메인에 대해서는 사전 지식이 없었다. 우리는 영상 도메인을 활용해서 어떤 주제, 어떤 프로토콜을 사용할지를 학습했고 이를 다같이 공유하며 초반 기획을 다졌다. 그리고 백로그와 주간 이터레이터를 토대로 빠르게 구현을 진행했고 부족했던 사전 지식은 부딪혀보며 점차 메꾸어나갔다. 이 과정에서 초반에 기획한 백로그의 상당수를 덜어내게 되었는데 다시 생각해도 말도 안되는 양의 백로그를 처음에 작성했던 것 같다. 최소 기능을 만들고 기능을 점차 늘려나가는 것에 대한 필요성을 생각해보게 되었던 경험이었다.&lt;/p&gt;

&lt;p&gt;어느정도 기능과 구조에 가닥이 잡힌 이후로는 다같이 구현을 하며 지속적으로 프로젝트의 방향성에 대한 이야기를 나누었던 것 같다.&lt;/p&gt;

&lt;p&gt;챌린지때는 머리 싸매며 새벽까지 학습하고 구현하는 것에 정말 열심이었고, 멤버십은 프로젝트에 욕심이 계속 나서 더 잘하고 싶다는 생각에 즐겁게 힘들 수 있었던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;네이버-부스트-캠프&quot;&gt;네이버 부스트 캠프&lt;/h1&gt;

&lt;p&gt;네이버 부스트 캠프를 진행하면서 개발에 대한 생각이 많이 바뀌었다. 막 대학교를 마치고 나서는 자바 + 스프링을 배워서 빠르게 애플리케이션을 만들어보는 것에 집중하는게 맞다고 생각했었다. 지금은 어떤 언어, 어떤 프레임워크를 쓰든 간에 문제를 어떻게 정의하고 해결책에 근거를 가지는 것에 집중하고 있다. 그 과정에서 내가 선택한 기술이 어떤 원리로 돌아가는지까지 학습하는 것이 베스트인 것 같다.  원리를 알아야 응용이 가능하다.&lt;/p&gt;

&lt;p&gt;처음에 회고를 쓸지 말지 고민하던 이유가, ‘네이버 부스트캠프가 끝나면서 열심히 하던 습관을 잃어버릴까봐’ 였던 만큼 앞으로도 네부캠에서 했던 것을 기억하고 유지해나가고 싶다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;NaverBoostcamp&quot;]" /><category term="[&quot;NaverBoostcamp&quot;]" /><category term="NaverBoostcamp" /><category term="Review" /><summary type="html">1차 문제 해결력 테스트(2024.06.15) → 베이직 → 챌린지 → 멤버십 학습스프린트 → 멤버십 그룹프로젝트(2024.12.06) 를 진행하면서의 기억</summary></entry><entry><title type="html">운영체제(페이징, 캐시, 자원 경쟁)</title><link href="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)" rel="alternate" type="text/html" title="운영체제(페이징, 캐시, 자원 경쟁)" /><published>2025-02-04T04:41:00+00:00</published><updated>2025-02-04T04:41:00+00:00</updated><id>https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)">&lt;h1 id=&quot;pcb-와-컨텍스트-스위칭&quot;&gt;PCB 와 컨텍스트 스위칭&lt;/h1&gt;

&lt;p&gt;PCB(Process Control Block) 은 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터 블록이며, 커널 스택에 저장된다.&lt;/p&gt;

&lt;p&gt;각 프로세스가 생성될 때 마다 고유의 PCB가 생성 되고, 프로세스가 종료되면 PCB 는 제거된다.&lt;/p&gt;

&lt;h2 id=&quot;유저-메모리-커널-메모리&quot;&gt;유저 메모리, 커널 메모리&lt;/h2&gt;

&lt;p&gt;가상메모리는 유저메모리와 커널 메모리로 나뉜다.&lt;/p&gt;

&lt;p&gt;유저 메모리와 커널 메모리는 전부 스택 영역을 사용하기 때문에 유저 스택, 커널 스택이라고 부르기도 한다.&lt;/p&gt;

&lt;p&gt;여기서 커널 모드일때만 사용할 수 있는 메모리를 커널 메모리(스택)이라고 한다.&lt;/p&gt;

&lt;p&gt;반대로 유저 모드일때만 사용할 수 있는 메모리는 유저 메모리(스택) 이라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;pcb의-구조&quot;&gt;PCB의 구조&lt;/h1&gt;

&lt;p&gt;Process State : 대기중, 실행 중 등의 프로세스 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;Process Number : 각 프로세스의 고유 식별 번호&lt;/p&gt;

&lt;p&gt;Program Counter : 이 프로세스에 대해 실행될 다음 명령의 주소에 대한 포인터&lt;/p&gt;

&lt;p&gt;Registers : 레지스터 관련 정보&lt;/p&gt;

&lt;p&gt;Memory Limits : 프로세스의 메모리 관련 정보&lt;/p&gt;

&lt;p&gt;List of Open Files : 프로세스를 위해 열린 파일 목록들&lt;/p&gt;

&lt;h1 id=&quot;컨텍스트-스위칭&quot;&gt;컨텍스트 스위칭&lt;/h1&gt;

&lt;p&gt;앞서 설명한 PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정&lt;/p&gt;

&lt;p&gt;이는 프로세스가 종료되거나 인터럽트에 의해 발생된다.&lt;/p&gt;

&lt;h2 id=&quot;컨텍스트-스위칭의-비용&quot;&gt;컨텍스트 스위칭의 비용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;유휴시간의 발생 : 컨텍스트 스위칭을 할 때 마다 유휴시간이 생겨서 CPU의 가용성이 떨어진다.&lt;/li&gt;
  &lt;li&gt;캐시 미스 : 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시 클리어 과정이 무조건 일어나게되고, 이 때문에 캐시 미스가 발생
페이지 테이블에 가상 주소가 실제 주소와 매칭 되어 있음. 그 위에 TLB 캐싱 계층이 있는데, 계속 컨텍스트 스위칭을 하면 캐시 미스가 발생하게 된다. 따라서 캐시를 계속 바꿔야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;프로세스의-상태&quot;&gt;프로세스의 상태&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;프로세스의 상태변화&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;create&quot;&gt;CREATE&lt;/h2&gt;

&lt;p&gt;프로세스가 생성된 상태&lt;/p&gt;

&lt;p&gt;fork, exec 시스템 콜 등을 통해 프로세스가 생성된 상태이며 PCB 가 할당된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fork : 부모 프로세스를 복제해서 자식 프로세스를 생성한다.&lt;/li&gt;
  &lt;li&gt;exec: 현재 프로세스의 메모리 공간에 새로운 실행 파일을 로드하여 기존 프로그램을 대체한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보통은 fork 로 자식 프로세스를 생성한 후에, exec 로 해당 프로그램을 대체하는 방식을 주로 쓴다.&lt;/p&gt;

&lt;p&gt;생성되고 나서는 대기(Ready) 상태로 간다.&lt;/p&gt;

&lt;h2 id=&quot;ready&quot;&gt;Ready&lt;/h2&gt;

&lt;p&gt;처음 프로세스가 생성된 이후, 메모리 공간이 충분하면 메모리를 할당받고 아니면 준비큐에 들어가서 대기중인 상태&lt;/p&gt;

&lt;p&gt;이는 CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다리는 상태&lt;/p&gt;

&lt;h2 id=&quot;ready-suspend&quot;&gt;Ready Suspend&lt;/h2&gt;

&lt;p&gt;Ready 큐가 꽉찬 상태라서, 메모리가 부족하기 때문에 Ready 상태가 아닌 Ready Suspend 가 된 상태&lt;/p&gt;

&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;

&lt;p&gt;실행 상태는 CPU 소유권과 메모리를 할당받고 명령어를 수행 중인 상태.&lt;/p&gt;

&lt;p&gt;CPU Burst 가 일어났다고도 표현한다.&lt;/p&gt;

&lt;h2 id=&quot;blocked&quot;&gt;Blocked&lt;/h2&gt;

&lt;p&gt;어떤 이벤트가 발생한 이후, 잠시 중단되어 프로세스가 차단된 상태&lt;/p&gt;

&lt;p&gt;예를 들어 프린트 인쇄 버튼을 눌렀을 때 프린트 인쇄 I/O 인터럽트에 의해, 현재 실행중이던 프로세스가 잠시 Blocked 상태로 들어갈 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;blocked-suspend&quot;&gt;Blocked Suspend&lt;/h2&gt;

&lt;p&gt;Blocked 된 상태에서 프로세스가 실행되려고 했지만, 레디 큐로 들어가지 못하고 메모리 부족으로 또 다시 중단된 상태&lt;/p&gt;

&lt;h2 id=&quot;terminated--exit&quot;&gt;Terminated / Exit&lt;/h2&gt;

&lt;p&gt;프로세스 실행이 완료되어 해당 프로세스에 대한 자원을 반납하고, PCB 가 삭제된 상태.&lt;/p&gt;

&lt;p&gt;부모 프로세스가 자식 프로세스를 강제로 종료시킨 경우도 있다.&lt;/p&gt;

&lt;h1 id=&quot;브라우저&quot;&gt;브라우저&lt;/h1&gt;

&lt;p&gt;멀티 프로세싱 + 멀티 스레딩&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/5237120&quot;&gt;https://d2.naver.com/helloworld/5237120&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티-프로세싱&quot;&gt;멀티 프로세싱&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;브라우저의 멀티 프로세싱&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레딩&quot;&gt;멀티 스레딩&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc&quot;&gt;IPC&lt;/h1&gt;

&lt;p&gt;Inter Process Communication 이란 프로세스끼리 데이터를 주고 받고 공유 데이터를 관리하는 매커니즘이다.&lt;/p&gt;

&lt;p&gt;IPC 의 종류로는 공유 메모리, 파일, 소켓, 파이프, 메시지 큐가 있다.&lt;/p&gt;

&lt;h2 id=&quot;공유-메모리&quot;&gt;공유 메모리&lt;/h2&gt;

&lt;p&gt;프로세스와 프로세스가 메모리를 공유해서 데이터를 주고 받는 방식&lt;/p&gt;

&lt;p&gt;메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르지만, 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 동기화가 필요&lt;/p&gt;

&lt;p&gt;IPC 중에서 가장 빠른 통신 방법.&lt;/p&gt;

&lt;h2 id=&quot;파일&quot;&gt;파일&lt;/h2&gt;

&lt;p&gt;디스크에 저장된 데이터를 기반으로 통신한다.&lt;/p&gt;

&lt;p&gt;요즘엔 잘 쓰이지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;파이프&quot;&gt;파이프&lt;/h2&gt;

&lt;p&gt;파이프는 통신을 위한 메모리 공간(버퍼)를 생성해서 프로세스 간 통신을 하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;unnamed-pipe-익명-파이프&quot;&gt;(Unnamed Pipe) 익명 파이프&lt;/h3&gt;

&lt;p&gt;익명 파이프는 프로세스 사이에 FIFO 기반의 통신 채널을 만들어 통신하는 방식&lt;/p&gt;

&lt;p&gt;이름이 정해지지 않은, 즉 부를 수 없는 파이프라서 외부에서 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;단방향 통신이므로 양방향 통신을 하려면 2개의 익명 파이프가 필요&lt;/p&gt;

&lt;p&gt;부모, 자식 프로세스 간에서는 파일 디스크립션을 상속 받아서 사용할 수 있으며 다른 네트워크상에서는 사용이 불가능&lt;/p&gt;

&lt;p&gt;파이프의 데이터 용량은 제한되어 있으며 쓰기 프로세스가 읽기 프로세스보다 더 빠르게 데이터를 쓸 수는 없다&lt;/p&gt;

&lt;h3 id=&quot;named-pipe-명명-파이프&quot;&gt;Named Pipe (명명 파이프)&lt;/h3&gt;

&lt;p&gt;익명 파이프의 확장된 개념이며 부모, 자식 뿐만 아니라 다른 네트워크 상에서도 통신할 수 있는 파이프&lt;/p&gt;

&lt;p&gt;보통 서버, 클라이언트용 파이프를 구분해서 동작한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;파이프 시나리오&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;메세지-큐&quot;&gt;메세지 큐&lt;/h2&gt;

&lt;p&gt;메세지 큐는 자료구조 형태로 관리하는 버퍼를 만들어 통신하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;매세지 큐의 동작 방식&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스가 메세지를 보내거나 받기 전에 메세지 큐를 초기화&lt;/li&gt;
  &lt;li&gt;Sender 의 메세지는 큐에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복사&lt;/code&gt;되어 Receiver 에 전달된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;자원-경쟁&quot;&gt;자원 경쟁&lt;/h1&gt;

&lt;h2 id=&quot;공유자원&quot;&gt;공유자원&lt;/h2&gt;

&lt;p&gt;공유자원이란 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태&quot;&gt;경쟁 상태&lt;/h2&gt;

&lt;p&gt;경쟁 상태(Race Condition)은 이 공유 자원을 둘 이상의 프로세스 또는 스레드가 동시에 읽거나 쓰는 상황을 말하며, 동시에 접근을 시도할 때 예상되는 결과값에 영향을 줄 수 있는 상태를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;임계-영역&quot;&gt;임계 영역&lt;/h2&gt;

&lt;p&gt;임계 영역(Critical Section) 은 둘 이상의 프로세스 또는 스레드가 공유 자원에 접근할 때, 순서 등의 이유로 결과가 달라지는 코드 영역을 의미한다.&lt;/p&gt;

&lt;p&gt;즉 경쟁 상태에 있는 영역&lt;/p&gt;

&lt;p&gt;이 영역은 한 번에 둘 이상의 프로세스나 스레드가 접근할 수 없도록 설계된다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태-관리의-중요성&quot;&gt;경쟁 상태 관리의 중요성&lt;/h2&gt;

&lt;h3 id=&quot;데이터-정합성&quot;&gt;데이터 정합성&lt;/h3&gt;

&lt;p&gt;데이터 정합성(data consistency) 는 예상되는 데이터와 값이 같아야함을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-무결성&quot;&gt;데이터 무결성&lt;/h3&gt;

&lt;p&gt;데이터 무결성(data integrity) 는 데이터의 어떠한 규칙을 위반하지 않아야 함을 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 잔고가 음수가 될 수는 없다.&lt;/p&gt;

&lt;p&gt;또한 데이터가 전송, 저장되고 처리되는 모든 과정에서 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성을 말한다.&lt;/p&gt;

&lt;h1 id=&quot;경쟁-상태의-해결-조건&quot;&gt;경쟁 상태의 해결 조건&lt;/h1&gt;

&lt;p&gt;아래의 세 조건을 만족해야 경쟁 상태를 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;상호-배제&quot;&gt;상호 배제&lt;/h2&gt;

&lt;p&gt;상호 배제(mutual exclusion) 은 한 프로세스가 임계 영역에 들어갔을 때, 다른 프로세스는 들어갈 수 없음을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;한정-대기&quot;&gt;한정 대기&lt;/h2&gt;

&lt;p&gt;한정 대기(bounded waiting) 은 특정 프로세스가 임계영역 진입을 요청한 후, 해당 요청이 승인되기 전까지 다른 프로세스가 임계영역에 진입하는 횟수를 제한하는 것을 말하며, 이를 통해 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 되는 것을 방지한다.&lt;/p&gt;

&lt;p&gt;(자원이 독점되지 않도록)&lt;/p&gt;

&lt;h2 id=&quot;진행의-융통성&quot;&gt;진행의 융통성&lt;/h2&gt;

&lt;p&gt;진행의 융통성(progress) 는 만약 어떠한 프로세스도 임계 영역을 사용하지 않는다면, 임계영역 외부의 어떠한 프로세스도 들어갈 수 있으며 이 때 프로세스끼리 서로 방해하지 않는 것을 의미한다.&lt;/p&gt;

&lt;h1 id=&quot;경쟁-상태의-해결-방법&quot;&gt;경쟁 상태의 해결 방법&lt;/h1&gt;

&lt;h2 id=&quot;뮤텍스&quot;&gt;뮤텍스&lt;/h2&gt;

&lt;p&gt;뮤텍스(mutex) 는 공유 자원을 lock() 을 통해 잠금 설정하고 사용한 후에, unlock() 을 통해 잠금해제한다.&lt;/p&gt;

&lt;p&gt;이러한 객체 Lock 을 기반으로 경쟁 상태를 해결하는데, 잠금 상태가 되면 다른 프로세스나 스레드는 해당 코드 영역에 접근할 수 없고, 해제되면 가능하다.&lt;/p&gt;

&lt;p&gt;한 번에 하나의 프로세스만 임계 영역에 있을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;세마포어&quot;&gt;세마포어&lt;/h2&gt;

&lt;p&gt;세마포어(semaphore) 는 일반화된 뮤텍스를 의미한다.&lt;/p&gt;

&lt;p&gt;정수 S, Wait(), Signal() 을 통해서 공유 자원에 대한 접근을 처리한다. 이를 통해 여러 프로세스가 동시에 임계 영역에 접근할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S : 현재 쓸 수 있는 공유 자원의 수&lt;/li&gt;
  &lt;li&gt;Wait() : S 를 1씩 감소 시킨다. 만약 S가 음수라면 공유 자원에 대한 접근은 못하고 블락된 채, 대기열로 들어간다.&lt;/li&gt;
  &lt;li&gt;Signal() : S 를 1씩 증가 시킨다. 프로세스가 공유 자원 사용을 마친 상태이고, S 가 0 이하라면 대기열에 있던 프로세스가 동작하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;바이너리-세마포어&quot;&gt;바이너리 세마포어&lt;/h3&gt;

&lt;p&gt;바이너리 세마포어는 0과 1 두 가지 값만 가질 수 있는 세마포어이다.&lt;/p&gt;

&lt;p&gt;구현의 유사성으로 인해 뮤텍스는 바이너리 세마포어와 유사하다고 할 수 있으나, 뮤텍스는 잠금을 기반으로 상호 배제가 일어나는 잠금 매커니즘이고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 매커니즘이다.&lt;/p&gt;

&lt;h3 id=&quot;카운팅-세마포어&quot;&gt;카운팅 세마포어&lt;/h3&gt;

&lt;p&gt;카운팅 세마포어는 S의 숫자가 1보다 큰, 세마포어를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;모니터&quot;&gt;모니터&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;모니터&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체이다.&lt;/p&gt;

&lt;p&gt;이를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다.&lt;/p&gt;

&lt;h1 id=&quot;교착-상태&quot;&gt;교착 상태&lt;/h1&gt;

&lt;p&gt;교착상태(deadlock) 은 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말한다.&lt;/p&gt;

&lt;p&gt;각각의 프로세스는 서로가 원하는 자원을 유지한 채, 다른 프로세스의 자원을 얻기를 기다린다.&lt;/p&gt;

&lt;p&gt;교착상태가 발생하기 위한 4가지 필요조건은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상호 배제: 주어진 시간 내에 하나의 프로세스만 자원을 독점할 수 있다. 즉 다른 프로세스들은 접근이 불가능&lt;/li&gt;
  &lt;li&gt;점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하며 대기하는 상태&lt;/li&gt;
  &lt;li&gt;비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.&lt;/li&gt;
  &lt;li&gt;환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결-방법-1-bankers-algorithm&quot;&gt;해결 방법 1. Banker’s Algorithm&lt;/h2&gt;

&lt;p&gt;교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당가능 여부를 파악하는 ‘은행원 알고리즘(banker’s algorithm)’&lt;/p&gt;

&lt;p&gt;은행원 알고리즘은 교착 상태를 회피하는 알고리즘으로, 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정, 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘&lt;/p&gt;

&lt;p&gt;안정 상태 : 교착 상태를 일으키지 않은 상태이며, 프로세스의 최대 자원 요구량을 운영체제가 충족시킬 수 있는 상태&lt;/p&gt;

&lt;p&gt;불안정 상태 : 안전 상태로 가는 순서열이 존재하지 않는 상태&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;은행원 알고리즘 예시1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;은행원 알고리즘 예시1&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;해결방법-2-3&quot;&gt;해결방법 2, 3&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지우기&lt;/li&gt;
  &lt;li&gt;해결 방법은 아니지만, 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 오히려 더 클 수도 있다. 따라서 교착 상태가 발생하면 사용자의 작업을 종료시켜버린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;cpu-스케줄링-알고리즘&quot;&gt;CPU 스케줄링 알고리즘&lt;/h1&gt;

&lt;p&gt;스케줄링 알고리즘에는 선점형(preemptive) 알고리즘과, 비선점(non-preemtive)형 알고리즘이 있다.&lt;/p&gt;

&lt;p&gt;중간에 인터럽트를 발생시켜서 강제적으로 컨텍스트 스위칭을 일으키는 것이 선점형알고리즘,&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 종료될 때 까지 대기하고 컨텍스트 스위칭을 일으키는 것이 비선점형 알고리즘이다.&lt;/p&gt;

&lt;h2 id=&quot;비선점형-알고리즘&quot;&gt;비선점형 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;fcfsfirst-come-first-saved&quot;&gt;FCFS(First Come, First Saved)&lt;/h3&gt;

&lt;p&gt;가장 먼저 온 것을 가장 먼저 처리하는 알고리즘&lt;/p&gt;

&lt;p&gt;길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상(convoy effect) 가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;FCFS 알고리즘 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;p1 → p2 → p3 → p4&lt;/p&gt;

&lt;p&gt;p1 이 버스트 타임이 길기 때문에 나머지가 오래 기다려야 한다.&lt;/p&gt;

&lt;h3 id=&quot;sjf-shortest-job-first&quot;&gt;SJF (Shortest Job First)&lt;/h3&gt;

&lt;p&gt;실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘.&lt;/p&gt;

&lt;p&gt;긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation) 이 일어날 수 있지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;평균 대기 시간이 가장 짧다&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하지만 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행 정보를 토대로 추측해야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;실행시간이 매우 긴 프로세스가 있으면 레디큐에서 계속 대기할 확률이 매우 높다.&lt;/p&gt;

&lt;h3 id=&quot;우선-순위-알고리즘&quot;&gt;우선 순위 알고리즘&lt;/h3&gt;

&lt;p&gt;오래된 작업일수록 우선순위를 높이는 방법(aging) 을 통해 SJF 의 단점을 보완한 알고리즘&lt;/p&gt;

&lt;p&gt;우선순위는 작업의 시간, 프로세스의 메모리 요구사항, 열린 파일 수, 평균 CPU 사용량 등을 고려해서 설정&lt;/p&gt;

&lt;h2 id=&quot;선점형-알고리즘&quot;&gt;선점형 알고리즘&lt;/h2&gt;

&lt;p&gt;현대 운영체제가 쓰고 있는 방식으로, 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권을 할당할 수 있는 방식&lt;/p&gt;

&lt;h3 id=&quot;라운드-로빈-rr-round-robin&quot;&gt;라운드 로빈 (RR, Round Robin)&lt;/h3&gt;

&lt;p&gt;현재 컴퓨터가 쓰는 스케쥴링 방법이자 단순한 선점형 알고리즘&lt;/p&gt;

&lt;p&gt;각 프로세스에게 동일한 할당 시간을 주고, 그 시간 안에 끝나지 않으면 다시 준비 큐의 마지막으로 들어가는 알고리즘.&lt;/p&gt;

&lt;p&gt;그런데 동일한 할당 시간을 q 라고 할 때, q 를 너무 크게 주면 사실 상 들어온 순서대로 프로세스를 진행하는 FCFS 가 되어버린다. 따라서 q 를 적절히 조절할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;너무 작게 하면 컨텍스트 스위칭이 너무 많이 일어나면서 오버헤드가 과하게 생길 수 있다.&lt;/p&gt;

&lt;p&gt;일반적으로 전체 작업 시간은 길어지지만, 평균 응답 시간은 짧아진다는 특징이 있다.&lt;/p&gt;

&lt;h3 id=&quot;srfshortest-remaining-time-first&quot;&gt;SRF(Shortest Remaining Time First)&lt;/h3&gt;

&lt;p&gt;SRF 는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 즉시 중지하고 더 짧은 프로세스를 수행한다.&lt;/p&gt;

&lt;p&gt;SJF 는 비선점형이기 때문에 해당 프로세스가 끝나야 그 다음 제일 짧은 프로세스를 수행하는 것과의 차이가 있다.&lt;/p&gt;

&lt;h3 id=&quot;다단계-큐&quot;&gt;다단계 큐&lt;/h3&gt;

&lt;p&gt;우선순위에 따른 준비 큐를 여러 개 사용하고, 큐 마다 라운드 로빈이나 FCFS 등 다른 스케쥴링 알고리즘을 적용한 것을 말한다.&lt;/p&gt;

&lt;p&gt;큐 간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징이 있다.&lt;/p&gt;

&lt;p&gt;우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리 되지 않는 기아 현상(starvation) 이 발생할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;캐시&quot;&gt;캐시&lt;/h1&gt;

&lt;p&gt;데이터를 미리 복사해 놓는 임시 저장소이자, 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다. 이를 통해 데이터 접근 시간의 단축, 데이터를 다시 계산하는 등의 시간을 절약할 수 있다.&lt;/p&gt;

&lt;p&gt;캐시의 예로 CPU 레지스터를 들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;캐시-설정-원리&quot;&gt;캐시 설정 원리&lt;/h2&gt;

&lt;p&gt;캐시를 설정할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자주 사용하는 데이터&lt;/code&gt; 를 기반으로 설정해야 한다.&lt;/p&gt;

&lt;p&gt;이 때 지역성을 기반으로 설정하게 되는데 지역성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시간 지역성&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공간 지역성&lt;/code&gt; 으로 나뉜다.&lt;/p&gt;

&lt;h3 id=&quot;시간-지역성&quot;&gt;시간 지역성&lt;/h3&gt;

&lt;p&gt;시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성&lt;/p&gt;

&lt;h3 id=&quot;공간-지역성&quot;&gt;공간 지역성&lt;/h3&gt;

&lt;p&gt;공간 지역성은 최근 접근한 데이터를 이루고 이쓴ㄴ 공간이나 그 가까운 공간에 접근하는 특성&lt;/p&gt;

&lt;h2 id=&quot;캐시-매핑&quot;&gt;캐시 매핑&lt;/h2&gt;

&lt;p&gt;캐시의 크기는 메모리보다 항상 작기 때문에 효율적으로 매핑하는 것이 중요하며 매핑 방식에는 직접 매핑, 연관 매핑, 집합 - 연관 매핑이 있다.&lt;/p&gt;

&lt;h3 id=&quot;직접-매핑direct-mapping&quot;&gt;직접 매핑(direct mapping)&lt;/h3&gt;

&lt;p&gt;직접 블록별로 매핑을 한다.&lt;/p&gt;

&lt;p&gt;캐시가 다섯 블록이라면, 메모리를 5개의 영역으로 나누어서 각각의 영역당 하나의 캐시에 매핑 할 수 있도록 만든다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;특정 라인과 특정 블록이 매핑되어 있는 것&lt;/p&gt;

&lt;p&gt;메모리 블록의 사이즈는 메모리의 크기 / 캐시의 블록 개수&lt;/p&gt;

&lt;p&gt;운영체제는 보통 메모리를 똑같은 크기의 페이지(보통 4kb)&lt;/p&gt;

&lt;p&gt;4kb 인 이유? : &lt;a href=&quot;https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80&quot;&gt;https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;블록 당 영역이 정해져있기 때문에, 같은 블록에서 여러 개를 캐싱할 수 없다.&lt;/p&gt;

    &lt;p&gt;따라서 같은 블록의 참조가 빈번하다면 계속 캐시를 스와핑해주어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대신 특정 정보의 캐시를 찾을 때 특정 블록만 찾으면 된다는 장점이 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연관-매핑associative-mapping&quot;&gt;연관 매핑(associative mapping)&lt;/h3&gt;

&lt;p&gt;순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하며 메모리의 컨텐츠가 캐시의 어느 위치에도 올라갈 수 있는 방법(자유롭게 캐싱)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특정 정보의 캐시를 찾을 때, 모든 캐시를 탐색해야한다.&lt;/li&gt;
  &lt;li&gt;그러나 스와핑이 빈번하게 일어나지는 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;집합-연관-매핑set-associate-mapping&quot;&gt;집합 연관 매핑(set associate mapping)&lt;/h2&gt;

&lt;p&gt;집합을 나누고(집합 매핑과 유사) 해당 집합에는 block descriptor 만 같으면 들어올 수 있게 하는데, 이 때 어떤 블럭에도 들어갈 수 있게 한다.(연관 매핑과 유사)&lt;/p&gt;

&lt;p&gt;즉 캐시의 집합을 나누었는데, 집합에 1개의 블록만 있다면 직접 매핑이고, 캐시 집합이 1개라면 연관 매핑인 것이다.&lt;/p&gt;

&lt;p&gt;이를 통해 모든 블럭을 찾을 필요 없이, 특정 블럭을 찾게 해 탐색 비용을 낮춘 직접매핑의 장점과 스와핑을 완화시키는 연관매핑의 장점을 모두 지니게 된다.&lt;/p&gt;

&lt;h1 id=&quot;메모리-할당&quot;&gt;메모리 할당&lt;/h1&gt;

&lt;p&gt;프로그램에 필요한 메모리를 할당할 때 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데 이는 연속할당과 불연속 할당으로 나뉜다.&lt;/p&gt;

&lt;h2 id=&quot;연속-할당&quot;&gt;연속 할당&lt;/h2&gt;

&lt;p&gt;메모리에 연속적으로 공간을 할당하는 것. 사용 가능한 모든 메모리 공간이 같은 위치에 있다.&lt;/p&gt;

&lt;p&gt;즉 메모리 파티션이 전체 메모리 공간에 분산되어 있지 않다.&lt;/p&gt;

&lt;p&gt;이는 고정분할방식과 가변분할방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;고정-분할-방식&quot;&gt;고정 분할 방식&lt;/h3&gt;

&lt;p&gt;고정분할방식은 메모리를 미리 같은 크기로 분할해서 할당하는 방법.&lt;/p&gt;

&lt;p&gt;고정 크기를 프로그램에 할당하므로, 프로그램의 크기보다 더 큰 메모리를 할당하게 된다.&lt;/p&gt;

&lt;p&gt;따라서 내부 단편화(internal framentation)가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;가변-분할-방식&quot;&gt;가변 분할 방식&lt;/h3&gt;

&lt;p&gt;가변분할방식은 프로그램에 필요한 만큼 동적으로 할당하는 방법.&lt;/p&gt;

&lt;p&gt;내부 단편화가 아닌 외부 단편화가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/13.png&quot; alt=&quot;13&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;가변 분할 방식에는 최초 적합, 최적 적합, 최악 적합이 있다.&lt;/p&gt;

&lt;p&gt;홀(hole) : 할당할 수 있는, 비어 있는 메모리 공간&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최초 적합(frist fit) : 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당&lt;/li&gt;
  &lt;li&gt;최적 적합(best fit) : 필요한 메모리 크기 이상인 공간 중에서 가장 작은 홀에 할당&lt;/li&gt;
  &lt;li&gt;최악 적합(worst fit) : 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불연속-할당&quot;&gt;불연속 할당&lt;/h2&gt;

&lt;p&gt;메모리를 연속적으로 할당하지 않는 방법으로, 현대 운영체제가 쓰는 방법.&lt;/p&gt;

&lt;p&gt;프로그램에 필요한 메모리를 쪼개어 서로 다른 위치에 있는 메모리 공간에 할당&lt;/p&gt;

&lt;p&gt;페이징, 세그멘테이션, 페이지드 세그멘테이션 기법이 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이징&quot;&gt;페이징&lt;/h3&gt;

&lt;p&gt;페이징은 동일한 크기의 페이지 단위(보통 4kb)로 나누어 메모리의 서로 다른 위치에 프로세스를 할당&lt;/p&gt;

&lt;p&gt;홀의 크기가 균일하지 않은 문제는 없어지지만 주소 변환을 페이지별로 해야 하기 때문에 주소 변환이 복잡해지는 단점이 있다.&lt;/p&gt;

&lt;p&gt;외부 단편화가 생겨도 분할해서 할당할 수 있기 때문에, 외부 단편화를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;그렇지만 결국 동일한 크기의 페이지 단위로 나눈다는 것은 언제나 내부 단편화를 유발할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;세그멘테이션&quot;&gt;세그멘테이션&lt;/h3&gt;

&lt;p&gt;페이지 단위가 아닌, 의미 단위인 세그먼트로 나누는 방식(즉, 동일한 크기가 아닐 수 있다.)&lt;/p&gt;

&lt;p&gt;프로세스는 코드, 데이터, 스택, 힙으로 나누어져서 메모리가 할당되는데 코드와 데이터, 또는 코드와 스택 등으로 나눌 수도 있으며 함수 단위로도 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;공유와 보안 측면에서 좋지만 홀 크기가 균일하지 않게 된다.&lt;/p&gt;

&lt;p&gt;내부 단편화는 해결될 수 있지만, 다시 외부 단편화가 일어날 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이지드-세그멘테이션&quot;&gt;페이지드 세그멘테이션&lt;/h3&gt;

&lt;p&gt;세그멘테이션으로 나누되, 해당 세그멘테이션을 동일한 크기의 페이지로 나누는 방법&lt;/p&gt;

&lt;p&gt;세그먼트에 의해 1kb, 5kb 로 나뉘었다면 이를 2kb 기준으로 나누어 2kb, (2kb, 2kb, 2kb) 로 나누는 방식&lt;/p&gt;

&lt;h1 id=&quot;busy-wait&quot;&gt;busy wait&lt;/h1&gt;

&lt;p&gt;busy wait 는 프로세스, 스레드가 어떠한 일을 실행하기 전에 만족하는 조건을 지속적으로 확인하는 동기화 기술이다.&lt;/p&gt;

&lt;p&gt;프로세스1이 점유하고 있는 자원을, 프로세스 2가 사용하고 싶을 때 blocking 되고 대기하는 과정이다.&lt;/p&gt;

&lt;h1 id=&quot;운영체제와-펌웨어의-차이&quot;&gt;운영체제와 펌웨어의 차이&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;펌웨어는 ROM 이라고 불리는 비휘발성 메모리 하나를 쓰는 반면, 운영체제는 휘발성 비휘발성 메모리를 계층화해서 사용한다.&lt;/li&gt;
  &lt;li&gt;펌웨어는 자유롭게 프로그램을 설치할 수 없으며, 미리 설치해놓은 프로그램을 기반으로 업데이트가 일어난다.
ROM 에 해당 소프트웨어를 지우고 덮어쓰면서 업데이트가 발생. → 멱등성처럼 변화를 최소화 하는 느낌인거 같다
반면, 운영체제는 정기적으로 업데이트 되며 프로그램을 자유롭게 설치할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="운영체제" /><summary type="html">PCB 와 컨텍스트 스위칭</summary></entry><entry><title type="html">백준 21939 문제 추천 시스템 Version 1</title><link href="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1" rel="alternate" type="text/html" title="백준 21939 문제 추천 시스템 Version 1" /><published>2025-02-03T08:07:00+00:00</published><updated>2025-02-03T08:07:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1">&lt;p&gt;&lt;img src=&quot;/upload/2025-02-03-백준_21939_문제_추천_시스템_Version_1.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;문제 추천 시스템 Version 1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;recommend(x) : x 가 1이면 난이도 가장 높은 문제를 우선순위 큐에서 출력, x 가 -1 이면 난이도가 가장 쉬운 문제를 출력.&lt;/p&gt;

    &lt;p&gt;→ 우선 순위큐를 minHeap, maxHeap 두 개를 써야겠다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;add(P, L) : 문제 번호가 P, 난이도가 L 인 문제를 추가&lt;/p&gt;

    &lt;p&gt;→ 2개의 우선순위 큐에 전부 넣어야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;solved(P) : 문제 번호가 P인 문제를 풀었다는 의미이므로, recommend 를 할 때 풀었던 문제는 추천하지 않도록 어딘가에 저장해두어야 함.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제는 우선순위 큐와 Map 혹은 Object 를 쓰면 쉽게 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;문제가 Solved 되면 Map 혹은 Object 에 기억해뒀다가, recommend 명령어에 의해서 문제를 추천할 때 Solved 된 문제라면 다음 Min (혹은 Max) Heap 에서 하나를 더 꺼내면 된다.&lt;/p&gt;

&lt;p&gt;그래서 문제 난이도가 그렇게 높게 잡히지는 않았는데 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javascript 에 우선순위 큐가 없다&lt;/code&gt;는 점이다.&lt;/p&gt;

&lt;p&gt;추가로 PriorityQueue 의 heap 을 일반 배열이 아닌 Queue 를 직접 구현했는데, 문제를 풀면서 heap 에 직접 shift 를 해야하는 경우가 필요하다고 착각했다.  dequeue 를 여러 번 하면 되는 일이었는데.&lt;/p&gt;

&lt;p&gt;자바스크립트는 배열의 shift 가 O(1) 이 아닌 O(n) 이다보니, shift 를 하려면 Queue 를 직접 구현해야해서 사용하면서도 일반 배열처럼 사용할 수 있는 방법을 고민하면서 풀었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Queue 에 배열처럼 index 만으로 접근하고 싶었는데 내가 만든 Queue 는 head 와 tail 로 이동하기 때문에 head 로 인덱스의 값을 보정해야했다.&lt;/p&gt;

&lt;p&gt;덕분에 모든 자료구조를 다 직접 짜면서 하다보니 코드가 엄청나게 길어졌다.&lt;/p&gt;

&lt;p&gt;아래는 삽질한 코드이다..&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Problem {
    constructor(num, level) {
        this.num = num;
        this.level = level;
    }
}

class PriorityQueue {
    heap = new Queue();

    constructor(comparator) {
        if(comparator) this.comparator = comparator.bind(this);
        else this.comparator = (a, b) =&amp;gt; this.heap.get(a) - this.heap.get(b);
    }

    enqueue(value){
        const heapLength = this.heap.push(value);
        this.bubbleUp(heapLength - 1);
    }

    peek(){
        return this.heap.get(0);
    }

    dequeue(){
        if(this.isEmpty()) return undefined;

        const root = this.heap.get(0);
        const leap = this.heap.pop();
        if(this.isEmpty()) return root;
        this.heap.set(0, leap);
        this.bubbleDown(0);

        return root;
    }

    bubbleUp(index_){
        let index = index_;
        while(index &amp;gt; 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if(this.comparator(index, parentIndex) &amp;gt;= 0) break;
            this.swap(index, parentIndex);
            index = parentIndex;
        }
        return index;
    }

    bubbleDown(index_){
        let index = index_;
        let smallestIndex = index;
        while(smallestIndex &amp;lt; this.heap.length){

            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;

            if(leftChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(leftChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = leftChildIndex;
            }
            if(rightChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(rightChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = rightChildIndex;
            }

            if(smallestIndex === index) break;
            this.swap(index, smallestIndex);
            index = smallestIndex;
        }
        return index;
    }

    isEmpty(){
        return this.heap.length === 0;
    }

    swap(i, j){
        const restore = this.heap.get(i);
        this.heap.set(i, this.heap.get(j));
        this.heap.set(j, restore);
    }
}

class Queue {
    items = {}
    head = 0;
    tail = 0;

    get length(){
        return this.tail - this.head;
    }

    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }

    constructor() {}

    push(value){
        this.items[this.tail] = value;
        this.tail += 1;
        return this.length;
    }

    pop(){
        if(this.isEmpty()) return undefined;
        const leaf = this.items[this.tail - 1];
        delete this.items[this.tail - 1];

        if(!this.isEmpty()) this.tail -= 1;
        return leaf;
    }

    isEmpty(){
        if(this.head !== this.tail) return false

        this.head = this.tail = 0;
        return true

    }
}

class ProblemPriorityQueue extends PriorityQueue {
    solvedProblems = {}
    constructor(comparator) {
        super(comparator);
    }
    solved(index){
        this.solvedProblems[index] = true;
    }

    peek(){
        this.removeSolvedProblem();
        return super.peek();
    }

    removeSolvedProblem(){
        let peek = super.peek();
        while(peek.num in this.solvedProblems){
            super.dequeue();
            delete this.solvedProblems[peek.num];
            peek = super.peek();
        }
    }
}

function minComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(a).level - this.heap.get(b).level;
    return this.heap.get(a).num - this.heap.get(b).num;
}

function maxComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(b).level - this.heap.get(a).level;
    return this.heap.get(b).num - this.heap.get(a).num;
}

function add(P, L){
    minPPQ.enqueue(new Problem(P, L));
    maxPPQ.enqueue(new Problem(P, L));
}

function solved(P) {
    minPPQ.solved(P);
    maxPPQ.solved(P);
}

function recommend(x){
    if(x === -1) {
        return minPPQ.peek().num;
    } else {
        return maxPPQ.peek().num;
    }
}

const readline = require(&quot;readline&quot;);
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let N = -1;
let M = -1;
let count = -1;
let answer = [];
const minPPQ = new ProblemPriorityQueue(minComparator);
const maxPPQ = new ProblemPriorityQueue(maxComparator);

rl.on(&quot;line&quot;, (line) =&amp;gt; {
    if(N === -1){
        N = parseInt(line);
        count = N;
    } else if (count &amp;gt; 0) {
        const [num, level] = line.split(&apos; &apos;).map((n) =&amp;gt; parseInt(n))
        add(num, level);
        count -= 1;
    } else {
        if(M === -1) M = parseInt(line);
        else {
            const [cmd, num1, num2] = line.split(&apos; &apos;);
            if (cmd === &apos;recommend&apos;) {
                const log = recommend(parseInt(num1));
                answer.push(log);
            } else if (cmd === &apos;solved&apos;) {
                solved(parseInt(num1));
            } else {
                add(parseInt(num1), parseInt(num2))
            }
        }
    }
}).on(&quot;close&quot;, () =&amp;gt; {
    console.log(answer.join(&apos;\n&apos;));
})


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="Algorithm" /><category term="JavaScript" /><summary type="html">문제 추천 시스템 Version 1</summary></entry><entry><title type="html">JS TS 로 Queue 구현</title><link href="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84" rel="alternate" type="text/html" title="JS TS 로 Queue 구현" /><published>2025-01-31T07:42:00+00:00</published><updated>2025-01-31T07:42:00+00:00</updated><id>https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84</id><content type="html" xml:base="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84">&lt;h1 id=&quot;objector-map-을-활용한-queue&quot;&gt;Object(or Map) 을 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class ObjectQueue {
    item = {};
    start = 0;
    end = 0;

    constructor() {}

    enqueue(value){
        this.item[this.end] = value;
        this.end += 1;
        return this.end - 1;
    }
    
     // 큐가 비어 있을 때는 undefined, 그렇지 않은 경우 0 번째 원소를 반환
    dequeue(){
        if(this.isEmpty()) return undefined;
        const value = this.item[this.start];
        delete this.item[this.start];
        this.start += 1;
        return value;
    }

    isEmpty(){
        if(this.start === this.end) {
            this.start = 0;
            this.end = 0;
            return true;
        }
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Object 나 Map 을 활용해서 key-value 형식으로 저장한다.&lt;/p&gt;

&lt;p&gt;다만 Object, Map 이 사용하는 메모리가 다른 방법에 비해 많아, 메모리 효율은 다소 떨어질 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;linkedlist-를-활용한-queue&quot;&gt;LinkedList 를 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Node {
    value = null;
    next = null
    constructor(value) {
        this.value = value;
    }
}

class LinkedListQueue {
    front = null;
    rear = null;
    length = 0;

    enqueue(value){
        const newNode = new Node(value);
        // rear 가 null 인, 초기 상황일 때
        if(!this.rear) {
            this.front = this.rear = newNode;
        } else {
            // 현재 맨 마지막 노드의 다음 노드를 newNode 로 지정하고, newNode 를 마지막 노드로 지정
            this.rear.next = newNode;
            this.rear = newNode;
        }
        this.length += 1;
    }

    dequeue() {
        if(!this.front) {
            return undefined;
        }
        const value = this.front.value;
        this.front = this.front.next;

        // 하나를 dequeue 하고 Queue 에 아무것도 없을 때
        if(!this.front) {
            this.rear = null;
        }
        this.length -= 1;

        return value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;원형-큐&quot;&gt;원형 큐&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularQueue&amp;lt;T&amp;gt; {
    private readonly items: (T | null)[];
    private readonly capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueue(value: T) {
        if (this.isFull()) return false;
        this.items[this.rear] = value;

        // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 front 까지 다시 사용
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
        return true;
    }

    dequeue() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        
         // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 rear 까지 다시 사용
        this.front = (this.front + 1) % this.capacity; 
        this.size--;
        return value;
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐는 고정 사이즈를 정하고, 고정 사이즈만큼의 배열을 순환하면서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 만약 배열이 꽉 찼는데도 enqueue 가 일어나면 문제가 된다. 배열에 이미 값이 존재하는데 그 위에 덮어쓰게 되기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 원형큐가 가득 찼으면 배열을 그 순간에 늘리거나 해야한다.&lt;/p&gt;

&lt;p&gt;이 과정에서 기존 배열을 복사해야해서 시간이 많이 소요된다.&lt;/p&gt;

&lt;p&gt;이렇게 보면 원형큐는 dequeue 보다 enqueue 가 월등히 많은 경우, 썩 좋지 못할 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;원형-덱deque-double-ended-queue&quot;&gt;원형 덱(deque, Double Ended Queue)&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularDeque&amp;lt;T&amp;gt; {
    private items: (T | null)[];
    private capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueueFront(value: T) {
        if (this.isFull()) this.resize();
        this.front = (this.front - 1 + this.capacity) % this.capacity;
        this.items[this.front] = value;
        this.size++;
    }

    enqueueBack(value: T) {
        if (this.isFull()) this.resize();
        this.items[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
    }

    dequeueFront() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        return value as T;
    }

    dequeueBack() {
        if (this.isEmpty()) return undefined;
        this.rear = (this.rear - 1 + this.capacity) % this.capacity;
        const value = this.items[this.rear];
        this.items[this.rear] = null;
        this.size--;
        return value as T;
    }

    peekFront() {
        return this.isEmpty() ? undefined : (this.items[this.front]);
    }


    peekBack() {
        return this.isEmpty() ? undefined : (this.items[(this.rear - 1 + this.capacity) % this.capacity]);
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }

    getSize() {
        return this.size;
    }

    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐와 큰 차이는 없다.&lt;/p&gt;

&lt;p&gt;여기서 원형 큐나, 원형 데크나 resize 부분을 알아둬야한다.&lt;/p&gt;

&lt;h2 id=&quot;resize&quot;&gt;Resize&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;resize 부분을 보면 capacity 를 2배(혹은 원하는 만큼) 늘리고나서&lt;/p&gt;

&lt;p&gt;for 문 내부에서 아이템을 복제 및 정렬을 한다.&lt;/p&gt;

&lt;p&gt;언뜻 생각해보면 capacity 만 2배로 복제해도 되지 않을까 싶지만 기존 배열의 순서를 정렬해서 새로운 배열에 적용해야만 한다.&lt;/p&gt;

&lt;p&gt;예시를 들어서 살펴보면,&lt;/p&gt;

&lt;h3 id=&quot;기존-상태-1234-덱에-삽입&quot;&gt;기존 상태 (1,2,3,4 덱에 삽입)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 1  ] [ 2  ] [ 3  ] [ 4  ]  
Front → index 0
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-2-dequeue&quot;&gt;1, 2 dequeue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ X  ] [ X  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-6-enqueue&quot;&gt;5, 6 enqueue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 2 (가득 참)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-enqueue-resize-실행&quot;&gt;7 enqueue (Resize 실행)&lt;/h3&gt;

&lt;p&gt;단순히 Capacity 만 늘리는 경우(잘못된 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
	Index:      0      1      2      3      4      5      6      7
	Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ] [ X  ] [ X  ] [ X  ] [ X  ]
	Front → index 2
	Rear  → index 4
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3 → 4→ 5→ 6 순서가 아니라, 5 → 6 → 3→ 4 가 되어버린다.&lt;/p&gt;

&lt;p&gt;따라서 3,4,5,6 순서로 정렬시켜주는 과정이 필요&lt;/p&gt;

&lt;p&gt;resize 및 정렬 과정(올바른 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3      4      5      6      7
Items:    [ 3  ] [ 4  ] [ 5  ] [ 6  ] [ X  ] [ X  ] [ X  ] [ X  ]
Front → index 0
Rear  → index 4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Algorithm" /><category term="JavaScript" /><category term="TypeScript" /><summary type="html">Object(or Map) 을 활용한 Queue</summary></entry><entry><title type="html">리눅스 컨테이너</title><link href="https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88" rel="alternate" type="text/html" title="리눅스 컨테이너" /><published>2025-01-27T03:16:00+00:00</published><updated>2025-01-27T03:16:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88">&lt;p&gt;도커 등의 컨테이너 기술을 사용하면서, 리눅스의 어떤 명령어들로 이런 컨테이너 기술이 동작할 수 있는지 문득 궁금해졌다.&lt;/p&gt;

&lt;h1 id=&quot;linux-namespace&quot;&gt;Linux Namespace&lt;/h1&gt;

&lt;p&gt;리눅스 네임스페이스는 리눅스 커널에서 제공하는 기능으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스가 시스템의 특정 리소스를 독립적으로 볼 수 있도록 격리하는 매커니즘&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 개의 마운트 네임스페이스 A, B 를 생성했을 때, 각자의 작업이 서로에게 영향을 끼치지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 A 네임스페이스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/test&lt;/code&gt; 를 만들었어도, B 네임스페이스에서는 /test 에 접근 할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;unshare&quot;&gt;unshare&lt;/h2&gt;

&lt;p&gt;마운트 네임스페이스를 직접 생성하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshare --mount {실행파일}&lt;/code&gt; 을 통해서 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;이 명령어를 통해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshare&lt;/code&gt; 이라는 시스템콜이 {실행파일} 인자 (→ CLONE_NEWNS 파라미터)와 함께 사용된다.&lt;/p&gt;

&lt;p&gt;unshare 명령을 사용한 프로세스가 부모 프로세스가 되고, 자식 프로세스를 생성 할 때 마운트 네임스페이스를 생성하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 부모 프로세스가 가지고 있던 마운트 포인트가 자식 프로세스에게 그대로 복사가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;proc&quot;&gt;proc&lt;/h3&gt;

&lt;p&gt;마운트 네임스페이스를 직접 생성해보자.&lt;/p&gt;

&lt;p&gt;마운트 네임스페이스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 디렉토리에 존재한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;proc 디렉토리는 시스템의 프로세스 및 스레드에 대한 상태 정보를 포함한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;proc 파일 시스템은 시스템에 있는 각 활성 프로세스 및 스레드의 상태에 대한 액세스를 제공한다.&lt;/p&gt;

&lt;p&gt;proc 디렉토리 내부를 보게 되면 프로세스 아이디로 이루어진 폴더들과 여러가지 정보(cpuinfo, meminfo, devices…) 등이 있는걸 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;ls /proc&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;현재 사용하고 있는 Shell 의 프로세스 아이디를 찾아서 /proc 에서 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
echo $$

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 명령어를 통해 프로세스 아이디를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 찾아낸 프로세스 아이디를 proc 에서 확인해보면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;ls /proc/{PID} 혹은 ls/proc/$$&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이런식으로 많은 것들이 들어있다.&lt;/p&gt;

&lt;p&gt;여기서 이 프로세스의 마운트 네임스페이스 번호를 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;프로세스의 마운트 네임스페이스&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc/$$/ns/mnt&lt;/code&gt; 로 프로세스의 마운트 네임스페이스를 확인할 수 있는데, 이는 symbolic link 라서 readlink 명령어를 통해서 symbolic link 의 값을 읽어보자.&lt;/p&gt;

&lt;h3 id=&quot;unshare-mount&quot;&gt;unshare —mount&lt;/h3&gt;

&lt;p&gt;4026531841 이 현재 프로세스의 pid 인걸 기억해두고 새로운 shell 창을 하나 더 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;shell 2개&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사진이 조금 이상해보일 수 있지만 쉘 창을 왼쪽과 오른쪽에 띄워놓은 상태이다.&lt;/p&gt;

&lt;p&gt;두 shell 창의 마운트 네임스페이스를 보면 같은 걸 알 수 있는데, 기본적으로 shell 창을 열든 ssh를 통해서 접속하든 새로운 마운트 네임스페이스를 만들지는 않는다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo unshare --mount /bin/sh&lt;/code&gt; 명령어를 통해서 오른쪽에 새로운 마운트 네임스페이스를 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;새로운 마운트 네임스페이스 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--mount&lt;/code&gt; 옵션을 주지 않으면, 새로운 마운트 네임스페이스를 만들지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;—mount 옵션 없이 unshare&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;왼쪽과 오른쪽 쉘의 mount namespace 가 같은 것을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;findmnt--a&quot;&gt;findmnt -A&lt;/h3&gt;

&lt;p&gt;다시 새로운 마운트 네임스페이스로 넘어와서, —mount 옵션을 주면서 새로운 마운트 네임스페이스를 생성하면 부모 네임스페이스로부터 마운트 포인트를 복사해서 자식 네임스페이스로 전달한다는 걸 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findmnt - A&lt;/code&gt; 옵션을 통해 마운트 포인트를 전부 확인할 수 있는데, 출력 순서가 조금 뒤바뀌었지만 값은 전부 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;자식-네임스페이스와-부모-네임스페이스는-서로-영향을-미치지-않는다&quot;&gt;자식 네임스페이스와 부모 네임스페이스는 서로 영향을 미치지 않는다.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;부모 프로세스에서 마운트 포인트 만들기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 부모 마운트 네임스페이스에서 새롭게 마운트를 했을 때, 자식 마운트 네임스페이스에 영향을 미치는지 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
sudo mount -t tmpfs tmpfs /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 위의 명령어를 통해 새로운 마운트 포인트를 하나 만들어볼건데, /tmp/mount_test 라는 디렉토리에 tmpfs 타입을 마운트 한다.&lt;/p&gt;

&lt;p&gt;여기서 tmpfs 는 임시 파일 시스템을 의미하는데, RAM을 기반으로 하는 가상 파일 시스템이다.&lt;/p&gt;

&lt;p&gt;RAM 은 휘발되기 때문에 시스템을 종료하면 당연히 다 없어진다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 를 통해 마운트가 되었는지도 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;df 명령어는 disk free 의 약자로, 파일 시스템의 디스크 사용량을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;-h 옵션은 human-readable, 즉 사람이 읽기 쉽게 포매팅 해준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ df -h
Filesystem                         Size  Used Avail Use% Mounted on
tmpfs                              391M  1.4M  389M   1% /run
efivarfs                           256K   27K  230K  11% /sys/firmware/efi/efivars
/dev/mapper/ubuntu--vg-ubuntu--lv   30G  7.9G   21G  28% /
tmpfs                              2.0G     0  2.0G   0% /dev/shm
tmpfs                              5.0M     0  5.0M   0% /run/lock
/dev/vda2                          2.0G  190M  1.6G  11% /boot
/dev/vda1                          1.1G  6.4M  1.1G   1% /boot/efi
tmpfs                              391M   12K  391M   1% /run/user/1000
tmpfs                              2.0G     0  2.0G   0% /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findmnt -A&lt;/code&gt; 를 통해서도 확인해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ findmnt -A | grep /tmp/mount_test
└─/tmp/mount_test              tmpfs                             tmpfs       rw,relatime,inode64

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 부모 네임스페이스에서는 tmpfs 를 새롭게 마운트했는데, 자식 네임스페이스에서 이를 확인할 수 있는지 살펴보자.&lt;/p&gt;

&lt;p&gt;아래는 자식 네임스페이스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 를 한 결과이다.&lt;/p&gt;

&lt;p&gt;살펴보면 /tmp/mount_test 의 마운트 포인트는 없다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
# df -h
Filesystem                         Size  Used Avail Use% Mounted on
/dev/mapper/ubuntu--vg-ubuntu--lv   30G  7.9G   21G  28% /
tmpfs                              2.0G     0  2.0G   0% /dev/shm
tmpfs                              391M  1.4M  389M   1% /run
tmpfs                              5.0M     0  5.0M   0% /run/lock
tmpfs                              391M   12K  391M   1% /run/user/1000
efivarfs                           256K   27K  230K  11% /sys/firmware/efi/efivars
/dev/vda2                          2.0G  190M  1.6G  11% /boot
/dev/vda1                          1.1G  6.4M  1.1G   1% /boot/efi

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마찬가지로 부모 네임스페이스에서 mount_test 를 언마운트해도 자식 네임스페이스에 영향을 끼치지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ sudo umount /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(이름이 umount 인 이유는 검색해보니 초기 유닉스 시스템에서는 명령어의 길이 제한을 6글자 이하로 하는 경우가 많았기 때문이라고 한다.)&lt;/p&gt;

&lt;p&gt;이처럼 mount namespace 를 활용하면 각 컨테이너마다 독립된 파일 시스템을 만들 수 있다. 이는 도커같은 컨테이너 기술에서 핵심 축을 담당하고 있다.&lt;/p&gt;

&lt;p&gt;심지어 루트 디렉토리도 리눅스 시스템이 부팅될 때, 커널이 루트 파일 시스템(/) 을 마운트하는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;chroot&quot;&gt;chroot&lt;/h1&gt;

&lt;p&gt;chroot 는 change root 의 약자로, 유닉스 운영 체제에서 현재 실행 중인 프로세스와 자식 프로세스 그룹에서 루트 디렉토리를 변경하는 작업이다.&lt;/p&gt;

&lt;p&gt;이렇게 루트 디렉토리가 변경된 환경에서 실행되는 프로그램은 지정된 디렉토리 트리 밖의 파일들의 이름을 지정할 수 없다.&lt;/p&gt;

&lt;p&gt;chroot 환경을 사용하려면, 커널 가상 파일 시스템과 구성 파일 또한 호스트에서 chroot 로 마운트 혹은 복사가 되어야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래와 같은 디렉토리 구조에서, chroot 를 통해 루트 디렉토리를 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;chroot 로 루트 디렉토리 변경&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;만약 왼쪽과 같은 구조에서 Nginx 를 실행시키면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;만약 아무런 설정도 하지 않았다면 당연히 환경변수에 따라 /usr/sbin/nginx, /usr/bin/nginx 등에서 nginx 실행 파일을 찾기 시작할 것이다. 여기서도 마찬가지로 /lib 를 찾지, /test/lib 를 찾지는 않는다. 따라서 환경 변수를 따로 지정해주어야 할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 우리가 컨테이너를 쓰는 이유는 하나의 nginx 를 모든 컨테이너에서 사용하기 위함이 아니라(물론 이런 경우도 있을수도 있지만 보통은), nginx 가 필요한 컨테이너만큼 새로운 nginx 를 설치하기 위함이지 않을까?&lt;/p&gt;

&lt;p&gt;각 컨테이너마다 nginx 의 설정도 다르게 하고 싶은 등의 이유로 nginx 를 컨테이너마다 다 넣어놨더니, 컨테이너의 루트 디렉토리가 호스트의 루트 디렉토리라서 실행을 할 수가 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 각 컨테이너마다 루트 디렉토리를 변경함으로써 오른쪽 그림의 형태로 바꾸어준다면 모든 컨테이너마다 각자 자신의 /etc/nginx 를 참조하면 각기 다른 Nginx 를 실행할 수 있지 않을까?&lt;/p&gt;

&lt;p&gt;따라서 위의 unshare 를 설명하면서 사용했던 옵선에, chroot 도 붙여보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
unshare --mount chroot test /bin/bash
# unshare --mount chroot {directory} /bin/bash

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;취약점&quot;&gt;취약점&lt;/h2&gt;

&lt;p&gt;chroot 는 루트 디렉토리를 바꿈으로써 독립적인 환경을 제공해줄 것 같지만, 사실 그렇지는 않다.&lt;/p&gt;

&lt;p&gt;눈에 보이는 루트 디렉토리를 변경해주는 일을 하지만, 호스트에서 동작하는 프로세스를 kill 하거나 디렉토리를 타고 올라가서 chroot 로 제한한 루트 디렉토리를 벗어나서 탐색할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
# chroot 내부에서 실행
mkdir /escape
mount --bind / /escape  # 호스트 루트 파일 시스템을 다시 마운트
ls /escape              # chroot 외부 파일 시스템에 접근 가능

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 취약점이 발생하는 이유는 chroot 가 root 경로와 현재 작업 경로를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상대경로&lt;/code&gt; 로 바꾸기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;pivot_root&quot;&gt;pivot_root&lt;/h1&gt;

&lt;p&gt;chroot 의 취약점을 개선하기 위해 pivot_root 를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;chroot 는 root 등을 상대경로로 바꾸었다면, pivot_root 는 기존의 루트 디렉토리를 백업해서 다른 경로로 바꿔버리고 원하는 디렉토리를 루트로 바꿔버린다.&lt;/p&gt;

&lt;p&gt;다시 말해서 루트 파일 시스템을 스왑한다.&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=CIvwIplZS1U&quot;&gt;https://www.youtube.com/watch?v=CIvwIplZS1U&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=OYM8OGKlufY&quot;&gt;https://www.youtube.com/watch?v=OYM8OGKlufY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;proc&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/docs/ko/aix/7.3?topic=files-proc-file&quot;&gt;https://www.ibm.com/docs/ko/aix/7.3?topic=files-proc-file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;chroot&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/Chroot&quot;&gt;https://ko.wikipedia.org/wiki/Chroot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;readlink&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man1/readlink.1.html&quot;&gt;https://man7.org/linux/man-pages/man1/readlink.1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Linux" /><summary type="html">도커 등의 컨테이너 기술을 사용하면서, 리눅스의 어떤 명령어들로 이런 컨테이너 기술이 동작할 수 있는지 문득 궁금해졌다.</summary></entry><entry><title type="html">상호 배타적 집합 (Union-Find)</title><link href="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)" rel="alternate" type="text/html" title="상호 배타적 집합 (Union-Find)" /><published>2025-01-26T07:18:00+00:00</published><updated>2025-01-26T07:18:00+00:00</updated><id>https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)">&lt;p&gt;상호 배타적이라는 것은, 공통 원소가 없는 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 상호 배타적 집합이라는 것은 공통 원소가 없은 부분 집합으로 이루어진 집합이다.&lt;/p&gt;

&lt;p&gt;상호 배타적 집합을 Union-FInd 라고도 부르는 이유는, 이러한 집합을 만드는데 아래와 같은 Union, Find 과정을 수행하기 때문이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;처음 상태는 각각 자기 자신만을 포함한 집합을 생성한다. (초기화 단계)&lt;/li&gt;
  &lt;li&gt;이제 두 원소 a, b 가 주어질 때 이들이 속한 두 집합을 하나로 합친다. (Union 연산)&lt;/li&gt;
  &lt;li&gt;어떤 원소 a 가 주어질 때, 이 원소가 속한 집합을 찾는다. (Find 연산)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어 1부터 n 까지의 숫자 중에서 2로 나눈 나머지에 대해 상호 배타적 집합을 만든다고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;2로 나눈 나머지에 따른 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 트리 구조로 원소들을 묶으면서 하나의 부분 집합을 표현할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;union&quot;&gt;Union&lt;/h2&gt;

&lt;p&gt;Union 과정은 이처럼 두 개의 트리 구조를 하나로 합치는 과정을 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 왼쪽의 2로 나눈 나머지가 0인 트리가 합쳐지기 전을 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합 2, 6 이 아직 합쳐지지않은 상태&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;아직 2 와 6 이 같은 트리로 합쳐지지 않은 상황이다.&lt;/p&gt;

&lt;p&gt;여기서 우리는 2와 6은 짝수이기 때문에 같은 집합에 속한다는 것을 알고있다.&lt;/p&gt;

&lt;p&gt;따라서 Union 과정을 거쳐야하고 6의 부모 노드를 2로 지정함으로써 맨 처음의 그래프와 같이 하나의 트리 구조로 만들 수 있는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;find&quot;&gt;Find&lt;/h2&gt;

&lt;p&gt;기본적으로 Find 과정은 부모노드를 타고 올라가면서, 최종적으로는 해당 집합의 루트 노드를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;루트 노드가 집합을 대표하는 격이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 위의 트리에서 4와 12가 같은 집합에 속해있는지 어떻게 알 수 있을까?&lt;/p&gt;

&lt;p&gt;4와 12 각각 루트노드가 나올때까지 부모노드를 타고 올라가보면 된다.&lt;/p&gt;

&lt;p&gt;그렇게 더이상 올라갈 수 있는 노드가 없을 때, 즉 루트 노드까지 왔을 때 4의 루트노드와 12의 루트노드를 비교해보면 된다.&lt;/p&gt;

&lt;p&gt;여기서는 둘 다 루트노드가 2로 같기 때문에 같은 집합에 속하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;최적화를-하지-않은-구현&quot;&gt;최적화를 하지 않은 구현&lt;/h2&gt;

&lt;p&gt;우선 Find 연산에서 봤듯이, 부모 노드에 대한 정보가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;반대로 부모 노드에서 자식 노드로 내려갈 일은 없다.&lt;/p&gt;

&lt;p&gt;따라서 Union-FInd 자료구조를 구현하기 위해서는 부모 노드에 대한 정보를 저장할 수 있는 자료구조를 선택하면 된다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 고려하지 않은, 굉장히 간단한 UnionFind 를 한 번 구현해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size){
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
    }
    
    union(a, b){
        const root_a = this.find(a);
        const root_b = this.find(b);
        
        // 같은 집합에 속해있지 않을 경우
        // 최적화 없는 버전!
        if(root_a !== root_b) this.parent[root_b] = root_a;
    }
    
    find(node){
        // 경로 압축 최적화가 없는 버전!
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 find 메서드부터 개선점을 찾아보자.&lt;/p&gt;

&lt;h3 id=&quot;find-개선하기-경로-압축&quot;&gt;Find 개선하기 (경로 압축)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;초기화 단계&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우선 2,4,6,8,10,12,14 가 초기화 단계로, 각자 자기 자신을 가지고 있는 집합인 상황에서부터 시작해보자.&lt;/p&gt;

&lt;p&gt;여기서 별 생각 없이 2와 4를 Union 하면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;2와 4를 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 이번에 4와 6을 union 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;4 와 6을 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 보아하니 아마도 최종적으로 이런 트리가 생성될 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;일자로 쭉~&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 되면 루트 노드를 찾아야하는 find 연산의 특성 상, 트리의 레벨에 직접적으로 영향을 받을 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 find 를 최적화하기 위해서 트리의 레벨을 줄여야하니까, 이런 그래프가 가장 좋은게 아닐까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;레벨을 1로 최적화한 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 어느 노드에서 find 메서드를 실행해도 바로 루트 노드가 나오게 된다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 이런 식으로 최적화할 수 있을까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
   	// 경로 압축 최적화가 없는 버전!
    find(node){
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }

    // 경로 압축 최적화
    find(node){
        if(this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
            return this.parent[node];
        }
        return node
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;맨 처음부터 완벽하게 최적화된 트리를 얻을 수는 없다. 다만 find 를 한 번 하고나면 최적화되도록 구현할 수는 있다.&lt;/p&gt;

&lt;p&gt;경로 압축을 하지 않는 경우는 루트 노드를 찾으면 그대로 루트 노드를 반환했다.&lt;/p&gt;

&lt;p&gt;반면 경로 압축을 하는 경우에는 루트 노드를 찾았을 때, 루트 노드를 찾기 전까지 거쳐온 노드들의 부모 노드를 루트 노드로 갱신하는 과정이 있다.&lt;/p&gt;

&lt;h3 id=&quot;union-개선하기-union-by-rank&quot;&gt;Union 개선하기 (union by rank)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;레벨이 1, 2 인 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 두 트리를 union 시킨다고 해보자.&lt;/p&gt;

&lt;p&gt;먼저 왼쪽의 레벨2 트리에, 오른쪽 트리의 레벨 1을 합치면 아래와 같은 트리가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;레벨이 1인 트리를, 레벨이 2인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 경우에는 기존의 레벨이 2인 트리와 동일하게 레벨이 2로 유지됨을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이번에는 방향을 거꾸로 해서 합쳐보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;레벨이 2인 트리를, 레벨이 1인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기존의 레벨이 1인 트리의 레벨이 2로 늘어나는 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 트리의 레벨이 늘어나는것을 최소화하기 위해서는 레벨이 높은 트리에, 레벨이 낮은 트리를 합치는 것이 좋다.&lt;/p&gt;

&lt;p&gt;이런 방식을 랭크에 의한 합치기(union by rank) 라고 한다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 해보면,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;최적화를-한-구현union-by-rank-경로-압축&quot;&gt;최적화를 한 구현(union by rank, 경로 압축)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size) {
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
        this.rank = Array(size).fill(0); // 초기 랭크는 모두 0
    }

    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

    find(node) {
        if (this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
        }
        return this.parent[node];
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Algorithm" /><summary type="html">상호 배타적이라는 것은, 공통 원소가 없는 것이다.</summary></entry><entry><title type="html">스패닝 트리</title><link href="https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC" rel="alternate" type="text/html" title="스패닝 트리" /><published>2025-01-20T02:16:00+00:00</published><updated>2025-01-20T02:16:00+00:00</updated><id>https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC">&lt;h1 id=&quot;스패닝-트리&quot;&gt;스패닝 트리&lt;/h1&gt;

&lt;p&gt;어떤 무향 그래프의 스패닝 트리는 원래 그래프의 정점 전부와 간선의 부분 집합으로 구성된 부분 그래프이다.&lt;/p&gt;

&lt;p&gt;스패닝 트리에 포함된 간선들은 정점들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 형태로 전부 연결해야하는데, 이는 사이클이 없고 정점들이 꼭 부모-자식 관계로 연결될 필요는 없다는걸 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;예시 그래프&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 예시 그래프에서 스패닝 트리를 그려보자. 스패닝 트리는 유일하지 않을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/1.png&quot; alt=&quot;1&quot; /&gt;_올바른 스패닝 트리 1 _&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;올바른 스패닝 트리 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;스패닝 트리는 모든 정점이 연결되어 있거나, 사이클이 있으면 안된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;잘못된 스패닝 트리 1 (모든 정점이 연결되어 있지 않음)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;잘못된 스패닝 트리 2 (모든 정점이 연결되어 있지만 사이클이 존재)&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;최소-스패닝-트리&quot;&gt;최소 스패닝 트리&lt;/h1&gt;

&lt;p&gt;가중치가 있는 그래프에서, 스패닝 트리 중 가중치의 합이 가장 작은 트리를 최소 스패닝 트리라고 한다.&lt;/p&gt;

&lt;p&gt;최소 스패닝 트리를 찾는 알고리즘에는 크게 두 가지가 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;크루스칼&lt;/li&gt;
  &lt;li&gt;프림&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;간선이 하나도 없는 상태&lt;/code&gt; 에서 시작해 하나씩 트리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치가 가장 작은 간선&lt;/code&gt;을 추가해 가는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그리디 알고리즘&lt;/code&gt; 으로, 접근 방법이 달라보이지만 같은 방법으로 증명할 수 있다는 특징도 있다.&lt;/p&gt;

&lt;h2 id=&quot;크루스칼-알고리즘&quot;&gt;크루스칼 알고리즘&lt;/h2&gt;

&lt;p&gt;크루스칼의 기본적인 아이디어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치가 작은 간선이 최소 스패닝 트리에 포함될 가능성이 높다&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;그래서&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 간선의 가중치를 오름차순으로 정렬한다&lt;/li&gt;
  &lt;li&gt;가중치가 작은 순서대로 스패닝 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt;단, 스패닝 트리에 사이클이 생기지 않도록 한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 방식으로 모든 간선을 한 번씩 검사하고 나면 크루스칼 알고리즘은 종료된다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-동작-방식&quot;&gt;알고리즘 동작 방식&lt;/h3&gt;

&lt;p&gt;이제 예시를 들어, 한 번 직접 진행해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;크루스칼 알고리즘의 예시 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우선 가중치들을 정렬하면 [1, 2, 3, 4, 5, 6, 7, 9] 가 될 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가중치가 가장 작은 A - C (1) 을 선택해보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;처음 뽑는 간선이다보니 당연히 사이클은 그려지지 않을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;가중치가 1인 A - C 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;두 번째로 작은 E - F (2) 를 선택하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;가중치가 2인 E - F 산텍&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;마찬가지로, C - D (3) 과 A - B (4) 를 선택해보자&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;가중치가 3인 C - D, 가중치가 4인 A - B 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이제 남은 간선중에 가중치가 가장 작은 B - C (5) 를 선택하려고 보니, A - B - C 간의 사이클이 발생한다.
마찬가지로 그 다음 가중치가 작은 B - D (6) 을 선택하면 A - B - D -C 간의 사이클이 발생한다.&lt;/li&gt;
  &lt;li&gt;사이클이 생기지 않는 선에서 가장 작은 가중치를 갖는 D - F (7) 을 연결한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;가중치가 7인 D - F 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;C - E 도 마찬가지로 사이클이 생기기 때문에 선택하지 않는다.&lt;/li&gt;
  &lt;li&gt;모든 간선에 대해 검사를 완료했으므로 종료한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;사이클-검사-방법&quot;&gt;사이클 검사 방법&lt;/h3&gt;

&lt;p&gt;알고리즘 동작 방식을 봤을 때, 딱히 어려울 게 없어 보이는 단순한 방식으로 보인다.&lt;/p&gt;

&lt;p&gt;다만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사이클이 생기는지&lt;/code&gt; 확인하는 작업을 어떻게 하는지를 고민해봐야 할 것 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결국 스패닝 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 이므로 트리에 간선을 추가한 뒤에, 이 간선의 역방향 간선이 존재하는지를 DFS 로 탐색하면 어떨까?&lt;/p&gt;

&lt;p&gt;예를 들어 A - B (4) 를 스패닝 트리에 추가하고 모든 간선마다 DFS 를 수행한다.&lt;/p&gt;

&lt;p&gt;방문 기록을 저장해두면서 DFS 를 타고가다가, 이미 방문했던 곳을 방문한다면 사이클이 생긴 것이다.&lt;/p&gt;

&lt;p&gt;이 과정을 간선을 추가할 때 마다 진행하면 된다.&lt;/p&gt;

&lt;p&gt;이 방법은 구현하기에 매우 간단하겠지만 시간 복잡도를 생각해봤을 때, DFS 의 시간복잡도인 O(V+E) 에 E 를 곱한, O(E^2) 가 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Union-Find&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 정점을 잇는 간선에서, 이 간선이 사이클을 만들어내는지 확인하려면 두 정점이 같은 그룹에 있는지 확인하면 된다. 그리고 같은 그룹이 아니라면, 간선을 추가하면서 같은 그룹으로 만들어주는 작업을 반복하면 사이클 검사를 쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 자료구조를 만족하는 Union-Find 를 활용하면 쉽게 사이클을 검사할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;Union-Find 사이클 탐색 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 가중치가 1인 A - C 를 검사해보자.&lt;/p&gt;

&lt;p&gt;초기화단계에서는 A부터 F까지 어디에도 연결되지 않은 상태이므로, 당연히 자기 자신을 부모노드로 가진 채 초기화되어있을 것이다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 A 와 C 는 같은 집합에 존재하지 않기 때문에 사이클이 생기지 않는다고 확신할 수 있다.&lt;/p&gt;

&lt;p&gt;이후에 C 의 부모 노드를 A 로 바꾸면서 같은 집합으로 만들어준다.&lt;/p&gt;

&lt;p&gt;이어서 E - F (2) 도 Union 하고 나서 C - D(3) 를 보자.&lt;/p&gt;

&lt;p&gt;C 의 부모노드는 이미 A 이고, D 의 부모노드는 자신(D) 이다.&lt;/p&gt;

&lt;p&gt;둘이 같은 집합이 아니므로 D의 부모노드를 A로 바꾼다.&lt;/p&gt;

&lt;p&gt;A - B 도 마찬가지로, B의 부모노드가 A 로 바뀐다.&lt;/p&gt;

&lt;p&gt;이제 가중치가 5인 B - C 를 추가할지 말지 결정해야한다.&lt;/p&gt;

&lt;p&gt;B와 C의 루트노드를 살펴보니 전부 다 A 인 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 사이클이 생길 수 있는 간선이므로 추가하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h3&gt;

&lt;p&gt;Union-Find 연산은 현실적으로 매우 짧은 시간(상수 시간)으로 봐도 되기 때문에 실제 트리를 만드는 for 문의 시간 복잡도는 O(E) 라고 봐도 좋다.&lt;/p&gt;

&lt;p&gt;간선 리스트의 정렬에 걸리는 시간은 O(ElogE) 이기 때문에 O(ElogE) 가 전체 시간 복잡도가 된다.&lt;/p&gt;

&lt;h3 id=&quot;증명&quot;&gt;증명&lt;/h3&gt;

&lt;p&gt;크루스칼 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 간선을 그래프에 추가할 때, 뒤에 오는 간선들에 대한 고려는 전혀 하지 않으므로&lt;/code&gt; 탐욕적 알고리즘으로 분류할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;탐욕적 선택 속성은 우리가 내리는 탐욕적인 선택으로 인해 손해를 볼 일이 없음을 증명해야한다.&lt;/li&gt;
  &lt;li&gt;항상 최적의 선택만을 내려도 전체 문제의 최적해를 얻을 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 두 가지의 증명을 함으로서 크루스칼 알고리즘의 정당성을 증명할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가장 짧은 간선을 선택해도 손해를 볼 일이 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 증명은 귀류법으로 할 수 있다.&lt;/p&gt;

&lt;p&gt;크루스칼 알고리즘이 선택한 간선 루트가 올바르지 않다고 가정을 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;예시 그래프&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;크루스칼 알고리즘은 A → B → C → D → F → E 를 최선으로 골랐는데, 실제로는 A → B → C → E → F → D 였다고 가정해보자.&lt;/p&gt;

&lt;p&gt;크루스칼은 C - D 간선을 선택했지만 실제로는 C - D 간선이 아니라 C - E 간선을 선택해야 최소 스패닝 트리라는 것이다.&lt;/p&gt;

&lt;p&gt;크루스칼은 항상 가중치의 최솟값부터 선택해나간다. 따라서 C - D 의 가중치가 C - E 보다 작기 때문에 크루스칼 알고리즘이 C - D 를 선택했을 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 만약에 C - E 간선을 제거하고, C - D 간선을 연결하면 어떻게 될까? 이 또한 스패닝 트리가 되는 것을 알 수 있다. 따라서 가중치가 더 작은 간선을 선택해서 스패닝트리를 만들 수 있으므로, 처음의 A → B → C → E → F → D 가 최소 스패닝 트리라는 가정에서 모순 된다.&lt;/p&gt;

&lt;p&gt;일반화를 시키자면, 실제 최소 스패닝트리 T 에 속하지 않으면서 크루스칼 알고리즘이 선택한 간선을 (u, v) 라고 하자. T 또한 스패닝 트리이므로 u 와 v 는 어떤 식으로든 연결이 되어 있을 것이다. 크루스칼 알고리즘은 최솟값부터 선택해나가므로 T에는 존재하지만 크루스칼이 선택하지 않은 간선 (a, b) 는 (u, v) 보다 무조건 가중치가 같거나 높을 수 밖에 없다. (a, b) 가 (u, v) 보다 가중치가 낮았다면 크루스칼은 (u, v) 가 아니라 (a, b) 를 선택했을 것이다.&lt;/p&gt;

&lt;p&gt;이제 T 에서 u 와 v 를 잇는 경로 상의 어떠한 간선 하나를 제거하고, (u, v) 간선을 선택해보자. 이 때 간선 하나를 없앴지만 (u, v) 간선이 생겼으므로 스패닝 트리가 유지됨을 알 수 있고, 같거나 더 짧은 간선을 선택하면서 스패닝트리를 유지할 수 있으므로 T가 최소 스패닝 트리라는 가정에 모순이 생긴다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;항상 최적의 선택(남은 간선 중에, 사이클이 생기지 않는 가장 짧은 간선을 선택)만을 내려도 전체 문제의 최적해를 얻을 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이는, 매 단계마다 선택되는 간선이 항상 최적의 부분 문제 해를 만족한다는 점에서 최적 부분 구조가 성립함을 쉽게 알 수 있다.&lt;/p&gt;

&lt;p&gt;매 단계마다 선택하는 가장 짧은 간선은, 그 간선이 만드는 그래프 자체를 가장 짧은 경로로 갈 수 있게 한다. 따라서 항상 최적의 부분 문제 해를 만족하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;프림-알고리즘&quot;&gt;프림 알고리즘&lt;/h2&gt;

&lt;p&gt;크루스칼 알고리즘은 어느 간선이든 최솟값이면 선택하지만 프림 알고리즘은 현재 만들어진 트리에 이어진 간선만을 선택해나가면서 스패닝 트리를 만들게 된다.&lt;/p&gt;

&lt;p&gt;프림 알고리즘도 트리에 이어진 간선 중에서 최솟값을 선택하기 때문에 크루스칼 알고리즘과 비슷하기도 하다.&lt;/p&gt;

&lt;p&gt;그런데 이런 과정을 어딘가에서 많이 본 것 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점을 추가하면서, 정점에 연결된 간선 중에서 가장 짧은 간선을 선택해나가는 방식&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방식은 다익스트라 알고리즘과 상당히 유사해보인다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-동작-방식-1&quot;&gt;알고리즘 동작 방식&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;프림 알고리즘 예시 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프로 동작 방식을 한 번 살펴보자. 시작점은 A 라고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/13.png&quot; alt=&quot;13&quot; /&gt;&lt;em&gt;A - C 간선, 정점 C 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/14.png&quot; alt=&quot;14&quot; /&gt;&lt;em&gt;C - D 간선, 정점 D 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/15.png&quot; alt=&quot;15&quot; /&gt;&lt;em&gt;A - B 간선, 정점 B 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/16.png&quot; alt=&quot;16&quot; /&gt;&lt;em&gt;D - F 간선, 정점 F 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 왜, 더 짧은 간선인 B - C(5), B - D(6) 을 선택하지 않았냐면 이미 정점 리스트에 들어가있는 C 와 D 를 잇는 간선이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/17.png&quot; alt=&quot;17&quot; /&gt;&lt;em&gt;E - F 간선, 정점 E 추가&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;증명-1&quot;&gt;증명&lt;/h3&gt;

&lt;p&gt;프림 알고리즘은 크루스칼 알고리즘과 동일하게 간선의 최솟값을 사용하므로 증명이 크루스칼 알고리즘과 똑같다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Algorithm" /><summary type="html">스패닝 트리</summary></entry><entry><title type="html">정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)</title><link href="https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)" rel="alternate" type="text/html" title="정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)" /><published>2025-01-16T02:20:00+00:00</published><updated>2025-01-16T02:20:00+00:00</updated><id>https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)">&lt;p&gt;정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;다익스트라&quot;&gt;다익스트라&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;단일 시작점 최단 경로 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다익스트라 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;너비 우선 탐색과 유사&lt;/code&gt; 한 형태를 가진 알고리즘으로, 시작점에서 가까운 순서대로 정점을 방문한다. 다만 가중치(거리)가 있다보니 BFS 와 완전히 동일한 방식을 사용할 수는 없다.&lt;/p&gt;

&lt;h2 id=&quot;우선순위-큐&quot;&gt;우선순위 큐&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐&lt;/code&gt; 를 활용한다. 우선순위 큐에 대한 자바스크립트의 구현은 &lt;a href=&quot;/우선순위_큐&quot;&gt;여기&lt;/a&gt; 를 참고하면 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(정점의 번호, 정점까지의 거리)&lt;/code&gt; 를 우선순위 큐에 넣어서 정점까지의 거리를 기준으로 우선순위 큐를 사용한다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점에서 다른 정점까지의 거리를 저장하는 배열&lt;/code&gt; 에 저장하면 된다. (간단히 dist 라고 부르자)&lt;/p&gt;

&lt;p&gt;우선순위 큐에서 최단 경로의 정점을 하나씩 꺼내면서 해당 정점과 연결된 정점들을 우선순위 큐에 넣는 것을 반복한다.&lt;/p&gt;

&lt;p&gt;만약 v 에 아직 방문하지 않았고, 간선 (u, v) 를 검사한다고 하면 u 까지의 최단 거리에 간선 (u, v) 의 가중치를 더해서 v 까지의 거리를 구한다.&lt;/p&gt;

&lt;p&gt;만약 이 거리가 최단 거리라면 dist[v] 를 갱신하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(dist[v], v)&lt;/code&gt; 를 우선순위 큐에 다시 넣는다.&lt;/p&gt;

&lt;p&gt;여기서 주의해야할 것은 최단거리는 언제든지 갱신될 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;간선 (u, v) 를 탐색하면서 (dist[v], v) 를 우선순위 큐에 넣었는데 다른 정점을 돌면서 더 짧은 (dist[v], v) 를 우선순위 큐에 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 우선순위 큐에 (dist[v], v) 가 여러 개 생길 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- 8 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 그래프에서 시작점이 A 라고 하자.  시작점을 탐색하면서 (20, D) 가 우선순위 큐에 들어가게 될 것이다.&lt;/p&gt;

&lt;p&gt;그러나 A, B, E 를 탐색하면서 (10 + 2 + 5, D) 도 우선 순위 큐에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;이 경우에 (20, D) 는 우선순위 큐에서 pop 된다고 해도 무시되어야 한다.&lt;/p&gt;

&lt;p&gt;(20, D) 가 pop 되었다는 것은 이미 이전에 (17, D) 가 pop 되었다는 것이고 dist[D] 는 17 일 것이다.&lt;/p&gt;

&lt;p&gt;따라서 dist[D] 와의 비교를 통해서 더 짧은 경로가 이전에 이미 탐색되었는지를 확인하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;증명&quot;&gt;증명&lt;/h2&gt;

&lt;p&gt;다익스트라의 증명은 귀류법(어떤 명제가 참이라고 가정한 후, 모순을 이끌어내 그 가정이 거짓임을, 즉 처음의 명제가 거짓임을 증명하는 방법) 을 통해 가능하다.&lt;/p&gt;

&lt;p&gt;여기서는 다익스트라를 통해 최단거리를 구할 수 없다고 가정하고 모순을 이끌어내려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- ? ---- B
   |             |
   ?             ?
   |             |
   D ---- ? ---- E -- ? -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 위의 그래프를 활용해서 이야기해보자.&lt;/p&gt;

&lt;p&gt;시작점 A 부터 E 까지의 거리를 구하는 것이 목표이고, 실제로는 A - D - E 가 가장 짧다고 하자.&lt;/p&gt;

&lt;p&gt;여기서 다익스트라 알고리즘이 최단 거리를 제대로 구하지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;못한다&lt;/code&gt;고 가정하기 위해, 다익스트라 알고리즘이 A - B - E 가 가장 짧은 최단경로라는 결론을 내렸다고 가정해보자.&lt;/p&gt;

&lt;p&gt;도착점 E 에 도착한 순간, 어떤 정점은 이미 방문을 했을거고 또 어떤 정점은 우선순위 큐에 들어가 있는 상태일 수 있다.&lt;/p&gt;

&lt;p&gt;만약 D 를 방문하지 않은 상태라고 가정해보면, D 까지의 최단 거리는 dist[A] + w(A, D) 가 된다. 그런데 이미 방문한 정점 A 를 탐색하면서 D는 무조건 우선순위 큐에 (D, dist[A] + w(A, D)) 로 들어가게 되었을 것이다.&lt;/p&gt;

&lt;p&gt;A - B - E 로 진행하면서 E 또한 우선순위 큐에 들어가게 될텐데 여기서 이미 들어가있던 D 가 아닌 E 가 pop 되었다는것은 dist[E] 가 dist[D] 보다 작았기 때문이다.&lt;/p&gt;

&lt;p&gt;즉 dist[D] ≥ dist[E] 라는 소린데, 이는 D 를 거쳐서 A 에서 E 로 가는 것이 가장 짧은 경로라면 성립할 수가 없다.&lt;/p&gt;

&lt;h2 id=&quot;음수-가중치를-계산할-수-있는가&quot;&gt;음수 가중치를 계산할 수 있는가?&lt;/h2&gt;

&lt;p&gt;일반적으로 다익스트라 알고리즘은 음수 가중치가 있다면 정확한 최단 거리를 계산하지 못한다.&lt;/p&gt;

&lt;p&gt;음수 가중치가 있다는것은 이미 최단거리로 처리된 노드가 나중에 더 최단거리로 갱신될 가능성이 있다는 것이기 때문이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- -100 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다익스트라를 돌면서 E 의 최단 거리는 (10 + 2) 가 되겠지만 실제로는 10 + 2 - 100 이다.&lt;/p&gt;

&lt;p&gt;다시 말해서 이미 처리된 정점이 최단 거리라는 가정을 깨뜨릴 수 있다.&lt;/p&gt;

&lt;p&gt;만약 이미 처리된 정점이 최단 거리라는 가정을 버리고 (방문한 정점에 대한 기록을 하지 않고) 다익스트라를 작성한다면 음수 가중치를 계산할 수도 있다. 하지만, 이 경우에는 시간 복잡도가 정점의 갯수에 대해 지수함수로 증가할 수 있기 때문에 굳이 이런 식으로 다익스트라 알고리즘을 쓸 이유가 없다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;다익스트라의 시간 복잡도는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 정점마다 인접한 간선들은 모두 검사&lt;/code&gt; 하는 작업과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/code&gt; 하는 작업으로 나눌 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;각-정점마다-인접한-간선들을-모두-검사&quot;&gt;각 정점마다 인접한 간선들을 모두 검사&lt;/h3&gt;

&lt;p&gt;정점의 갯수를 E, 간선의 갯수를 V 라고 할 때,&lt;/p&gt;

&lt;p&gt;각 정점마다 인접한 간선들을 모두 검사하는 작업은 정확히 모든 간선을 1번씩 검사하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(E)&lt;/code&gt; 의 시간이 걸리게 된다.&lt;/p&gt;

&lt;h3 id=&quot;우선순위-큐에-원소를-넣고-삭제&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/h3&gt;

&lt;p&gt;우선순위 큐에 원소를 넣고 삭제하는 작업에서 최악의 경우에는 그래프의 모든 간선이 검사될 때마다 dist 배열이 갱신되면서 동시에 우선순위 큐에 정점의 번호가 추가되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/0.png&quot; alt=&quot;0&quot; /&gt;_다익스트라 최악의 경우 _&lt;/p&gt;

&lt;p&gt;위의 그래프에서 왼쪽의 핑크색 1번이 시작점이라고 하자.&lt;/p&gt;

&lt;p&gt;1번에서 2, 3, 4 까지의 dist 배열은 각각 6, 10, 15로 갱신되면서 우선순위 큐에 (2, 6), (10, 3), (15, 4) 로 들어갈 것이다.&lt;/p&gt;

&lt;p&gt;그러고 나서 2번 정점을 탐색하면서 dist[3] 은 6 + 3 으로 갱신되고, 우선순위 큐에 (9, 3) 이 추가 된다.&lt;/p&gt;

&lt;p&gt;이제 3번 정점을 탐색하면서 dist[4] 도 10 + 3 으로 갱신되고, 우선순위 큐에 (13, 4) 로 갱신 된다.&lt;/p&gt;

&lt;p&gt;이처럼 최악의 시나리오에서는 각 간선마다 한 번씩 추가가 되고, 우선순위 큐에 원소를 추가하거나 삭제하는데 O(logE)의 시간이 걸리고 이를 O(E) 개의 원소에 대해 작업을 해야하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(ElogE)&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;h3 id=&quot;일반적인-시간-복잡도&quot;&gt;일반적인 시간 복잡도&lt;/h3&gt;

&lt;p&gt;위의 두 과정을 더하게 되면 O(E + ElogE) = O(ElogE) 가 되는데, 보통 그래프에서 간선의 개수 E 는 V^2 보다 작기 때문에 O(logE) = O(logV) 라고 볼 수 있다. 따라서 O(ElogV) 라고 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘을 통해 최단 거리뿐만 아니라 최단 경로를 구하려면 정점에 도착하기 직전의 정점을 기록해서 역추적을 하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;벨만-포드&quot;&gt;벨만 포드&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘과 똑같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일&lt;/code&gt; 시작점 최단 경로 알고리즘이지만, 음수 가중치가 있는 그래프에서도 최단 경로를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;또한 음수 사이클이 있어서 최단 거리를 제대로 구하지 못하는 경우도 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;벨만포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;알고리즘-동작&quot;&gt;알고리즘 동작&lt;/h2&gt;

&lt;p&gt;시작점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;, 도착점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; , dist[k] = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점부터 k 까지의 최단 거리&lt;/code&gt; , w(u, v) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;= u와 v 사이의 간선 가중치&lt;/code&gt; 라고 하자. upper[k] 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재까지 계산된&lt;/code&gt;시작점부터 k 까지의 최단 거리이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 맨 처음에는 시작점부터 시작점사이의 거리가 0이라는 것을 제외하면, 아무것도 알고 있는 것이 없다. 따라서 upper[s] = 0 으로 초기화하고 나머지는 양의 무한대 혹은 매우 큰 수로 초기화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;완화&quot;&gt;완화&lt;/h3&gt;

&lt;p&gt;이제부터 우리는 upper 배열의 값을 점차 실제 최단 거리에 가깝도록 줄여나갈 것이다. 그러려면 최단 거리의 특성을 이용해야 하는데, 아래의 특성을 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;dist[v] ≤ dist[u] + w(u, v)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;dist[v] 는 v 까지 최단 거리인데, 만약 u를 거쳐서 v 로 오는 거리가 더 짧다면, u를 거쳐오는 거리가 최단 거리여야한다. 그렇기때문에 dist[v] 가 최단 거리라는 가정에 위배된다.&lt;/p&gt;

&lt;p&gt;이번에는 upper[u] + w(u, v) &amp;lt; upper[v] 인 상황을 생각해보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;upper[v] 를 upper[u] + w(u, v) 로 줄이려고 하는 것이 이번 과정의 목표이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;u 까지의 최단 거리는 항상 upper[u] 보다 작거나 같을 것이다.&lt;/p&gt;

&lt;p&gt;여기서 upper[u] + w(u, v) 는 u를 거쳐 v 로 가는 경로 이므로 만약 upper[u] + w(u, v) 가 upper[v] 보다 작다는 것은, u를 거쳐서 v 로 가는 것이 현재까지 계산된 v로 가는 최단 거리보다 짧다는 것이다.&lt;/p&gt;

&lt;p&gt;즉 upper[v] 를 upper[u] + w(u, v) 로 갱신할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완화&lt;/code&gt; 라고 하고 이를 계속 수행하면서 최단거리가 되도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;완화를-얼마나-해야하는가&quot;&gt;완화를 얼마나 해야하는가?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;최단거리는 결국, 어느 한 지점까지의 최단거리에서 간선을 더한 값으로 완화되어야 한다.&lt;/p&gt;

&lt;p&gt;무슨 이야기냐 하면 시작점 s 에서 연결된 정점 a 가 있다고 하자.&lt;/p&gt;

&lt;p&gt;모든 간선을 순회하면서 한 번씩 완화를 시도했다고 하자.&lt;/p&gt;

&lt;p&gt;이때 upper[a] 는 upper[s] + w(s, a) 로 완화될 수 있다. 그런데 upper[s] 는 시작점 s 부터 s 까지의 거리이므로 당연히 0이 된다.&lt;/p&gt;

&lt;p&gt;즉, upper[a] 는 w(s, a) 로 완화될 수 있다. w(s, a) 로 완화하고 나면, 시작점 s 부터 a 까지의 가는 경로중에 w(s, a) 보다 짧은 거리가 있을 수 있을까?&lt;/p&gt;

&lt;p&gt;없다. 위의 그래프에서 s 에서 b 로 가는 최단 거리가 s → b 말고 더 있을 수는 없다.&lt;/p&gt;

&lt;p&gt;여기서 만약 s → b → c → b 가 더 짧을 수도 있지 않을까 라는 생각이 들었다면 이는 음수 사이클이다. 이 경우에는 s→ b → c → b 보다 s → b → c → b → c → b 가 더 짧고 이를 무한반복하면 당연히 더 짧아진다.&lt;/p&gt;

&lt;p&gt;음수 사이클은 기본적으로 존재하는 순간 모든 그래프에서 최단 경로라는 말을 사용할 수가 없다.&lt;/p&gt;

&lt;p&gt;이는 조금 뒤에서 더 자세히 살펴보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 전체 간선에 대한 완화를 몇 번이나 수행해야 하는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그래프를 보면 전체 간선에 대한 완화를 1회 수행하면, a와 b 까지의 최단 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;2번 수행하면 c, 3번 수행하면 d 까지의 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 s → a → b → c → d 의 모양을 가진 그래프라면 어떨까?&lt;/p&gt;

&lt;p&gt;총 4회에 거쳐 a, b, c, d 까지의 최단 거리가 완화될 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서 정점의 갯수가 V 개 일때, 아무리 많이 해도 V - 1 번이면 모든 정점들까지의 거리가 최단 거리로 완화된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;음수-사이클&quot;&gt;음수 사이클&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프를 한 번 살펴보자. A → B → C 경로를 살펴보면 A → B 는 1 이 필요한데 B → C → A 는 가중치의 합이 -3 이다. A → B → C → A 는 결국 -2 의 가중치를 갖는다.&lt;/p&gt;

&lt;p&gt;어떠한 사이클이 합이 음의 가중치를 가지는 순간, 이 사이클을 무한 반복 함으로써 가중치의 합도 음의 무한대를 가지게 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서, 정점의 개수를 V 라고 할 때, 완화가 V - 1 번 이후에도 계속 이루어진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 보면 음수 사이클을 판별하는 방법은 쉽다.&lt;/p&gt;

&lt;p&gt;V - 1 번까지 완화를 진행하고 V 번째 완화를 시도해보면 된다. 만약 완화가 이루어졌다면 음수 사이클이 존재하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적-1&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;벨만 포드의 경로 추적은 다익스트라의 경로 추적과 유사하다. 다익스트라처럼 역추적을 하면 되는데,&lt;/p&gt;

&lt;p&gt;각 정점을 마지막으로 완화시킨 간선들을 토대로 역추적하면 된다. (이 간선들은 항상 최단경로의 위에 있기 때문)&lt;/p&gt;

&lt;h2 id=&quot;경로-존재-유무-판별하기&quot;&gt;경로 존재 유무 판별하기&lt;/h2&gt;

&lt;p&gt;시작점 s 에서 u 까지의 경로가 있는지 판별하는 방법은 쉽게 생각하면 upper[u] 가 Infinity 가 아니면 경로가 있다라고 착각할 수 있다.&lt;/p&gt;

&lt;p&gt;경로가 있으면 무조건 완화가 이루어질 것이라고 생각할 수 있기 때문이다. 하지만 음수 사이클이 있다면 이야기가 조금 달라진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위처럼 시작점 s 가 다른 정점들과 간선이 없다고 해도, a ↔ b 사이의 음수 사이클을 통한 완화가 이루어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 경로의 존재 유무를 판별하려면 upper[u] 가 Infinity 인지 아닌지로 판별하는 것이 아닌, 적당히 큰 값 M 에 대해서 upper[u] &amp;lt; Infinity - M 인지를 확인해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;적당히-큰-값-m&quot;&gt;적당히 큰 값 M..?&lt;/h3&gt;

&lt;p&gt;M 은 그러면 어떻게 결정할 수 있을까?&lt;/p&gt;

&lt;p&gt;우리는 위에서 완화를 최대 V - 1 번 진행한다고 했다. 그렇기 때문에 음수 사이클을 돌면서 완화된다고 했을 때, 한 번의 완화에 가장 많이 완화되는 값은 가장 작은 가중치값의 2배를 넘지 않을 것이다.&lt;/p&gt;

&lt;p&gt;위의 그래프에서는 한 번의 완화당 -1 씩 (-2 + 1) 작아진다.&lt;/p&gt;

&lt;p&gt;따라서 (가장 작은 가중치 * 2) * (V - 1) 로 M 을 설정하면 될 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도-1&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;벨만 포드 알고리즘은 모든 간선을 순회하는 작업을 정점의 갯수 - 1 번 만큼 진행한다. 음수 사이클을 판별하려면정점의 갯수만큼 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 O(E * V) 가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정점의 갯수 : V, 간선의 갯수 : E&lt;/p&gt;

&lt;h1 id=&quot;플로이드&quot;&gt;플로이드&lt;/h1&gt;

&lt;p&gt;다익스트라와 벨만 포드 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 시작점에서 다른 모든 정점까지의 거리&lt;/code&gt; 를 구하는 알고리즘이었다. 플로이드는 한 시작점이 아닌, 모든 정점에서 모든 정점까지의 거리를 구할 수 있는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;사실 플로이드를 굳이 안쓰고 모든 정점에서 한 번씩 다익스트라 알고리즘을 수행해도 구할 수 있다. 음수 가중치가 있다면 모든 정점에서 벨만 포드 알고리즘을 쓸 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 이런 방법보다는 더 빠르게 수행할 수 있는 알고리즘이 플로이드 와샬 알고리즘이다.&lt;/p&gt;

&lt;p&gt;플로이드 알고리즘은 생각보다 간단하다.&lt;/p&gt;

&lt;p&gt;정점 u 에서 v 까지의 거리를 dist[u][v] 라고 정했을 때 3중 for 문을 돌면서 u → ? → v 로 갔을 때, 거리가 갱신되는지 살펴보는 것이다.&lt;/p&gt;

&lt;p&gt;그런데 플로이드 알고리즘의 프로토타입을 글로 읽고 이해하려니 꽤나 많은 생각을 거쳐야 했다.&lt;/p&gt;

&lt;h2 id=&quot;프로토타입&quot;&gt;프로토타입&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 표현식은 a 에서 출발하여 c, d 를 거쳐 b 로 가는 경로이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 그래프에서 정점들의 집합을 S 라고 하고, 임의의 점을 x 라고 하자.&lt;/p&gt;

&lt;p&gt;a 에서 f 로 가는 경로에서 x 를 경유하는 것과, 경유하지 않은 것을 나누어 나타내면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기호가 너무 많아서 햇갈릴 수 있는데 a → f 의 경로는 x 를 경유해서 가는 것과 경유해서 가지 않는 것의 최소값이라는 의미일 뿐이다.&lt;/p&gt;

&lt;p&gt;여기서 이 점화식을 살짝 수정해서 더 보기 좋게 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 가지의 식을 활용해서 위의 식을 바꾸면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 된다.&lt;/p&gt;

&lt;p&gt;이제서야 우리가 자주 보던 점화식같이 생겼다.&lt;/p&gt;

&lt;p&gt;여기서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 식의 차이점에 대해서 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 식은 k 를 거치지 않고 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;반대로 위의 식은 k 까지 거쳐서 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;그런데 k 까지 가는데 k 를 거치든 안거치든 그게 다를 수 있나?&lt;/p&gt;

&lt;p&gt;도착점이 k 이므로 k를 거치는것과 안거치는것은 당연히 같다.&lt;/p&gt;

&lt;p&gt;따라서 위의 식이 같다라고 생각하게 되면 식은 더욱 간단해진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 우리가 알던 플로이드 알고리즘인, 경유점 하나를 거쳐서 가는것과 안거쳐서 가는 것 중에서 더 짧은 것을 선택하는 식이 된다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Algorithm" /><summary type="html">정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.</summary></entry></feed>