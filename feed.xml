<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://hoeeeeeh.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hoeeeeeh.github.io/" rel="alternate" type="text/html" /><updated>2025-12-17T10:52:50+00:00</updated><id>https://hoeeeeeh.github.io/feed.xml</id><title type="html">hoeeeeeh</title><subtitle>HOEH 개발 블로그</subtitle><entry><title type="html">JS Closure</title><link href="https://hoeeeeeh.github.io/JS_Closure" rel="alternate" type="text/html" title="JS Closure" /><published>2025-12-14T05:58:00+00:00</published><updated>2025-12-14T05:58:00+00:00</updated><id>https://hoeeeeeh.github.io/JS_Closure</id><content type="html" xml:base="https://hoeeeeeh.github.io/JS_Closure">&lt;p&gt;&lt;a href=&quot;https://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html&quot;&gt;https://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;closure&quot;&gt;Closure&lt;/h1&gt;

&lt;h2 id=&quot;lexical-environment&quot;&gt;Lexical Environment&lt;/h2&gt;

&lt;p&gt;자바스크립트를 사용한다면, 모든 함수가 변수를 값으로 해석하기 위해 &lt;strong&gt;렉시컬 환경(lexical environment)&lt;/strong&gt; 을 가지고 있다는 사실을 알고 있을 것이다. 말은 추상적으로 들리지만 실제로는 매우 단순하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
function makeF() { 
	var x = 11; 
	var y = 22; 
	return function (what) { 
		switch (what) { 
			case &quot;x&quot;: 
				return x; 
				
			case &quot;y&quot;: 
				return y; 
		} 
	} 
} 

var f = makeF(); 
f(&quot;x&quot;);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt;를 보관할 저장소가 필요하다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makeF&lt;/code&gt;의 실행 컨텍스트는 이미 사라졌기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-12-14-JS_Closure.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;73900.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;V8은 정확히 이렇게 수행한다 :&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Context&lt;/code&gt;라고 불리는 객체를 하나 생성하고, 이것을 클로저에 붙인다(이 클로저는 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSFunction&lt;/code&gt; 클래스의 인스턴스로 표현된다).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;너무 추상적인 것 같아서 이해를 바탕으로 다시 써보면, Context 라는 객체를 하나 생성하고 JSFunction 이 Context 를 참조할 수 있도록 연결한다. 라고 이해할 수 있을 것 같다.&lt;/p&gt;

  &lt;p&gt;다시 말해서, 함수(JSFunction) 가 Context 를 들고 있는 상태를 클로저(JSFunction + Context) 라고 부른다.&lt;br /&gt;
JSFunction 내부에 Context 를 가리키는 포인터가 존재하는 상태가 클로저이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이후에 이 캡쳐된 변수들(여기서는 x, y) 를 앞으로 컨텍스트 변수라고 지칭하겠다.&lt;/p&gt;

&lt;p&gt;여기서 이제 중요한 점이 몇 가지 있다.&lt;/p&gt;

&lt;h2 id=&quot;context-생성-시점&quot;&gt;Context 생성 시점&lt;/h2&gt;

&lt;p&gt;첫째로, V8은 클로저가 만들어질 때가 아니라 &lt;strong&gt;스코프에 진입할 때&lt;/strong&gt; Context를 생성한다. 이 사실은 핫 루프 안에서 클로저가 참조하는 변수를 다룰 때 매우 중요하다. 최적화 컴파일러는 이런 변수를 레지스터에 둘 수 없고, 매번 메모리 load/store가 발생한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;‘핫 루프’는 직관적으로 설명하면 ‘짧은 시간안에 매우 많이 실행되는 루프’ 정도로 생각할 수 있다. 여기서 왜 핫 루프가 중요하냐면, 핫 루프처럼 매우 자주 사용되는 경우, 인터프리터인 Ignition 이 ‘이 루프는 굉장히 많이 사용되는구나. 이걸 매번 실행하기보다는 최적화해야겠다’ 라고 생각하고 TurboFan 에게 최적화 컴파일을 하도록 한다.&lt;br /&gt;
이렇게 최적화를 하게 되면 변수를 참조할 때, 매번 메모리에서 load 하지 않고 레지스터에서 빠르게 가져올 수 있다. 하지만 Context 는 클로저가 만들어질때가 아니라 스코프에 진입할 때 만들어진다.&lt;/p&gt;

  &lt;p&gt;V8은 스코프에 진입할 때 Context를 만들고, 클로저가 참조하는 변수는 Context 슬롯에 들어간다. 그러면 핫 루프 안에서 그 변수를 사용할 때, TurboFan은 그 변수를 단순한 로컬 변수처럼 레지스터에 올려둘 수가 없다. 매 반복마다 “Context → 슬롯 → 값”을 따라가서 메모리에서 load 해야 하고, 값이 바뀌면 다시 store 해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그래서, 테스트를 해보려고 했는데 간단한 테스트에서는 오히려 Closure 를 사용할때가 성능이 더 좋았다..!&lt;/p&gt;

&lt;p&gt;이유는 아래에서 더 자세히 설명되어있다.&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;간단한 테스트&lt;/summary&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
let cnt = 0;

function count(c) {
	return c + 1;
}

while(cnt &amp;lt; 1e5) {
	cnt = count(cnt);
	// do something
}

// --------------------

function c() {
	let cnt = 0;
	function count() {
		cnt += 1;
		
		return cnt;
	}
	
	return count;
}

let f = c();

while(f() &amp;lt; 1e5) {
	// do something
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;정말 간단하게 위의 두 코드에 대한 실행시간 차이를 재봤더니 차이가 없거나 오히려 클로저가 더 빠른 경우가 있다. V8 엔진의 최적화가 잘 되어서 이정도로는 차이를 크게 벌릴 수 없나보다.&lt;/p&gt;

&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;복잡한 테스트&lt;/summary&gt;

  &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
&apos;use strict&apos;;
const { performance } = require(&apos;perf_hooks&apos;);

const WARMUP = 5_000_000;
const ITER = 50_000_000;

let sink = 0; // 루프에서 생성되는 값이 사라지지 않게끔 잡아두는 변수. 

function bench(name, fn) {
  fn(WARMUP); // warmup
  let best = Infinity;
  for (let r = 0; r &amp;lt; 7; r++) {
    const t0 = performance.now();
    fn(ITER);
    const t1 = performance.now();
    best = Math.min(best, t1 - t0);
  }
  console.log(`${name}: ${best.toFixed(2)} ms`);
}

/**
 * 1) local: 루프 안 변수들이 &quot;로컬&quot; (V8이 레지스터로 잡기 쉬움)
 */
function localRunner(n) {
  let a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8;

  for (let i = 0; i &amp;lt; n; i++) {
    a = (a + b) | 0;
    b = (b + c) | 0;
    c = (c + d) | 0;
    d = (d + e) | 0;
    e = (e + f) | 0;
    f = (f + g) | 0;
    g = (g + h) | 0;
    h = (h + a) | 0;

    sink = (sink + (a ^ h)) | 0;
  }
}

/**
 * 2) closure: a~h가 &quot;외부 스코프 변수&quot;라서 Context 슬롯에 들어갈 가능성이 높음
 */
function makeClosureRunner() {
  let a = 1, b = 2, c = 3, d = 4, e = 5, f = 6, g = 7, h = 8;

  return function closureRunner(n) {
    for (let i = 0; i &amp;lt; n; i++) {
      a = (a + b) | 0;
      b = (b + c) | 0;
      c = (c + d) | 0;
      d = (d + e) | 0;
      e = (e + f) | 0;
      f = (f + g) | 0;
      g = (g + h) | 0;
      h = (h + a) | 0;

      sink = (sink + (a ^ h)) | 0;
    }
  };
}

const closureRunner = makeClosureRunner();

bench(&apos;local&apos;, localRunner);
bench(&apos;closure(context)&apos;, closureRunner);


// local: 573.22 ms
// closure(context): 692.98 ms

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;루프를 돌고 sink 에 값을 저장해둠으로써 ‘이 루프는 쓸모없는 루프가 아니라 sink 를 위한 루프구나’ 라고 TurboFan 이 생각하도록 만든다.&lt;/p&gt;

&lt;/details&gt;

&lt;h2 id=&quot;스코프&quot;&gt;스코프&lt;/h2&gt;

&lt;p&gt;둘째로, Context는 스코프에 진입하는 순간 &lt;strong&gt;즉시 생성&lt;/strong&gt;되고, 그 스코프에서 만들어진 모든 클로저가 &lt;strong&gt;공유&lt;/strong&gt;한다. 그리고 이 스코프가 또 다른 클로저 안에 있다면, Context는 부모 Context를 가리키는 포인터를 가진다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 구조는 메모리 누수를 유발할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
function outer() {
  var x = HUGE;  // huge object
  function inner() {
    var y = GIANT;  // giant object :-)

    use(x);  // usage of x cause it to be allocated to the context

    function innerF() {
      use(y);  // usage of y causes it to be allocated to the context
    }

    function innerG() {
      /* use nothing */
    }

    return innerG;
  }

  return inner();
}

var o = outer();  // o will retain HUGE and GIANT.

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;outer → inner → innerF, innerG&lt;/p&gt;

&lt;p&gt;이 코드에서 innerG 가 실제로 사용하는건 없다. HUGE 도 GIANT 도 innerG 가 사용하지 않는다. 하지만 o 는 HUGE 와 GIANT 를 유지시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;innerG 와 innerF 는 Context 를 공유하기 때문에 GIANT 를 유지한다.&lt;/li&gt;
  &lt;li&gt;innerG 의 부모, inner 의 Context 를 통해 HUGE 가 유지된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-12-14-JS_Closure.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;85101.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;context-가-생기는-추가-규칙들&quot;&gt;Context 가 생기는 추가 규칙들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt;을 직접 호출하거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 문을 사용하는 경우, 이를 포함하는 모든 스코프의 모든 변수는 Context에 할당된다.&lt;/li&gt;
  &lt;li&gt;non-strict 함수에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arguments&lt;/code&gt; 객체를 참조하면, 파라미터들이 Context에 할당된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
function f(a) {  // a is context allocated
  var x = 10;  // x is context allocated
  function g(b) {  // b is context allocated
    var y = 10;  // y is context allocated
    function h(c) {  // c is context allocated
      with (obj) {
        z = c;
      }
    }
    h(b);
  }
  g(a);
}

function k(x, y) {  // x and y are context allocated
  return arguments[0] + arguments[1];
}

function sk(x, y) {  // x and y are not context allocated
  &quot;use strict&quot;;
  return arguments[0] * arguments[1];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;context-vs-instance-field&quot;&gt;‘Context’ vs ‘Instance Field’&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// Classic Object
function ClassicObject() {
  this.x = 10;
}
ClassicObject.prototype.getX = function () {
  return this.x; // (1)
};


// Closure Object
function ClosureObject() {
  var x = 10;
  return {
    getX: function () {
      return x; // (2)
    }
  };
}



var classic_object = new ClassicObject();
var closure_object = new ClosureObject();

// 이제 컴파일과 최적화를 유도하기 위해 루프를 돌린다.
for (var i = 0; i &amp;lt; 1e5; i++) classic_object.getX();
for (var i = 0; i &amp;lt; 1e5; i++) closure_object.getX();

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ClassicObject 는 우리가 Class 를 쓰는 방식과 동일하다. getX 는 this.x 를 반환하기만 하므로 굉장히 예측 가능한 형태이다. 따라서 &lt;a href=&quot;https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C&quot;&gt;Hidden Class 와 Inline Cache&lt;/a&gt; 를 활용한 최적화가 이루어질 것이다.&lt;/p&gt;

&lt;p&gt;ClosureObject 는 x 를 반환하는 방식에 Closure 를 이용했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;아래에서 등장할 eax, edx, ecx, esi 등은 전부 CPU 레지스터 이름이다.&lt;br /&gt;
다만, 그 이름이 특별한 의미를 가지는 건 아니고 어떻게 쓰이는지가 의미가 있다.&lt;br /&gt;
예를 들어, ebp는 “현재 함수 스택 프레임의 기준점(프레임 포인터)” 이고 “receiver는 edx”, “property key는 ecx”, “current context는 esi”, “return/result는 eax” 로 쓰이는구나! 정도로만 받아들이면 될 것 같다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;classic-object&quot;&gt;Classic Object&lt;/h3&gt;

&lt;p&gt;예상대로, 인스턴스 필드 로드 (1)은 비최적화 컴파일러에 의해 &lt;strong&gt;인라인 캐시 호출&lt;/strong&gt;로 컴파일된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;비최적화 컴파일러 → 아직 실행 초기다보니, 최적화되지 못했다는 의미!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
mov eax, [ebp+0x8]     ;; 스택에서 this를 로드
mov edx, eax           ;; receiver를 edx에 둠
mov ecx, &quot;x&quot;           ;; 프로퍼티 이름을 ecx에 둠
call LoadIC_Initialize ;; IC 스텁 호출

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인스턴스 필드 로드를 많이 하게 되면, 다음과 같이 Inline Cache 호출은 아래의 Stub 처럼 패치(최적화)된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Stub : 자주 쓰는 일을 빠르게 처리하려고, 미리 만들어 놓는 아주 작은 머신코드 조각&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
test_b dl, 0x1              ;; receiver가 smi가 아닌 객체인지 확인
jz miss                     ;; 아니면 miss로 이동
cmp [edx-1], 0x2bb0ece1     ;; 객체의 hidden class 확인
jnz miss                    ;; 아니면 miss로 이동
mov eax, [edx+0xb]          ;; IC 히트, 고정 오프셋으로 필드 로드
ret
miss:
jmp LoadIC_Miss             ;; miss 처리 위해 런타임으로 점프

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;최적화된 코드를 보면, 인스턴스 필드를 load 하는 것은 꽤나 복잡해진다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assembly
;;; @11: gap.
mov eax,[ebp+0x8] ;; this 가져오기
;;; @12: check-non-smi.
test eax,0x1 ;; smi(숫자 같은 원시값) 인지 아닌지 체크
jz 0x3080a00a        ;; deoptimization bailout 1
;;; @14: check-maps.
cmp [eax-1],0x2bb0ece1
jnz 0x3080a014       ;; deoptimization bailout 2
;;; @16: load-named-field.
mov eax,[eax+0xb]
;;; @18: return.
mov esp,ebp
pop ebp
ret 0x4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;;; @N:&lt;/code&gt; 주석은 Crankshaft의 저수준 IR(lithium)에 있는 명령을 가리킨다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;어떤 수행을 하는지 간단하게 다이어그램으로 표현하면&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
[Start]
  |
  v
this 로드 (eax = this)
  |
  v
check-non-smi: eax가 Smi(원시값)인지 가드 (객체가 아니라 원시값이면 프로퍼티 읽으면 안됨!)
  |Yes ----------------------&amp;gt; [DEOPT] (비최적화 코드로 되돌아감)
  |
  No
  |
  v
check-maps: eax의 hidden class(map)가 예상값인지 가드
(예상했던 hidden class 가 아니라면 고정 오프셋 쓰면 안됨!)
  |No -----------------------&amp;gt; [DEOPT]
  |
  Yes
  |
  v
load-named-field: eax = *(eax + offset_of_x)
  |
  v
return eax

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;가드 : check-non-smi, check-maps (최적화된 경로를 써도 되는지 체크하는 것!)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Crankshaft는 특정 객체 타입에 맞게 로드 지점을 특수화하고, 가드가 실패할 경우 디옵트마이즈하여 비최적화 코드로 전환하도록 한다. 본질적으로 Crankshaft는 IC 스텁을 인라인하고, 이를 개별 연산(비-smi 검사, 히든 클래스 검사, 필드 로드)으로 분해한 뒤, 느린 경로(miss)를 디옵트마이즈로 우회시킨다고 볼 수 있다.&lt;/p&gt;

&lt;p&gt;프로퍼티가 여러 개 생길 경우, 가드와 함수 실행부를 분리할 수 있다.
예를 들어, 아래와 같이 프로퍼티가 하나 더 생겼다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
functionClassicObject() {
	this.x =10;
	this.y =20;
}

ClassicObject.prototype.getSum = function () {
	returnthis.x +this.y;
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;비최적화된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getSum&lt;/code&gt;은 IC 세 개(각 프로퍼티 로드용 두 개와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; 연산용 하나)를 가지지만, 최적화된 버전은 훨씬 더 간결하다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assembly
;;; @11: gap.
mov eax,[ebp+0x8]
;;; @12: check-non-smi.
test eax,0x1
jz 0x5950a00a
;;; @14: check-maps.
cmp [eax-1],0x24f0ed01
jnz 0x5950a014
;;; @16: load-named-field.
mov ecx,[eax+0xb]
	;;; @18: load-named-field.
mov edx,[eax+0xf]

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check-non-smi&lt;/code&gt;, 두 개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;check-maps&lt;/code&gt;를 남기는 대신, 컴파일러는 공통 부분을 제거해 중복 가드를 없앴다.&lt;/p&gt;

&lt;p&gt;x 를 로드할 수 있었다면, y 에 굳이 가드를 한 번 더 할 이유가 없다는 의미이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
[Start]
  |
  v
this 로드 (eax = this)
  |
  v
check-non-smi (this가 객체인가?)
  |Fail ---------------------&amp;gt; [DEOPT]
  |
  Pass
  |
  v
check-maps (this의 map이 예상한 구조인가?)
  |Fail ---------------------&amp;gt; [DEOPT]
  |
  Pass
  |
  v
x 로드 (ecx = *(eax + offset_of_x))
  |
  v
y 로드 (edx = *(eax + offset_of_y))
  |
  v
(+ 연산 수행: ecx + edx)
  |
  v
return

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;closure-object&quot;&gt;Closure Object&lt;/h3&gt;

&lt;p&gt;Closure 은 비최적화 컴파일러조차도 Classic Object 에 비해 훨씬 간단한 코드를 생성한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
mov eax, esi            ;; 컨텍스트를 eax로 이동
mov eax, [eax + 0x17]   ;; 컨텍스트의 고정 오프셋에서 변수 로드

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 눈여겨볼 점은,&lt;/p&gt;

&lt;p&gt;첫째, V8은 현재 컨텍스트를 가리키기 위해 &lt;strong&gt;전용 레지스터&lt;/strong&gt; &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esi&lt;/code&gt;&lt;/strong&gt;를 사용한다. 프레임이나 클로저 객체에서 다시 로드할 필요를 피하기 위해서다.&lt;/p&gt;

&lt;p&gt;둘째, 컴파일러는 컴파일 시점에 변수를 &lt;strong&gt;고정 인덱스&lt;/strong&gt;로 해석할 수 있었기 때문에, 지연 바인딩도 없고, 룩업 오버헤드도 없으며, 인라인 캐시를 개입시킬 필요도 없다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;왜 Closure Object 는 고정 인덱스로 해석할 수 있고, Classic Object 는 고정 인덱스로 해석할 수 없는가?&lt;br /&gt;
→ Closure Object 는 렉시컬 스코프 안의 지역 변수에 대한 캡처가 가능하다. 반면, Classic Object 는 런타임에 구조가 계속 바뀔 수 있다. (Object 에 프로퍼티가 변할 수 있기 때문)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Closure Object 의 컨텍스트 슬롯을 읽는 최적화 코드는 사실 비최적화와 크게 차이가 없다. 그냥 고정 오프셋 읽는 코드가 끝이기 때문.&lt;/p&gt;

&lt;h2 id=&quot;그래서-왜-클로저-기반이-고전적인classic-object-oop-보다-성능이-느려지는가&quot;&gt;그래서 왜? 클로저 기반이 고전적인(Classic Object) OOP 보다 성능이 느려지는가&lt;/h2&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="CS" /><category term="Programming" /><category term="JavaScript" /><summary type="html">https://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html</summary></entry><entry><title type="html">원시 타입과 객체</title><link href="https://hoeeeeeh.github.io/%EC%9B%90%EC%8B%9C_%ED%83%80%EC%9E%85%EA%B3%BC_%EA%B0%9D%EC%B2%B4" rel="alternate" type="text/html" title="원시 타입과 객체" /><published>2025-12-13T06:00:00+00:00</published><updated>2025-12-13T06:00:00+00:00</updated><id>https://hoeeeeeh.github.io/%EC%9B%90%EC%8B%9C_%ED%83%80%EC%9E%85%EA%B3%BC_%EA%B0%9D%EC%B2%B4</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EC%9B%90%EC%8B%9C_%ED%83%80%EC%9E%85%EA%B3%BC_%EA%B0%9D%EC%B2%B4">&lt;h1 id=&quot;원시-타입-primitive-type-과-객체object-의-비교&quot;&gt;원시 타입 (Primitive Type) 과 객체(Object) 의 비교&lt;/h1&gt;

&lt;p&gt;자바스크립트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체&lt;/code&gt; 기반의 프로그래밍 언어이고, 사실상 자바스크립트를 구성하는 대부분이 객체이다.&lt;/p&gt;

&lt;p&gt;함수도 객체이고 배열도 사실 객체이다. typeof arr 을 했을 때도 Object 라는 결과를 볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
console.log(typeof []); // object

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;원시 타입은 ‘단 하나의 값’ 만 나타내지만 ‘객체 타입’ 은 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;원시 타입에는 number, string, boolean, null, undefined, symbol, bigint가 있고, 이 타입들은 모두 불변이다. 즉, 값을 직접 수정할 수 없다. 예를 들어, 문자열에서 일부 문자를 바꾸는 연산을 해도 기존 문자열이 바뀌는 게 아니라 새로운 문자열이 만들어진다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
let s = &apos;abc&apos;;
s += &apos;z&apos;; 
// 여기서 단순히 s 의 마지막에 z 가 붙어서 abcz 가 되는 것이 아니라, 
// abcz 라는 문자열이 새로 만들어지고 그것이 s 에 할당된다.

let sCopy = s;
// s 의 메모리 주소가 sCopy 에 할당되는 것이 아니라, s 의 값이 복사되어 sCopy 에 할당된다.

sCopy = &apos;xyz&apos;;

console.log(s, sCopy); // &apos;abcz&apos;, &apos;xyz&apos;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;객체 타입은 object, array, function 처럼 참조 타입이다. 변수에는 객체 그 자체가 아니라 객체가 있는 메모리 주소가 들어간다. 그래서 객체를 다른 변수에 대입하면 값이 복사되는 게 아니라 같은 객체를 가리키는 참조가 복사된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
let sArr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
sArr.push(&apos;z&apos;);
console.log(sArr.join(&apos;&apos;));
// sArr 의 맨 뒤 요소로 z 가 들어오고, join 연산 결과로 abcz 가 된다. 

let sArrCopy = sArr;
// sArr 의 참조가 sArrCopy 에 할당된다.

sArrCopy[0] = &apos;x&apos;;

console.log(sArr, sArrCopy); // 둘 다 [&apos;x&apos;, &apos;b&apos;, &apos;c&apos;, &apos;z&apos;];

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;비교 연산에서도 차이가 난다. 원시 타입은 === 비교 시 값 자체를 비교하지만, 객체는 참조 주소를 비교한다. 내용이 똑같은 객체 리터럴 두 개를 만들어도 서로 다른 객체이기 때문에 === 결과는 false가 된다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
const s1 = &apos;abc&apos;;
const s2 = &apos;abc&apos;;

console.log(s1 === s2); // true

const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];

console.log(arr1 === arr2); // false

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="CS" /><category term="Programming" /><category term="JavaScript" /><summary type="html">원시 타입 (Primitive Type) 과 객체(Object) 의 비교</summary></entry><entry><title type="html">내 큐는 왜 느릴까</title><link href="https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C" rel="alternate" type="text/html" title="내 큐는 왜 느릴까" /><published>2025-09-05T07:50:00+00:00</published><updated>2025-09-05T07:50:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C">&lt;p&gt;자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다.&lt;/p&gt;

&lt;p&gt;일반적인 배열의 shift 메서드는 배열의 맨 앞 원소를 반환하지만 결국 마지막 원소까지 전부 shift 시켜야하기 때문에 O(1) 가 아닌 O(N) 이 소모된다.&lt;/p&gt;

&lt;p&gt;그래서 아주 간단하게 큐를 작성해보면, 아래와 같이 생각해볼 수 있을 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;객체로-간단하게-큐-구현해보기&quot;&gt;객체로 간단하게 큐 구현해보기&lt;/h1&gt;

&lt;p&gt;정확히는 앞이나 뒤에서 모두 원소를 O(1) 로 꺼낼 수 있는 deque 인데,&lt;/p&gt;

&lt;p&gt;간단하게 items 라는 객체에서 left, right 인덱스를 통해 바로 접근할 수 있도록 하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
    left = 0;
    right = 0;
    items = {};
    
    dequeue() {
        if(this.isEmpty()) {
            return null;
        }
        
        const result = this.items[this.left];
        delete this.items[this.left];
        this.left += 1;
        
        this.clean();
        
        return result;
    }
    
    isEmpty() {
        return this.left === this.right;
    }
    
    peek() {
        if(this.isEmpty()) {
            return null;
        }
        return this.items[this.left];
    }
    
    last() {
        if(this.isEmpty()) {
            return null;
        }
        return this.items[this.right - 1];
    }
    
    enqueue(value) {
        this.items[this.right] = value;
        this.right += 1;
    }
    
    
    pop() {
        if(this.isEmpty()) {
            return null;
        }
        
        this.right -= 1;
        
        const result = this.items[this.right];
        delete this.items[this.right];
        
        this.clean();
        
        return result;
    }
    
    clean() {
        if(this.left === this.right) {
            this.left = 0;
            this.right = 0;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;dequeue-delete&quot;&gt;Dequeue, delete&lt;/h2&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dequeue&lt;/code&gt;  메서드를 살펴보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete this.items[this.left]&lt;/code&gt; 를 통해서 items 객체에서 제거하고 있다.&lt;/p&gt;

&lt;p&gt;delete 하는 이유는 당연하게도 메모리를 아끼기 위해서였다. 그리고 delete 하는데 O(1) 밖에 걸리지 않기 때문에 그렇게 큰 문제가 생기지 않을 것이라고 생각했었는데, 뒤에서 이야기하겠지만 굉장히 큰 실수였다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
dequeue() {
    if(this.isEmpty()) {
        return null;
    }
        
    const result = this.items[this.left];
    delete this.items[this.left];
    this.left += 1;
        
    this.clean();
        
    return result;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 점이 왜 잘못되었는지 알려면 우리가 쓰고 있는 node.js 의 엔진에 대해서 알아봐야한다.&lt;/p&gt;

&lt;h1 id=&quot;v8&quot;&gt;V8&lt;/h1&gt;

&lt;h2 id=&quot;turbofan-ignition&quot;&gt;TurboFan, Ignition&lt;/h2&gt;

&lt;p&gt;node.js 의 내부 엔진인 V8 은 우리가 작성한 코드를 내부적으로 최적화하는, 2단계의 실행 파이프라인을 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ignition (바이트코드 인터프리터) : 코드를 빠르게 실행하면서 객체가 어떤 모양과 타입을 가지는지(타입 피드백) 등을 수집&lt;/li&gt;
  &lt;li&gt;TurboFan (최적화 JIT 컴파일러) : Hot(자주 실행되는) 한 함수들을 최적화한 기계어 코드를 생성. 여기서 TurboFan 은 Ignition 에서 얻은 피드백 등을 사용하여 코드를 최적화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-09-05-내_큐는_왜_느릴까.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;89549.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;피드백&lt;/code&gt; 을 통해 코드를 최적화하기 때문에 V8 은 자바스크립트 코드를 훨씬 더 빠르게 실행할 수 있다. 반면, 함수가 너무 복잡하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;폴리모픽&lt;/code&gt;(Polymorphic, 다양한 형태를 가진, 즉 예측 하기 힘든) 한 경우에는 코드를 최적화하기 어렵다. 따라서 아예 최적화된 코드가 없거나 최적화된 코드에서 실행이 불가능해서 최적화되지 않은 코드로 실행되는(’탈출’ 혹은 deoptimize 라고 부르는듯 하다) 경우가 많다.&lt;/p&gt;

&lt;p&gt;폴리모픽의 예시를 보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    1 function getX(obj) {
    2   return obj.x; // 이 부분이 폴리모픽 상태가 됨
    3 }
    4 
    5 const obj1 = { x: 1, y: 2 }; // Shape A
    6 const obj2 = { x: 3, z: 4 }; // Shape B (y 대신 z)
    7 
    8 // getX는 Shape A와 Shape B, 두 가지 형태의 객체를 받음
    9 getX(obj1);
   10 getX(obj2);

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;obj1 은 x, y 프로퍼티를 가지고 있고, obj2 는 x, z 프로퍼티를 가지고 있다.&lt;/p&gt;

&lt;p&gt;따라서 Shape A (x, y 프로퍼티), Shape B (x, z 프로퍼티) 2가지가 존재하고, getX 는 2가지의 형태를 받을 수 있다.&lt;/p&gt;

&lt;p&gt;obj.x 부분은 Shape A 가 들어올지, Shape B 가 들어올지에 따라 각각 최적화된 코드로 넘어갈 수 있다.&lt;/p&gt;

&lt;p&gt;위의 경우에는 어느정도 최적화를 하는데 큰 문제가 없지만 조금 더 복잡한 상황이면 (보통 4개 이상?) 최적화 하기가 힘들어진다.&lt;/p&gt;

&lt;p&gt;이런 경우를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메가모픽&lt;/code&gt;이라고 부르는 듯 하다.&lt;/p&gt;

&lt;p&gt;반대로 하나의 Shape 으로 고정되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모노모픽&lt;/code&gt; 이라고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    1 function getX(obj) {
    2   return obj.x; // 이 부분이 메가모픽 상태가 됨
    3 }
    4 
    5 // 매번 다른 Shape의 객체를 생성하여 함수 호출
    6 for (let i = 0; i &amp;lt; 10; i++) {
    7   let obj = { x: i };
    8   if (i % 2 === 0) obj.a = 1;
    9   if (i % 3 === 0) obj.b = 1;
   10   if (i % 4 === 0) obj.c = 1;
   11   // ... 이런 식으로 계속 다른 Shape가 만들어짐
   12   getX(obj);
   13 }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 모노모픽, 혹은 적당한 수준의 폴리모픽은 V8 의 인라인 캐시를 통해 최적화된 코드를 만들고 빠른 경로를 미리 만들어둔다.&lt;/p&gt;

&lt;p&gt;최적화된 코드에서는 런타임에 객체의 히든 클래스를 검사하는 가드가 포함되고, 일치하지 않는다면 디옵트(탈출, 인터프리터로 실행) 된다.&lt;/p&gt;

&lt;h2 id=&quot;hidden-class-shape&quot;&gt;Hidden Class (Shape)&lt;/h2&gt;

&lt;p&gt;자바스크립트는 동적 언어이지만, V8 은 내부적으로 객체에 구조를 부여하기 위해 히든 클래스라는 것을 사용한다. 히든 클래스는 어떤 프로퍼티가 있고, 메모리 어디에 저장되는지 등을 나타내는 내부 디스크립터다.&lt;/p&gt;

&lt;p&gt;코드로 간단하게 살펴보면,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
let o = {};
o.a = &quot;foo&quot;;
o.b = &quot;bar&quot;;
o.c = &quot;baz&quot;;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-09-05-내_큐는_왜_느릴까.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;31421.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 o.a → o.b → o.c 순으로 프로퍼티를 추가했으면 위의 이미지처럼 a → b → c 순으로 디스크립터가 추가되면서 히든 클래스가 만들어진다.&lt;/p&gt;

&lt;h3 id=&quot;히든-클래스는-offset-을-저장한다&quot;&gt;히든 클래스는 Offset 을 저장한다.&lt;/h3&gt;

&lt;p&gt;여기서 주의할 점은 “순서” 이다.&lt;/p&gt;

&lt;p&gt;a → b → c 순으로 프로퍼티를 추가한 객체와, c → b → a 순서로 프로퍼티를 추가한 객체는 서로 다른 히든 클래스를 갖는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
let o = {};
o.a = &quot;foo&quot;;
o.b = &quot;bar&quot;;
o.c = &quot;baz&quot;;

let x = {};
x.c = &quot;baz&quot;;
x.b = &quot;bar&quot;;
x.a = &quot;foo&quot;;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;o 와 x 는 결국 a,b,c 의 프로퍼티를 갖겠지만 서로 다른 히든 클래스를 갖는다. 프로퍼티가 추가될 때마다 새로운 히든 클래스를 만들게 되는데, 그 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로퍼티가 메모리 어디에 저장되어 있는지를 저장하는 오프셋&lt;/code&gt; 을 저장하기 때문이다.&lt;/p&gt;

&lt;p&gt;프로퍼티를 추가할 때를 기준으로 offset 이 정해지는데, a → b → c 순으로 정하는 offset 은 당연히 c → b → a 순으로 정하는 offset 과 다르다.&lt;/p&gt;

&lt;p&gt;이렇게 offset 을 가지고 특정 프로퍼티에 빠르게 접근이 가능하기 때문에 히든 클래스가 중요한 것이고, 히든 클래스에 순서가 영향을 미치는 이유이다.&lt;/p&gt;

&lt;p&gt;히든클래스를 통해 V8 은 매번 딕셔너리에서 프로퍼티를 찾는 대신, 고정 오프셋을 사용해서 프로퍼티에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;o.a, o.b, o.c 처럼 a b c 의 해시값을 딕셔너리에서 검색할 필요가 없이 오프셋을 통해 바로 접근할 수 있게 되는 것이다. (C++ 의 구조체처럼)&lt;/p&gt;

&lt;p&gt;따라서 프로퍼티의 생성 순서와 일관성이 중요하다. 일관된 shape 는 성능에 영향을 줄 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;딕셔너리-모드&quot;&gt;딕셔너리 모드&lt;/h3&gt;

&lt;p&gt;히든클래스로 프로퍼티의 오프셋을 저장하고 프로퍼티가 추가될 때마다 새로운 히든 클래스로 “전이” 되다가 너무 비효율적이게 되면 해당 객체를 딕셔너리 모드로 전환한다고 한다. 이렇게 딕셔너리 모드로 전환되면 해시 테이블(딕셔너리)에 프로퍼티를 저장하게 되기 때문에 프로퍼티의 추가, 삭제는 유연해진다. 대신 당연히 모든 프로퍼티로의 접근이 느려진다. (인라인 캐시와 고정 오프셋을 사용하지 못하기 때문)&lt;/p&gt;

&lt;p&gt;여기서 딕셔너리 모드로 전환되는 일반적인 방법이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 이다. delete 를 사용하는 경우 V8 은 이 객체가 고정된 구조(모노모픽처럼) 라고 생각하기 보단 동적으로 사용된다고 판단하여 딕셔너리 모드로 들어가게 된다. 결국 여기서 고려해볼수 있는 점은, 속도와 메모리효율의 트레이드오프이다. delete 를 사용하는 대신 null 이나 undefined 로 바꿈으로써 딕셔너리 모드로 전환되는 것을 막을 수 있지만 그만큼 메모리는 지속적으로 사용될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;elements-kind&quot;&gt;Elements Kind&lt;/h2&gt;

&lt;p&gt;자바스크립트에서 배열도 사실 그냥 객체이다. arr[0] 은 키가 0 인 프로퍼티일 뿐이다. 하지만 V8 은 배열에 대해서 조금 더 특별하게 최적화 한다. 정확히는 배열이라고 전부 다 동일하게 최적화하는건 아니고, 규칙성에 맞게 최적화를 한다.&lt;/p&gt;

&lt;p&gt;아래에서 볼, 객체가 가지는 원소의 타입에 맞게 최적화된다. (= Elements Kind 에 맞게 최적화)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://source.chromium.org/chromium/v8/v8.git/+/ec37390b2ba2b4051f46f153a8cc179ed4656f5d:src/elements-kind.h;l=14&quot;&gt;전체 Elements Kind&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;타입이-달라지면&quot;&gt;타입이 달라지면&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
const array = [1, 2, 3];
// elements kind: PACKED_SMI_ELEMENTS
array.push(4.56);
// elements kind: PACKED_DOUBLE_ELEMENTS

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;엔진의 레벨에서 바라보면, array = [1, 2, 3] 의 경우는 PACKED_SMI_ELEMENTS 로 판별한다. 여기서 SMI 는 Small Integer 이다.&lt;/p&gt;

&lt;p&gt;그런데 array.push(4.56) 을 하고 나면 PACKED_DOUBLE_ELEMENTS 로 바뀐다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
array.push(&apos;x&apos;);
// elements kind: PACKED_ELEMENTS

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마지막으로 문자열을 넣으면, PACKED_ELEMENTS 로 바뀐다.&lt;/p&gt;

&lt;h2 id=&quot;holey&quot;&gt;Holey&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
const array = [1, 2, 3, 4.56, &apos;x&apos;];
// elements kind: PACKED_ELEMENTS
array.length; // 5
array[9] = 1; // array[5] until array[8] are now holes
// elements kind: HOLEY_ELEMENTS

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;length 가 5인 배열에, 갑자기 9번째 인덱스에 1을 넣고 있다. 이 경우에는 array[5] ~ array[8] 까지 구멍이 생긴다.&lt;/p&gt;

&lt;p&gt;이러면 PACKED_ELEMENTS 에서 HOLEY_ELEMENTS 로 바뀌게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-09-05-내_큐는_왜_느릴까.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;73913.png&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 그림은 2025.02.28 이전의 그림인데 자세히보면 화살표의 방향이 위에서 아래로만 되어있다. 즉, 한 번 HOLEY 가 되면 되돌아갈 수 없다는 의미였는데 2025.02.28 이후에는 예외가 하나 생겼다고 한다.&lt;/p&gt;

  &lt;p&gt;Array.prototype.fill 를 통해서 모든 홀을 채우면, PACKED 로 돌아갈 수 있다고 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hole 이 생기게 되면, V8 은 매번 hole 이 있는지 여부를 체크해야하는 로직이 최적화에 포함되고, hole 인지 구분하기 위해 상위 프로토타입까지 거슬러 올라가기때문에 PACKED 보다 최적화가 비효율적이다.&lt;/p&gt;

&lt;h1 id=&quot;더-나은-큐를-만들기&quot;&gt;더 나은 큐를 만들기&lt;/h1&gt;

&lt;p&gt;기존의 큐 방식을 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// 기존 방식(최적화가 잘 되지 않음)
let queue = {};
let head = 0, tail = 0;
function enqueue(x) {
  queue[tail++] = x;
}
function dequeue() {
  if (tail &amp;gt; head) {
    let x = queue[head];
    delete queue[head++];
    return x;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;처음에는 queue 안에서 0, 1, 2… 같은 순서로 인덱스가 증가하기 때문에 객체가 배열처럼 동작한다.&lt;/p&gt;

&lt;p&gt;따라서 SMI(Small Integer) elements kind 로 최적화 된다.&lt;/p&gt;

&lt;p&gt;그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt; 를 하게 되면 0부터 hole 이 생기게 된다. 따라서 PACKED → HOLEY 로 최적화 효율이 다소 안좋아지게 된다.&lt;/p&gt;

&lt;p&gt;그러다가 delete 를 많이 하다보면 head 와 tail 의 숫자는 매우 큰 반면 실제로 객체에 저장된 값은 몇 개 없을 수도 있다. 다시 말해, offset 을 통해서 접근하려고 보니까 앞에 hole 이 너무 많아서 매우 큰 offset 을 통해서 접근해야 하는 것이다.&lt;/p&gt;

&lt;p&gt;이럴 때는 V8 이 배열처럼 최적화하는 것은 비효율적이라고 판단해 딕셔너리 모드로 전환해버릴 수 있다. 이렇게 되면 히든 클래스와 offset 을 사용할 수도 없게 되고, 인라인 캐시 입장에서는 매번 offset 을 통해서 접근했는데, 딕셔너리 모드로 전환되다보니 캐싱된 값이 달라지므로 인라인 캐시도 유지할 수 없다.&lt;/p&gt;

&lt;p&gt;이제부터는 최적화 로직은 거의 사용하지 못하게 되므로 속도가 느려진다.&lt;/p&gt;

&lt;h3 id=&quot;delete-를-안쓰는-방법&quot;&gt;Delete 를 안쓰는 방법&lt;/h3&gt;

&lt;p&gt;delete 를 안쓰면서 메모리 효율도 높일 수 있는 방법은 뭐가 있을까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;원형 큐(고정 크기)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
// 원형 큐
const capacity = 1024;
let queueArr = new Array(capacity);
let head = 0, tail = 0;

function enqueue(x) {
  if ((tail + 1) % capacity === head) throw Error(&quot;queue full&quot;);
  queueArr[tail] = x;
  tail = (tail + 1) % capacity;
}

function dequeue() {
  if (head === tail) return undefined; 
  const x = queueArr[head];
  queueArr[head] = undefined;
  head = (head + 1) % capacity;
  return x;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드와 같은 원형 큐를 한 번 살펴보자.&lt;/p&gt;

&lt;p&gt;고정된 크기의 원형 큐를 한 번 보면, hole 이 생기지 않고 index 도 0부터 쌓이기 때문에 PACKED_SMI 를 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;지금처럼 고정된 큐의 경우에는 리사이징을 할 수 없기 때문에, 리사이징까지 고려하면 아래와 같이 생각해볼 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;대신 아무래도 동적인 크기가 가능해지기 때문에 완전히 모노모픽을 유지하기는 힘들고, 미리 capacity 를 크게 잡아둔다거나 하는 방식으로 너무 빈번한 리사이징이 일어나지 않도록 크기를 잘 잡는게 중요할 것 같다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
  constructor(initialCapacity = 16) {
    this.capacity = initialCapacity;
    this.queue = new Array(this.capacity);
    this.head = 0;
    this.tail = 0;
    this.size = 0;
  }

  enqueue(x) {
    if (this.size === this.capacity) {
      this._grow();
    }
    this.queue[this.tail] = x;
    this.tail = (this.tail + 1) % this.capacity;
    this.size++;
  }

  dequeue() {
    if (this.size === 0) return undefined;
    const x = this.queue[this.head];
    this.queue[this.head] = undefined; // 슬롯 정리 (GC-friendly)
    this.head = (this.head + 1) % this.capacity;
    this.size--;

    if (this.capacity &amp;gt; 16 &amp;amp;&amp;amp; this.size &amp;lt;= this.capacity / 4) {
      this._shrink();
    }
    return x;
  }

  peek() {
    return this.size === 0 ? undefined : this.queue[this.head];
  }

  isEmpty() {
    return this.size === 0;
  }

  _grow() {
    const newCapacity = this.capacity * 2;
    this._resize(newCapacity);
  }

  _shrink() {
    const newCapacity = Math.floor(this.capacity / 2);
    this._resize(newCapacity);
  }

  _resize(newCapacity) {
    const newQueue = new Array(newCapacity);
    for (let i = 0; i &amp;lt; this.size; i++) {
      newQueue[i] = this.queue[(this.head + i) % this.capacity];
    }
    this.queue = newQueue;
    this.capacity = newCapacity;
    this.head = 0;
    this.tail = this.size;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="[&quot;CS&quot;, &quot;Programming&quot;]" /><category term="CS" /><category term="Programming" /><category term="JavaScript" /><summary type="html">자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다.</summary></entry><entry><title type="html">gemini-cli notion mcp 연결하기</title><link href="https://hoeeeeeh.github.io/gemini-cli_notion_mcp_%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0" rel="alternate" type="text/html" title="gemini-cli notion mcp 연결하기" /><published>2025-08-01T10:25:00+00:00</published><updated>2025-08-01T10:25:00+00:00</updated><id>https://hoeeeeeh.github.io/gemini-cli_notion_mcp_%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://hoeeeeeh.github.io/gemini-cli_notion_mcp_%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0">&lt;p&gt;프로젝트의 루트에 간단하게 .gemini/settings.json 에 아래와 같이 코드를 작성하면 notion mcp 가 추가되어야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
  &quot;mcpServers&quot;: {
    &quot;notion&quot;: {
      &quot;command&quot;: &quot;npx&quot;,
      &quot;args&quot;: [&quot;-y&quot;, &quot;@notionhq/notion-mcp-server&quot;],
      &quot;env&quot;: {
        &quot;OPENAPI_MCP_HEADERS&quot;: &quot;{\&quot;Authorization\&quot;: \&quot;Bearer ntn_&amp;lt;key&amp;gt;\&quot;, \&quot;Notion-Version\&quot;: \&quot;2022-06-28\&quot; }&quot;
      }
    }
  }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;근데 내 경우에는 계속 gemini-cli 가 notion mcp 에 disconnected 가 되어 있어서 로그를 봤더니, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeError: fieldValue.toUpperCase is not a function&lt;/code&gt;  라는 에러가 발생하고 있었다.&lt;/p&gt;

&lt;p&gt;구글링을 해보니까 같은 이슈가 이미 올라와있어서 확인해봤다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;원인은 genai v1.8.0 쪽의 버그인데, 1.9.0 버전을 사용하면 해결할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;관련된 MR은 있지만, mcp를 사용할 수 없게 만드는 문제는 버전 업그레이드만으로 해결될 것으로 보입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/google-gemini/gemini-cli/issues/1481&quot;&gt;https://github.com/google-gemini/gemini-cli/issues/1481&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그래서 결국 gemini 버전을 업그레이드 해주면 잘 된다..&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Blog&quot;]" /><category term="[&quot;Blog&quot;]" /><category term="Blog" /><category term="mcp" /><summary type="html">프로젝트의 루트에 간단하게 .gemini/settings.json 에 아래와 같이 코드를 작성하면 notion mcp 가 추가되어야 한다.</summary></entry><entry><title type="html">네이버 부스트캠프 멤버십 최종 회고</title><link href="https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0" rel="alternate" type="text/html" title="네이버 부스트캠프 멤버십 최종 회고" /><published>2025-02-21T07:40:00+00:00</published><updated>2025-02-21T07:40:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0">&lt;p&gt;1차 문제 해결력 테스트(2024.06.15) → 베이직 → 챌린지 → 멤버십 학습스프린트 → 멤버십 그룹프로젝트(2024.12.06) 를 진행하면서의 기억&lt;/p&gt;

&lt;h1 id=&quot;회고를-할까-말까&quot;&gt;회고를 할까 말까..&lt;/h1&gt;

&lt;p&gt;멤버십이 12월 6일에 끝났고 리팩토링 기간 3주를 해도 회고를 작성하고 있는 지금(2월 21일)은 한두 달은 지난 시점으로 회고가 조금 늦었다. 사실 회고를 작성할까 말까 고민이 있었는데 6월부터 시작했으니 2024년 절반을 거의 네이버 부스트캠프 하나에만 집중해서 살았었다. 그래서 네이버 부스트캠프의 공식 일정이 마무리되었다는게 나에게 있어서는 꽤나 큰 이슈였고 대단원의 막이 내린듯한 느낌이 들었다. 하지만 사실은 네이버 부스트캠프가 마무리되었다고 내 인생이 갑작스러운 전환점을 맞이하는것도 아니고 이제 진짜 시작일 뿐이다. 그래서 네이버 부스트캠프가 끝나서 붕 뜬 느낌을 받기 보다 열심히 했던 것을 이어가고 싶었다.&lt;/p&gt;

&lt;p&gt;그런데 내 블로그를 한 번 씩 읽어보면서 베이직, 챌린지때의 회고에서 내가 어떤 경험을 했고 또 구현과 학습의 사이에서 고민했던 흔적을 볼 수 있었다. 특히 챌린지때는 매주 내가 다음주에 개선해보면 좋을 것들을 생각하고 적용해봤던 것 같은데 그때 당시에 느꼈던 생생한 감정들은 이제는 회고를 통해서만 느낄 수 있다.&lt;/p&gt;

&lt;p&gt;그래서 늦었지만 더 까먹기전에 전체적인 회고를 한 번 진행해보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;네이버-부스트캠프-9기-웹모바일-지원&quot;&gt;네이버 부스트캠프 9기 웹모바일 지원&lt;/h1&gt;

&lt;p&gt;대학교를 다니면서 하고 싶었던게 중구난방으로 많았던 것 같다. 안드로이드, IOS 개발자가 되고 싶었다가 또 어느샌가 졸업프로젝트를 하면서는 자동화에 관심이 생겼다. 그리고 취업시장에 딱 나가려니 나만의 강점이 무엇인지 갈피를 잡지 못했다. 그래서 일단은 선택의 폭이 가장 넓은 백엔드 개발자가 되는것을 목표로 삼았다. 백엔드 개발자라고 하면 범주가 되게 크다고 느꼈고 추후에 여러 가지의 길 중에서 하나를 선택할 수 있을 것 같았다. 그래서 거의 백엔드 개발자의 바이블로 여겨지는 자바 + 스프링을 하면서 준비를 해야하나? 하고 고민하던 차에 네이버 부스트캠프 웹모바일이 눈에 띄었고 그때 당시는 별 고민없이 안되면 말고! 하고 지원했던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;1차-문제-해결력-테스트&quot;&gt;1차 문제 해결력 테스트&lt;/h1&gt;

&lt;p&gt;여기서부터 고민이었던 것은 역시 언어와 프레임워크이다. 자바 + 스프링은 백엔드 취업에 있어서 안정적이고 굳이 벗어날 필요가 없는 길이었다. 지금이라도 자바스프링을 공부해야할 것 같은데 네부캠은 자바스크립트로, 그것도 풀스택 과정을 밟아야 했다.&lt;/p&gt;

&lt;p&gt;그래서 네이버 부스트캠프를 지원할 당시에는 네이버 부스트캠프를 통해서 node.js 개발자가 될 지, 아니면 그냥 자바 + 스프링을 공부해서 자프링 개발자가 될 지 선택해야하는 느낌을 받았다. 내가 어떤 일을 할 지도 모르는데 언어와 프레임워크로 나의 개발 라이프 사이클을 결정하고 있었다.&lt;/p&gt;

&lt;p&gt;그리고 결국, 그래도 한 번 들어보고 결정하자라는 가벼운 마음으로 지원을 하게 되었다.&lt;/p&gt;

&lt;p&gt;1차 문제 해결력 테스트는 아마 기억상으로는 언어 제한이 크게 없었던 것 같다. 그래서 평소 코딩테스트 준비하던 파이썬으로 응시를 했고 무난하게 풀었던 것 같다.&lt;/p&gt;

&lt;p&gt;이제부터 있을 모든 테스트는 JS로 언어 제한이 되면서 사실상 자바스크립트를 무조건 공부해야한다는 생각이 들었다.&lt;/p&gt;

&lt;h1 id=&quot;베이직-과정&quot;&gt;베이직 과정&lt;/h1&gt;

&lt;p&gt;베이직 과정에서, 그때 당시에는 문제 구현이 어렵지 않다고 생각했다. 지금 생각해보면 운영진분들의 의도를 내가 명확하게 캐치하지 못했던 것 같기도 하다. 문제가 주어지면 나 스스로 어떻게 문제를 정의하고 해결할지에 가장 방점을 두었어야 했던 것 같은데 구현하는데 급급하지 않았나 싶다.&lt;/p&gt;

&lt;p&gt;이때까지는 베이직이 아니라 그냥 네이버 부스트캠프 자체를 제대로 이해하지 못했던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;챌린지-과정&quot;&gt;챌린지 과정&lt;/h1&gt;

&lt;p&gt;베이직 과정을 거치고 챌린지에 들어선 순간 정말 분위기가 너무 달랐다. 일단 100퍼센트 구현한다는 것 자체가 너무 어려워보였고 구현을 하기 위해 학습도 필요했다. 다른 캠퍼들은 어떻게 구현했는지도 배우면서 또 적용도 하고 나만의 학습 방식을 찾아가는 등, 챌린지 과정은 정말 힘들었고 열심히 했고 많이 배웠다.&lt;/p&gt;

&lt;p&gt;이때 아마 작년 기수 선배님들이 오셔서 “챌린지 과정 같은 기간은 다시 오지 않을 기간이다” 라고 했던 것이 아직도 기억에 남는다. 정말로 다시 경험하기 힘들 과정이었지만 많은 걸 배웠다.&lt;/p&gt;

&lt;h1 id=&quot;멤버십-과정&quot;&gt;멤버십 과정&lt;/h1&gt;

&lt;p&gt;챌린지 과정은 따로 작성해둔 회고가 있어서 이제 본론인 멤버십 과정에 대해서 얘기해보려고 한다.&lt;/p&gt;

&lt;p&gt;멤버십 과정은 첫 오프라인 일정이 있기도 했고 마지막에는 그룹프로젝트가 있어서 기대 반, 걱정 반으로 임했던 것 같다.&lt;/p&gt;

&lt;p&gt;멤버십 과정을 전반적으로 요약하자면 자기 주도적인 문제 해결이었던 것 같다. 멤버십 과정도 모든 것을 100퍼센트 구현하는게 매우 어려웠다. 그래서 학습과 구현사이에서 고민하고 문제를 어떻게 해결할 것인지에 대한 고민을 많이 했었다.&lt;/p&gt;

&lt;p&gt;미션을 하면서 어떻게 하면 프론트엔드에서 State, View 의 흐름을 최대한 단순하게 만들 수 있을까? 라는 고민을 했고 Flux 패턴을 처음 사용했던 Facebook 의 레포지토리에 들어가서 소스 코드를 직접 읽어보며 이해했던 것이 기억에 남는다. 나는 백엔드 개발자로 가고 싶다는 생각을 하고 있었음에도 프론트엔드에서 자주 사용하는 Flux 패턴이 백엔드 아키텍처에서도 충분히 도움이 될 것 같았다. 이때부터 조금씩 개발의 경계선이 무너졌다? 라고 해야할까 언어나 분야가 안중요한 것은 아니지만 다양한 경험도 해보고 싶어졌었다.&lt;/p&gt;

&lt;p&gt;그룹 프로젝트를 진행하면서 영상 도메인을 1순위로 선택해서 팀 매칭을 했는데, 다시 생각해보면 좋은 선택이었던 것 같다. 기획 1주, 마지막 코드프리징 1주를 제외하면 약 4주 동안에 빠르게 개발을 진행해야 했었는데 모든 팀원이 다같이 영상 도메인에 대해서는 사전 지식이 없었다. 우리는 영상 도메인을 활용해서 어떤 주제, 어떤 프로토콜을 사용할지를 학습했고 이를 다같이 공유하며 초반 기획을 다졌다. 그리고 백로그와 주간 이터레이터를 토대로 빠르게 구현을 진행했고 부족했던 사전 지식은 부딪혀보며 점차 메꾸어나갔다. 이 과정에서 초반에 기획한 백로그의 상당수를 덜어내게 되었는데 다시 생각해도 말도 안되는 양의 백로그를 처음에 작성했던 것 같다. 최소 기능을 만들고 기능을 점차 늘려나가는 것에 대한 필요성을 생각해보게 되었던 경험이었다.&lt;/p&gt;

&lt;p&gt;어느정도 기능과 구조에 가닥이 잡힌 이후로는 다같이 구현을 하며 지속적으로 프로젝트의 방향성에 대한 이야기를 나누었던 것 같다.&lt;/p&gt;

&lt;p&gt;챌린지때는 머리 싸매며 새벽까지 학습하고 구현하는 것에 정말 열심이었고, 멤버십은 프로젝트에 욕심이 계속 나서 더 잘하고 싶다는 생각에 즐겁게 힘들 수 있었던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;네이버-부스트-캠프&quot;&gt;네이버 부스트 캠프&lt;/h1&gt;

&lt;p&gt;네이버 부스트 캠프를 진행하면서 개발에 대한 생각이 많이 바뀌었다. 막 대학교를 마치고 나서는 자바 + 스프링을 배워서 빠르게 애플리케이션을 만들어보는 것에 집중하는게 맞다고 생각했었다. 지금은 어떤 언어, 어떤 프레임워크를 쓰든 간에 문제를 어떻게 정의하고 해결책에 근거를 가지는 것에 집중하고 있다. 그 과정에서 내가 선택한 기술이 어떤 원리로 돌아가는지까지 학습하는 것이 베스트인 것 같다.  원리를 알아야 응용이 가능하다.&lt;/p&gt;

&lt;p&gt;처음에 회고를 쓸지 말지 고민하던 이유가, ‘네이버 부스트캠프가 끝나면서 열심히 하던 습관을 잃어버릴까봐’ 였던 만큼 앞으로도 네부캠에서 했던 것을 기억하고 유지해나가고 싶다.&lt;/p&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;NaverBoostcamp&quot;]" /><category term="[&quot;NaverBoostcamp&quot;]" /><category term="NaverBoostcamp" /><category term="Review" /><summary type="html">1차 문제 해결력 테스트(2024.06.15) → 베이직 → 챌린지 → 멤버십 학습스프린트 → 멤버십 그룹프로젝트(2024.12.06) 를 진행하면서의 기억</summary></entry><entry><title type="html">운영체제(페이징, 캐시, 자원 경쟁)</title><link href="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)" rel="alternate" type="text/html" title="운영체제(페이징, 캐시, 자원 경쟁)" /><published>2025-02-04T04:41:00+00:00</published><updated>2025-02-04T04:41:00+00:00</updated><id>https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)">&lt;h1 id=&quot;pcb-와-컨텍스트-스위칭&quot;&gt;PCB 와 컨텍스트 스위칭&lt;/h1&gt;

&lt;p&gt;PCB(Process Control Block) 은 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터 블록이며, 커널 스택에 저장된다.&lt;/p&gt;

&lt;p&gt;각 프로세스가 생성될 때 마다 고유의 PCB가 생성 되고, 프로세스가 종료되면 PCB 는 제거된다.&lt;/p&gt;

&lt;h2 id=&quot;유저-메모리-커널-메모리&quot;&gt;유저 메모리, 커널 메모리&lt;/h2&gt;

&lt;p&gt;가상메모리는 유저메모리와 커널 메모리로 나뉜다.&lt;/p&gt;

&lt;p&gt;유저 메모리와 커널 메모리는 전부 스택 영역을 사용하기 때문에 유저 스택, 커널 스택이라고 부르기도 한다.&lt;/p&gt;

&lt;p&gt;여기서 커널 모드일때만 사용할 수 있는 메모리를 커널 메모리(스택)이라고 한다.&lt;/p&gt;

&lt;p&gt;반대로 유저 모드일때만 사용할 수 있는 메모리는 유저 메모리(스택) 이라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;pcb의-구조&quot;&gt;PCB의 구조&lt;/h1&gt;

&lt;p&gt;Process State : 대기중, 실행 중 등의 프로세스 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;Process Number : 각 프로세스의 고유 식별 번호&lt;/p&gt;

&lt;p&gt;Program Counter : 이 프로세스에 대해 실행될 다음 명령의 주소에 대한 포인터&lt;/p&gt;

&lt;p&gt;Registers : 레지스터 관련 정보&lt;/p&gt;

&lt;p&gt;Memory Limits : 프로세스의 메모리 관련 정보&lt;/p&gt;

&lt;p&gt;List of Open Files : 프로세스를 위해 열린 파일 목록들&lt;/p&gt;

&lt;h1 id=&quot;컨텍스트-스위칭&quot;&gt;컨텍스트 스위칭&lt;/h1&gt;

&lt;p&gt;앞서 설명한 PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정&lt;/p&gt;

&lt;p&gt;이는 프로세스가 종료되거나 인터럽트에 의해 발생된다.&lt;/p&gt;

&lt;h2 id=&quot;컨텍스트-스위칭의-비용&quot;&gt;컨텍스트 스위칭의 비용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;유휴시간의 발생 : 컨텍스트 스위칭을 할 때 마다 유휴시간이 생겨서 CPU의 가용성이 떨어진다.&lt;/li&gt;
  &lt;li&gt;캐시 미스 : 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시 클리어 과정이 무조건 일어나게되고, 이 때문에 캐시 미스가 발생
페이지 테이블에 가상 주소가 실제 주소와 매칭 되어 있음. 그 위에 TLB 캐싱 계층이 있는데, 계속 컨텍스트 스위칭을 하면 캐시 미스가 발생하게 된다. 따라서 캐시를 계속 바꿔야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;프로세스의-상태&quot;&gt;프로세스의 상태&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;프로세스의 상태변화&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;create&quot;&gt;CREATE&lt;/h2&gt;

&lt;p&gt;프로세스가 생성된 상태&lt;/p&gt;

&lt;p&gt;fork, exec 시스템 콜 등을 통해 프로세스가 생성된 상태이며 PCB 가 할당된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fork : 부모 프로세스를 복제해서 자식 프로세스를 생성한다.&lt;/li&gt;
  &lt;li&gt;exec: 현재 프로세스의 메모리 공간에 새로운 실행 파일을 로드하여 기존 프로그램을 대체한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보통은 fork 로 자식 프로세스를 생성한 후에, exec 로 해당 프로그램을 대체하는 방식을 주로 쓴다.&lt;/p&gt;

&lt;p&gt;생성되고 나서는 대기(Ready) 상태로 간다.&lt;/p&gt;

&lt;h2 id=&quot;ready&quot;&gt;Ready&lt;/h2&gt;

&lt;p&gt;처음 프로세스가 생성된 이후, 메모리 공간이 충분하면 메모리를 할당받고 아니면 준비큐에 들어가서 대기중인 상태&lt;/p&gt;

&lt;p&gt;이는 CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다리는 상태&lt;/p&gt;

&lt;h2 id=&quot;ready-suspend&quot;&gt;Ready Suspend&lt;/h2&gt;

&lt;p&gt;Ready 큐가 꽉찬 상태라서, 메모리가 부족하기 때문에 Ready 상태가 아닌 Ready Suspend 가 된 상태&lt;/p&gt;

&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;

&lt;p&gt;실행 상태는 CPU 소유권과 메모리를 할당받고 명령어를 수행 중인 상태.&lt;/p&gt;

&lt;p&gt;CPU Burst 가 일어났다고도 표현한다.&lt;/p&gt;

&lt;h2 id=&quot;blocked&quot;&gt;Blocked&lt;/h2&gt;

&lt;p&gt;어떤 이벤트가 발생한 이후, 잠시 중단되어 프로세스가 차단된 상태&lt;/p&gt;

&lt;p&gt;예를 들어 프린트 인쇄 버튼을 눌렀을 때 프린트 인쇄 I/O 인터럽트에 의해, 현재 실행중이던 프로세스가 잠시 Blocked 상태로 들어갈 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;blocked-suspend&quot;&gt;Blocked Suspend&lt;/h2&gt;

&lt;p&gt;Blocked 된 상태에서 프로세스가 실행되려고 했지만, 레디 큐로 들어가지 못하고 메모리 부족으로 또 다시 중단된 상태&lt;/p&gt;

&lt;h2 id=&quot;terminated--exit&quot;&gt;Terminated / Exit&lt;/h2&gt;

&lt;p&gt;프로세스 실행이 완료되어 해당 프로세스에 대한 자원을 반납하고, PCB 가 삭제된 상태.&lt;/p&gt;

&lt;p&gt;부모 프로세스가 자식 프로세스를 강제로 종료시킨 경우도 있다.&lt;/p&gt;

&lt;h1 id=&quot;브라우저&quot;&gt;브라우저&lt;/h1&gt;

&lt;p&gt;멀티 프로세싱 + 멀티 스레딩&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/5237120&quot;&gt;https://d2.naver.com/helloworld/5237120&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티-프로세싱&quot;&gt;멀티 프로세싱&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;브라우저의 멀티 프로세싱&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레딩&quot;&gt;멀티 스레딩&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc&quot;&gt;IPC&lt;/h1&gt;

&lt;p&gt;Inter Process Communication 이란 프로세스끼리 데이터를 주고 받고 공유 데이터를 관리하는 매커니즘이다.&lt;/p&gt;

&lt;p&gt;IPC 의 종류로는 공유 메모리, 파일, 소켓, 파이프, 메시지 큐가 있다.&lt;/p&gt;

&lt;h2 id=&quot;공유-메모리&quot;&gt;공유 메모리&lt;/h2&gt;

&lt;p&gt;프로세스와 프로세스가 메모리를 공유해서 데이터를 주고 받는 방식&lt;/p&gt;

&lt;p&gt;메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르지만, 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 동기화가 필요&lt;/p&gt;

&lt;p&gt;IPC 중에서 가장 빠른 통신 방법.&lt;/p&gt;

&lt;h2 id=&quot;파일&quot;&gt;파일&lt;/h2&gt;

&lt;p&gt;디스크에 저장된 데이터를 기반으로 통신한다.&lt;/p&gt;

&lt;p&gt;요즘엔 잘 쓰이지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;파이프&quot;&gt;파이프&lt;/h2&gt;

&lt;p&gt;파이프는 통신을 위한 메모리 공간(버퍼)를 생성해서 프로세스 간 통신을 하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;unnamed-pipe-익명-파이프&quot;&gt;(Unnamed Pipe) 익명 파이프&lt;/h3&gt;

&lt;p&gt;익명 파이프는 프로세스 사이에 FIFO 기반의 통신 채널을 만들어 통신하는 방식&lt;/p&gt;

&lt;p&gt;이름이 정해지지 않은, 즉 부를 수 없는 파이프라서 외부에서 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;단방향 통신이므로 양방향 통신을 하려면 2개의 익명 파이프가 필요&lt;/p&gt;

&lt;p&gt;부모, 자식 프로세스 간에서는 파일 디스크립션을 상속 받아서 사용할 수 있으며 다른 네트워크상에서는 사용이 불가능&lt;/p&gt;

&lt;p&gt;파이프의 데이터 용량은 제한되어 있으며 쓰기 프로세스가 읽기 프로세스보다 더 빠르게 데이터를 쓸 수는 없다&lt;/p&gt;

&lt;h3 id=&quot;named-pipe-명명-파이프&quot;&gt;Named Pipe (명명 파이프)&lt;/h3&gt;

&lt;p&gt;익명 파이프의 확장된 개념이며 부모, 자식 뿐만 아니라 다른 네트워크 상에서도 통신할 수 있는 파이프&lt;/p&gt;

&lt;p&gt;보통 서버, 클라이언트용 파이프를 구분해서 동작한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;파이프 시나리오&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;메세지-큐&quot;&gt;메세지 큐&lt;/h2&gt;

&lt;p&gt;메세지 큐는 자료구조 형태로 관리하는 버퍼를 만들어 통신하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;매세지 큐의 동작 방식&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스가 메세지를 보내거나 받기 전에 메세지 큐를 초기화&lt;/li&gt;
  &lt;li&gt;Sender 의 메세지는 큐에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복사&lt;/code&gt;되어 Receiver 에 전달된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;자원-경쟁&quot;&gt;자원 경쟁&lt;/h1&gt;

&lt;h2 id=&quot;공유자원&quot;&gt;공유자원&lt;/h2&gt;

&lt;p&gt;공유자원이란 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태&quot;&gt;경쟁 상태&lt;/h2&gt;

&lt;p&gt;경쟁 상태(Race Condition)은 이 공유 자원을 둘 이상의 프로세스 또는 스레드가 동시에 읽거나 쓰는 상황을 말하며, 동시에 접근을 시도할 때 예상되는 결과값에 영향을 줄 수 있는 상태를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;임계-영역&quot;&gt;임계 영역&lt;/h2&gt;

&lt;p&gt;임계 영역(Critical Section) 은 둘 이상의 프로세스 또는 스레드가 공유 자원에 접근할 때, 순서 등의 이유로 결과가 달라지는 코드 영역을 의미한다.&lt;/p&gt;

&lt;p&gt;즉 경쟁 상태에 있는 영역&lt;/p&gt;

&lt;p&gt;이 영역은 한 번에 둘 이상의 프로세스나 스레드가 접근할 수 없도록 설계된다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태-관리의-중요성&quot;&gt;경쟁 상태 관리의 중요성&lt;/h2&gt;

&lt;h3 id=&quot;데이터-정합성&quot;&gt;데이터 정합성&lt;/h3&gt;

&lt;p&gt;데이터 정합성(data consistency) 는 예상되는 데이터와 값이 같아야함을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-무결성&quot;&gt;데이터 무결성&lt;/h3&gt;

&lt;p&gt;데이터 무결성(data integrity) 는 데이터의 어떠한 규칙을 위반하지 않아야 함을 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 잔고가 음수가 될 수는 없다.&lt;/p&gt;

&lt;p&gt;또한 데이터가 전송, 저장되고 처리되는 모든 과정에서 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성을 말한다.&lt;/p&gt;

&lt;h1 id=&quot;경쟁-상태의-해결-조건&quot;&gt;경쟁 상태의 해결 조건&lt;/h1&gt;

&lt;p&gt;아래의 세 조건을 만족해야 경쟁 상태를 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;상호-배제&quot;&gt;상호 배제&lt;/h2&gt;

&lt;p&gt;상호 배제(mutual exclusion) 은 한 프로세스가 임계 영역에 들어갔을 때, 다른 프로세스는 들어갈 수 없음을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;한정-대기&quot;&gt;한정 대기&lt;/h2&gt;

&lt;p&gt;한정 대기(bounded waiting) 은 특정 프로세스가 임계영역 진입을 요청한 후, 해당 요청이 승인되기 전까지 다른 프로세스가 임계영역에 진입하는 횟수를 제한하는 것을 말하며, 이를 통해 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 되는 것을 방지한다.&lt;/p&gt;

&lt;p&gt;(자원이 독점되지 않도록)&lt;/p&gt;

&lt;h2 id=&quot;진행의-융통성&quot;&gt;진행의 융통성&lt;/h2&gt;

&lt;p&gt;진행의 융통성(progress) 는 만약 어떠한 프로세스도 임계 영역을 사용하지 않는다면, 임계영역 외부의 어떠한 프로세스도 들어갈 수 있으며 이 때 프로세스끼리 서로 방해하지 않는 것을 의미한다.&lt;/p&gt;

&lt;h1 id=&quot;경쟁-상태의-해결-방법&quot;&gt;경쟁 상태의 해결 방법&lt;/h1&gt;

&lt;h2 id=&quot;뮤텍스&quot;&gt;뮤텍스&lt;/h2&gt;

&lt;p&gt;뮤텍스(mutex) 는 공유 자원을 lock() 을 통해 잠금 설정하고 사용한 후에, unlock() 을 통해 잠금해제한다.&lt;/p&gt;

&lt;p&gt;이러한 객체 Lock 을 기반으로 경쟁 상태를 해결하는데, 잠금 상태가 되면 다른 프로세스나 스레드는 해당 코드 영역에 접근할 수 없고, 해제되면 가능하다.&lt;/p&gt;

&lt;p&gt;한 번에 하나의 프로세스만 임계 영역에 있을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;세마포어&quot;&gt;세마포어&lt;/h2&gt;

&lt;p&gt;세마포어(semaphore) 는 일반화된 뮤텍스를 의미한다.&lt;/p&gt;

&lt;p&gt;정수 S, Wait(), Signal() 을 통해서 공유 자원에 대한 접근을 처리한다. 이를 통해 여러 프로세스가 동시에 임계 영역에 접근할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S : 현재 쓸 수 있는 공유 자원의 수&lt;/li&gt;
  &lt;li&gt;Wait() : S 를 1씩 감소 시킨다. 만약 S가 음수라면 공유 자원에 대한 접근은 못하고 블락된 채, 대기열로 들어간다.&lt;/li&gt;
  &lt;li&gt;Signal() : S 를 1씩 증가 시킨다. 프로세스가 공유 자원 사용을 마친 상태이고, S 가 0 이하라면 대기열에 있던 프로세스가 동작하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;바이너리-세마포어&quot;&gt;바이너리 세마포어&lt;/h3&gt;

&lt;p&gt;바이너리 세마포어는 0과 1 두 가지 값만 가질 수 있는 세마포어이다.&lt;/p&gt;

&lt;p&gt;구현의 유사성으로 인해 뮤텍스는 바이너리 세마포어와 유사하다고 할 수 있으나, 뮤텍스는 잠금을 기반으로 상호 배제가 일어나는 잠금 매커니즘이고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 매커니즘이다.&lt;/p&gt;

&lt;h3 id=&quot;카운팅-세마포어&quot;&gt;카운팅 세마포어&lt;/h3&gt;

&lt;p&gt;카운팅 세마포어는 S의 숫자가 1보다 큰, 세마포어를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;모니터&quot;&gt;모니터&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;모니터&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체이다.&lt;/p&gt;

&lt;p&gt;이를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다.&lt;/p&gt;

&lt;h1 id=&quot;교착-상태&quot;&gt;교착 상태&lt;/h1&gt;

&lt;p&gt;교착상태(deadlock) 은 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말한다.&lt;/p&gt;

&lt;p&gt;각각의 프로세스는 서로가 원하는 자원을 유지한 채, 다른 프로세스의 자원을 얻기를 기다린다.&lt;/p&gt;

&lt;p&gt;교착상태가 발생하기 위한 4가지 필요조건은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상호 배제: 주어진 시간 내에 하나의 프로세스만 자원을 독점할 수 있다. 즉 다른 프로세스들은 접근이 불가능&lt;/li&gt;
  &lt;li&gt;점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하며 대기하는 상태&lt;/li&gt;
  &lt;li&gt;비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.&lt;/li&gt;
  &lt;li&gt;환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결-방법-1-bankers-algorithm&quot;&gt;해결 방법 1. Banker’s Algorithm&lt;/h2&gt;

&lt;p&gt;교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당가능 여부를 파악하는 ‘은행원 알고리즘(banker’s algorithm)’&lt;/p&gt;

&lt;p&gt;은행원 알고리즘은 교착 상태를 회피하는 알고리즘으로, 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정, 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘&lt;/p&gt;

&lt;p&gt;안정 상태 : 교착 상태를 일으키지 않은 상태이며, 프로세스의 최대 자원 요구량을 운영체제가 충족시킬 수 있는 상태&lt;/p&gt;

&lt;p&gt;불안정 상태 : 안전 상태로 가는 순서열이 존재하지 않는 상태&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;은행원 알고리즘 예시1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;은행원 알고리즘 예시1&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;해결방법-2-3&quot;&gt;해결방법 2, 3&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지우기&lt;/li&gt;
  &lt;li&gt;해결 방법은 아니지만, 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 오히려 더 클 수도 있다. 따라서 교착 상태가 발생하면 사용자의 작업을 종료시켜버린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;cpu-스케줄링-알고리즘&quot;&gt;CPU 스케줄링 알고리즘&lt;/h1&gt;

&lt;p&gt;스케줄링 알고리즘에는 선점형(preemptive) 알고리즘과, 비선점(non-preemtive)형 알고리즘이 있다.&lt;/p&gt;

&lt;p&gt;중간에 인터럽트를 발생시켜서 강제적으로 컨텍스트 스위칭을 일으키는 것이 선점형알고리즘,&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 종료될 때 까지 대기하고 컨텍스트 스위칭을 일으키는 것이 비선점형 알고리즘이다.&lt;/p&gt;

&lt;h2 id=&quot;비선점형-알고리즘&quot;&gt;비선점형 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;fcfsfirst-come-first-saved&quot;&gt;FCFS(First Come, First Saved)&lt;/h3&gt;

&lt;p&gt;가장 먼저 온 것을 가장 먼저 처리하는 알고리즘&lt;/p&gt;

&lt;p&gt;길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상(convoy effect) 가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;FCFS 알고리즘 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;p1 → p2 → p3 → p4&lt;/p&gt;

&lt;p&gt;p1 이 버스트 타임이 길기 때문에 나머지가 오래 기다려야 한다.&lt;/p&gt;

&lt;h3 id=&quot;sjf-shortest-job-first&quot;&gt;SJF (Shortest Job First)&lt;/h3&gt;

&lt;p&gt;실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘.&lt;/p&gt;

&lt;p&gt;긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation) 이 일어날 수 있지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;평균 대기 시간이 가장 짧다&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하지만 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행 정보를 토대로 추측해야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;실행시간이 매우 긴 프로세스가 있으면 레디큐에서 계속 대기할 확률이 매우 높다.&lt;/p&gt;

&lt;h3 id=&quot;우선-순위-알고리즘&quot;&gt;우선 순위 알고리즘&lt;/h3&gt;

&lt;p&gt;오래된 작업일수록 우선순위를 높이는 방법(aging) 을 통해 SJF 의 단점을 보완한 알고리즘&lt;/p&gt;

&lt;p&gt;우선순위는 작업의 시간, 프로세스의 메모리 요구사항, 열린 파일 수, 평균 CPU 사용량 등을 고려해서 설정&lt;/p&gt;

&lt;h2 id=&quot;선점형-알고리즘&quot;&gt;선점형 알고리즘&lt;/h2&gt;

&lt;p&gt;현대 운영체제가 쓰고 있는 방식으로, 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권을 할당할 수 있는 방식&lt;/p&gt;

&lt;h3 id=&quot;라운드-로빈-rr-round-robin&quot;&gt;라운드 로빈 (RR, Round Robin)&lt;/h3&gt;

&lt;p&gt;현재 컴퓨터가 쓰는 스케쥴링 방법이자 단순한 선점형 알고리즘&lt;/p&gt;

&lt;p&gt;각 프로세스에게 동일한 할당 시간을 주고, 그 시간 안에 끝나지 않으면 다시 준비 큐의 마지막으로 들어가는 알고리즘.&lt;/p&gt;

&lt;p&gt;그런데 동일한 할당 시간을 q 라고 할 때, q 를 너무 크게 주면 사실 상 들어온 순서대로 프로세스를 진행하는 FCFS 가 되어버린다. 따라서 q 를 적절히 조절할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;너무 작게 하면 컨텍스트 스위칭이 너무 많이 일어나면서 오버헤드가 과하게 생길 수 있다.&lt;/p&gt;

&lt;p&gt;일반적으로 전체 작업 시간은 길어지지만, 평균 응답 시간은 짧아진다는 특징이 있다.&lt;/p&gt;

&lt;h3 id=&quot;srfshortest-remaining-time-first&quot;&gt;SRF(Shortest Remaining Time First)&lt;/h3&gt;

&lt;p&gt;SRF 는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 즉시 중지하고 더 짧은 프로세스를 수행한다.&lt;/p&gt;

&lt;p&gt;SJF 는 비선점형이기 때문에 해당 프로세스가 끝나야 그 다음 제일 짧은 프로세스를 수행하는 것과의 차이가 있다.&lt;/p&gt;

&lt;h3 id=&quot;다단계-큐&quot;&gt;다단계 큐&lt;/h3&gt;

&lt;p&gt;우선순위에 따른 준비 큐를 여러 개 사용하고, 큐 마다 라운드 로빈이나 FCFS 등 다른 스케쥴링 알고리즘을 적용한 것을 말한다.&lt;/p&gt;

&lt;p&gt;큐 간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징이 있다.&lt;/p&gt;

&lt;p&gt;우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리 되지 않는 기아 현상(starvation) 이 발생할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;캐시&quot;&gt;캐시&lt;/h1&gt;

&lt;p&gt;데이터를 미리 복사해 놓는 임시 저장소이자, 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다. 이를 통해 데이터 접근 시간의 단축, 데이터를 다시 계산하는 등의 시간을 절약할 수 있다.&lt;/p&gt;

&lt;p&gt;캐시의 예로 CPU 레지스터를 들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;캐시-설정-원리&quot;&gt;캐시 설정 원리&lt;/h2&gt;

&lt;p&gt;캐시를 설정할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자주 사용하는 데이터&lt;/code&gt; 를 기반으로 설정해야 한다.&lt;/p&gt;

&lt;p&gt;이 때 지역성을 기반으로 설정하게 되는데 지역성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시간 지역성&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공간 지역성&lt;/code&gt; 으로 나뉜다.&lt;/p&gt;

&lt;h3 id=&quot;시간-지역성&quot;&gt;시간 지역성&lt;/h3&gt;

&lt;p&gt;시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성&lt;/p&gt;

&lt;h3 id=&quot;공간-지역성&quot;&gt;공간 지역성&lt;/h3&gt;

&lt;p&gt;공간 지역성은 최근 접근한 데이터를 이루고 이쓴ㄴ 공간이나 그 가까운 공간에 접근하는 특성&lt;/p&gt;

&lt;h2 id=&quot;캐시-매핑&quot;&gt;캐시 매핑&lt;/h2&gt;

&lt;p&gt;캐시의 크기는 메모리보다 항상 작기 때문에 효율적으로 매핑하는 것이 중요하며 매핑 방식에는 직접 매핑, 연관 매핑, 집합 - 연관 매핑이 있다.&lt;/p&gt;

&lt;h3 id=&quot;직접-매핑direct-mapping&quot;&gt;직접 매핑(direct mapping)&lt;/h3&gt;

&lt;p&gt;직접 블록별로 매핑을 한다.&lt;/p&gt;

&lt;p&gt;캐시가 다섯 블록이라면, 메모리를 5개의 영역으로 나누어서 각각의 영역당 하나의 캐시에 매핑 할 수 있도록 만든다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;특정 라인과 특정 블록이 매핑되어 있는 것&lt;/p&gt;

&lt;p&gt;메모리 블록의 사이즈는 메모리의 크기 / 캐시의 블록 개수&lt;/p&gt;

&lt;p&gt;운영체제는 보통 메모리를 똑같은 크기의 페이지(보통 4kb)&lt;/p&gt;

&lt;p&gt;4kb 인 이유? : &lt;a href=&quot;https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80&quot;&gt;https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;블록 당 영역이 정해져있기 때문에, 같은 블록에서 여러 개를 캐싱할 수 없다.&lt;/p&gt;

    &lt;p&gt;따라서 같은 블록의 참조가 빈번하다면 계속 캐시를 스와핑해주어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대신 특정 정보의 캐시를 찾을 때 특정 블록만 찾으면 된다는 장점이 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연관-매핑associative-mapping&quot;&gt;연관 매핑(associative mapping)&lt;/h3&gt;

&lt;p&gt;순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하며 메모리의 컨텐츠가 캐시의 어느 위치에도 올라갈 수 있는 방법(자유롭게 캐싱)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특정 정보의 캐시를 찾을 때, 모든 캐시를 탐색해야한다.&lt;/li&gt;
  &lt;li&gt;그러나 스와핑이 빈번하게 일어나지는 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;집합-연관-매핑set-associate-mapping&quot;&gt;집합 연관 매핑(set associate mapping)&lt;/h2&gt;

&lt;p&gt;집합을 나누고(집합 매핑과 유사) 해당 집합에는 block descriptor 만 같으면 들어올 수 있게 하는데, 이 때 어떤 블럭에도 들어갈 수 있게 한다.(연관 매핑과 유사)&lt;/p&gt;

&lt;p&gt;즉 캐시의 집합을 나누었는데, 집합에 1개의 블록만 있다면 직접 매핑이고, 캐시 집합이 1개라면 연관 매핑인 것이다.&lt;/p&gt;

&lt;p&gt;이를 통해 모든 블럭을 찾을 필요 없이, 특정 블럭을 찾게 해 탐색 비용을 낮춘 직접매핑의 장점과 스와핑을 완화시키는 연관매핑의 장점을 모두 지니게 된다.&lt;/p&gt;

&lt;h1 id=&quot;메모리-할당&quot;&gt;메모리 할당&lt;/h1&gt;

&lt;p&gt;프로그램에 필요한 메모리를 할당할 때 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데 이는 연속할당과 불연속 할당으로 나뉜다.&lt;/p&gt;

&lt;h2 id=&quot;연속-할당&quot;&gt;연속 할당&lt;/h2&gt;

&lt;p&gt;메모리에 연속적으로 공간을 할당하는 것. 사용 가능한 모든 메모리 공간이 같은 위치에 있다.&lt;/p&gt;

&lt;p&gt;즉 메모리 파티션이 전체 메모리 공간에 분산되어 있지 않다.&lt;/p&gt;

&lt;p&gt;이는 고정분할방식과 가변분할방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;고정-분할-방식&quot;&gt;고정 분할 방식&lt;/h3&gt;

&lt;p&gt;고정분할방식은 메모리를 미리 같은 크기로 분할해서 할당하는 방법.&lt;/p&gt;

&lt;p&gt;고정 크기를 프로그램에 할당하므로, 프로그램의 크기보다 더 큰 메모리를 할당하게 된다.&lt;/p&gt;

&lt;p&gt;따라서 내부 단편화(internal framentation)가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;가변-분할-방식&quot;&gt;가변 분할 방식&lt;/h3&gt;

&lt;p&gt;가변분할방식은 프로그램에 필요한 만큼 동적으로 할당하는 방법.&lt;/p&gt;

&lt;p&gt;내부 단편화가 아닌 외부 단편화가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/13.png&quot; alt=&quot;13&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;가변 분할 방식에는 최초 적합, 최적 적합, 최악 적합이 있다.&lt;/p&gt;

&lt;p&gt;홀(hole) : 할당할 수 있는, 비어 있는 메모리 공간&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최초 적합(frist fit) : 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당&lt;/li&gt;
  &lt;li&gt;최적 적합(best fit) : 필요한 메모리 크기 이상인 공간 중에서 가장 작은 홀에 할당&lt;/li&gt;
  &lt;li&gt;최악 적합(worst fit) : 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불연속-할당&quot;&gt;불연속 할당&lt;/h2&gt;

&lt;p&gt;메모리를 연속적으로 할당하지 않는 방법으로, 현대 운영체제가 쓰는 방법.&lt;/p&gt;

&lt;p&gt;프로그램에 필요한 메모리를 쪼개어 서로 다른 위치에 있는 메모리 공간에 할당&lt;/p&gt;

&lt;p&gt;페이징, 세그멘테이션, 페이지드 세그멘테이션 기법이 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이징&quot;&gt;페이징&lt;/h3&gt;

&lt;p&gt;페이징은 동일한 크기의 페이지 단위(보통 4kb)로 나누어 메모리의 서로 다른 위치에 프로세스를 할당&lt;/p&gt;

&lt;p&gt;홀의 크기가 균일하지 않은 문제는 없어지지만 주소 변환을 페이지별로 해야 하기 때문에 주소 변환이 복잡해지는 단점이 있다.&lt;/p&gt;

&lt;p&gt;외부 단편화가 생겨도 분할해서 할당할 수 있기 때문에, 외부 단편화를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;그렇지만 결국 동일한 크기의 페이지 단위로 나눈다는 것은 언제나 내부 단편화를 유발할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;세그멘테이션&quot;&gt;세그멘테이션&lt;/h3&gt;

&lt;p&gt;페이지 단위가 아닌, 의미 단위인 세그먼트로 나누는 방식(즉, 동일한 크기가 아닐 수 있다.)&lt;/p&gt;

&lt;p&gt;프로세스는 코드, 데이터, 스택, 힙으로 나누어져서 메모리가 할당되는데 코드와 데이터, 또는 코드와 스택 등으로 나눌 수도 있으며 함수 단위로도 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;공유와 보안 측면에서 좋지만 홀 크기가 균일하지 않게 된다.&lt;/p&gt;

&lt;p&gt;내부 단편화는 해결될 수 있지만, 다시 외부 단편화가 일어날 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이지드-세그멘테이션&quot;&gt;페이지드 세그멘테이션&lt;/h3&gt;

&lt;p&gt;세그멘테이션으로 나누되, 해당 세그멘테이션을 동일한 크기의 페이지로 나누는 방법&lt;/p&gt;

&lt;p&gt;세그먼트에 의해 1kb, 5kb 로 나뉘었다면 이를 2kb 기준으로 나누어 2kb, (2kb, 2kb, 2kb) 로 나누는 방식&lt;/p&gt;

&lt;h1 id=&quot;busy-wait&quot;&gt;busy wait&lt;/h1&gt;

&lt;p&gt;busy wait 는 프로세스, 스레드가 어떠한 일을 실행하기 전에 만족하는 조건을 지속적으로 확인하는 동기화 기술이다.&lt;/p&gt;

&lt;p&gt;프로세스1이 점유하고 있는 자원을, 프로세스 2가 사용하고 싶을 때 blocking 되고 대기하는 과정이다.&lt;/p&gt;

&lt;h1 id=&quot;운영체제와-펌웨어의-차이&quot;&gt;운영체제와 펌웨어의 차이&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;펌웨어는 ROM 이라고 불리는 비휘발성 메모리 하나를 쓰는 반면, 운영체제는 휘발성 비휘발성 메모리를 계층화해서 사용한다.&lt;/li&gt;
  &lt;li&gt;펌웨어는 자유롭게 프로그램을 설치할 수 없으며, 미리 설치해놓은 프로그램을 기반으로 업데이트가 일어난다.
ROM 에 해당 소프트웨어를 지우고 덮어쓰면서 업데이트가 발생. → 멱등성처럼 변화를 최소화 하는 느낌인거 같다
반면, 운영체제는 정기적으로 업데이트 되며 프로그램을 자유롭게 설치할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="운영체제" /><summary type="html">PCB 와 컨텍스트 스위칭</summary></entry><entry><title type="html">백준 21939 문제 추천 시스템 Version 1</title><link href="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1" rel="alternate" type="text/html" title="백준 21939 문제 추천 시스템 Version 1" /><published>2025-02-03T08:07:00+00:00</published><updated>2025-02-03T08:07:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1">&lt;p&gt;&lt;img src=&quot;/upload/2025-02-03-백준_21939_문제_추천_시스템_Version_1.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;문제 추천 시스템 Version 1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;recommend(x) : x 가 1이면 난이도 가장 높은 문제를 우선순위 큐에서 출력, x 가 -1 이면 난이도가 가장 쉬운 문제를 출력.&lt;/p&gt;

    &lt;p&gt;→ 우선 순위큐를 minHeap, maxHeap 두 개를 써야겠다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;add(P, L) : 문제 번호가 P, 난이도가 L 인 문제를 추가&lt;/p&gt;

    &lt;p&gt;→ 2개의 우선순위 큐에 전부 넣어야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;solved(P) : 문제 번호가 P인 문제를 풀었다는 의미이므로, recommend 를 할 때 풀었던 문제는 추천하지 않도록 어딘가에 저장해두어야 함.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제는 우선순위 큐와 Map 혹은 Object 를 쓰면 쉽게 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;문제가 Solved 되면 Map 혹은 Object 에 기억해뒀다가, recommend 명령어에 의해서 문제를 추천할 때 Solved 된 문제라면 다음 Min (혹은 Max) Heap 에서 하나를 더 꺼내면 된다.&lt;/p&gt;

&lt;p&gt;그래서 문제 난이도가 그렇게 높게 잡히지는 않았는데 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javascript 에 우선순위 큐가 없다&lt;/code&gt;는 점이다.&lt;/p&gt;

&lt;p&gt;추가로 PriorityQueue 의 heap 을 일반 배열이 아닌 Queue 를 직접 구현했는데, 문제를 풀면서 heap 에 직접 shift 를 해야하는 경우가 필요하다고 착각했다.  dequeue 를 여러 번 하면 되는 일이었는데.&lt;/p&gt;

&lt;p&gt;자바스크립트는 배열의 shift 가 O(1) 이 아닌 O(n) 이다보니, shift 를 하려면 Queue 를 직접 구현해야해서 사용하면서도 일반 배열처럼 사용할 수 있는 방법을 고민하면서 풀었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Queue 에 배열처럼 index 만으로 접근하고 싶었는데 내가 만든 Queue 는 head 와 tail 로 이동하기 때문에 head 로 인덱스의 값을 보정해야했다.&lt;/p&gt;

&lt;p&gt;덕분에 모든 자료구조를 다 직접 짜면서 하다보니 코드가 엄청나게 길어졌다.&lt;/p&gt;

&lt;p&gt;아래는 삽질한 코드이다..&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Problem {
    constructor(num, level) {
        this.num = num;
        this.level = level;
    }
}

class PriorityQueue {
    heap = new Queue();

    constructor(comparator) {
        if(comparator) this.comparator = comparator.bind(this);
        else this.comparator = (a, b) =&amp;gt; this.heap.get(a) - this.heap.get(b);
    }

    enqueue(value){
        const heapLength = this.heap.push(value);
        this.bubbleUp(heapLength - 1);
    }

    peek(){
        return this.heap.get(0);
    }

    dequeue(){
        if(this.isEmpty()) return undefined;

        const root = this.heap.get(0);
        const leap = this.heap.pop();
        if(this.isEmpty()) return root;
        this.heap.set(0, leap);
        this.bubbleDown(0);

        return root;
    }

    bubbleUp(index_){
        let index = index_;
        while(index &amp;gt; 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if(this.comparator(index, parentIndex) &amp;gt;= 0) break;
            this.swap(index, parentIndex);
            index = parentIndex;
        }
        return index;
    }

    bubbleDown(index_){
        let index = index_;
        let smallestIndex = index;
        while(smallestIndex &amp;lt; this.heap.length){

            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;

            if(leftChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(leftChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = leftChildIndex;
            }
            if(rightChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(rightChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = rightChildIndex;
            }

            if(smallestIndex === index) break;
            this.swap(index, smallestIndex);
            index = smallestIndex;
        }
        return index;
    }

    isEmpty(){
        return this.heap.length === 0;
    }

    swap(i, j){
        const restore = this.heap.get(i);
        this.heap.set(i, this.heap.get(j));
        this.heap.set(j, restore);
    }
}

class Queue {
    items = {}
    head = 0;
    tail = 0;

    get length(){
        return this.tail - this.head;
    }

    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }

    constructor() {}

    push(value){
        this.items[this.tail] = value;
        this.tail += 1;
        return this.length;
    }

    pop(){
        if(this.isEmpty()) return undefined;
        const leaf = this.items[this.tail - 1];
        delete this.items[this.tail - 1];

        if(!this.isEmpty()) this.tail -= 1;
        return leaf;
    }

    isEmpty(){
        if(this.head !== this.tail) return false

        this.head = this.tail = 0;
        return true

    }
}

class ProblemPriorityQueue extends PriorityQueue {
    solvedProblems = {}
    constructor(comparator) {
        super(comparator);
    }
    solved(index){
        this.solvedProblems[index] = true;
    }

    peek(){
        this.removeSolvedProblem();
        return super.peek();
    }

    removeSolvedProblem(){
        let peek = super.peek();
        while(peek.num in this.solvedProblems){
            super.dequeue();
            delete this.solvedProblems[peek.num];
            peek = super.peek();
        }
    }
}

function minComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(a).level - this.heap.get(b).level;
    return this.heap.get(a).num - this.heap.get(b).num;
}

function maxComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(b).level - this.heap.get(a).level;
    return this.heap.get(b).num - this.heap.get(a).num;
}

function add(P, L){
    minPPQ.enqueue(new Problem(P, L));
    maxPPQ.enqueue(new Problem(P, L));
}

function solved(P) {
    minPPQ.solved(P);
    maxPPQ.solved(P);
}

function recommend(x){
    if(x === -1) {
        return minPPQ.peek().num;
    } else {
        return maxPPQ.peek().num;
    }
}

const readline = require(&quot;readline&quot;);
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let N = -1;
let M = -1;
let count = -1;
let answer = [];
const minPPQ = new ProblemPriorityQueue(minComparator);
const maxPPQ = new ProblemPriorityQueue(maxComparator);

rl.on(&quot;line&quot;, (line) =&amp;gt; {
    if(N === -1){
        N = parseInt(line);
        count = N;
    } else if (count &amp;gt; 0) {
        const [num, level] = line.split(&apos; &apos;).map((n) =&amp;gt; parseInt(n))
        add(num, level);
        count -= 1;
    } else {
        if(M === -1) M = parseInt(line);
        else {
            const [cmd, num1, num2] = line.split(&apos; &apos;);
            if (cmd === &apos;recommend&apos;) {
                const log = recommend(parseInt(num1));
                answer.push(log);
            } else if (cmd === &apos;solved&apos;) {
                solved(parseInt(num1));
            } else {
                add(parseInt(num1), parseInt(num2))
            }
        }
    }
}).on(&quot;close&quot;, () =&amp;gt; {
    console.log(answer.join(&apos;\n&apos;));
})


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;Programming&quot;]" /><category term="[&quot;Programming&quot;]" /><category term="Programming" /><category term="Algorithm" /><category term="JavaScript" /><summary type="html">문제 추천 시스템 Version 1</summary></entry><entry><title type="html">JS TS 로 Queue 구현</title><link href="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84" rel="alternate" type="text/html" title="JS TS 로 Queue 구현" /><published>2025-01-31T07:42:00+00:00</published><updated>2025-01-31T07:42:00+00:00</updated><id>https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84</id><content type="html" xml:base="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84">&lt;h1 id=&quot;objector-map-을-활용한-queue&quot;&gt;Object(or Map) 을 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class ObjectQueue {
    item = {};
    start = 0;
    end = 0;

    constructor() {}

    enqueue(value){
        this.item[this.end] = value;
        this.end += 1;
        return this.end - 1;
    }
    
     // 큐가 비어 있을 때는 undefined, 그렇지 않은 경우 0 번째 원소를 반환
    dequeue(){
        if(this.isEmpty()) return undefined;
        const value = this.item[this.start];
        delete this.item[this.start];
        this.start += 1;
        return value;
    }

    isEmpty(){
        if(this.start === this.end) {
            this.start = 0;
            this.end = 0;
            return true;
        }
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Object 나 Map 을 활용해서 key-value 형식으로 저장한다.&lt;/p&gt;

&lt;p&gt;다만 Object, Map 이 사용하는 메모리가 다른 방법에 비해 많아, 메모리 효율은 다소 떨어질 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;linkedlist-를-활용한-queue&quot;&gt;LinkedList 를 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Node {
    value = null;
    next = null
    constructor(value) {
        this.value = value;
    }
}

class LinkedListQueue {
    front = null;
    rear = null;
    length = 0;

    enqueue(value){
        const newNode = new Node(value);
        // rear 가 null 인, 초기 상황일 때
        if(!this.rear) {
            this.front = this.rear = newNode;
        } else {
            // 현재 맨 마지막 노드의 다음 노드를 newNode 로 지정하고, newNode 를 마지막 노드로 지정
            this.rear.next = newNode;
            this.rear = newNode;
        }
        this.length += 1;
    }

    dequeue() {
        if(!this.front) {
            return undefined;
        }
        const value = this.front.value;
        this.front = this.front.next;

        // 하나를 dequeue 하고 Queue 에 아무것도 없을 때
        if(!this.front) {
            this.rear = null;
        }
        this.length -= 1;

        return value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;원형-큐&quot;&gt;원형 큐&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularQueue&amp;lt;T&amp;gt; {
    private readonly items: (T | null)[];
    private readonly capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueue(value: T) {
        if (this.isFull()) return false;
        this.items[this.rear] = value;

        // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 front 까지 다시 사용
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
        return true;
    }

    dequeue() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        
         // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 rear 까지 다시 사용
        this.front = (this.front + 1) % this.capacity; 
        this.size--;
        return value;
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐는 고정 사이즈를 정하고, 고정 사이즈만큼의 배열을 순환하면서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 만약 배열이 꽉 찼는데도 enqueue 가 일어나면 문제가 된다. 배열에 이미 값이 존재하는데 그 위에 덮어쓰게 되기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 원형큐가 가득 찼으면 배열을 그 순간에 늘리거나 해야한다.&lt;/p&gt;

&lt;p&gt;이 과정에서 기존 배열을 복사해야해서 시간이 많이 소요된다.&lt;/p&gt;

&lt;p&gt;이렇게 보면 원형큐는 dequeue 보다 enqueue 가 월등히 많은 경우, 썩 좋지 못할 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;원형-덱deque-double-ended-queue&quot;&gt;원형 덱(deque, Double Ended Queue)&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularDeque&amp;lt;T&amp;gt; {
    private items: (T | null)[];
    private capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueueFront(value: T) {
        if (this.isFull()) this.resize();
        this.front = (this.front - 1 + this.capacity) % this.capacity;
        this.items[this.front] = value;
        this.size++;
    }

    enqueueBack(value: T) {
        if (this.isFull()) this.resize();
        this.items[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
    }

    dequeueFront() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        return value as T;
    }

    dequeueBack() {
        if (this.isEmpty()) return undefined;
        this.rear = (this.rear - 1 + this.capacity) % this.capacity;
        const value = this.items[this.rear];
        this.items[this.rear] = null;
        this.size--;
        return value as T;
    }

    peekFront() {
        return this.isEmpty() ? undefined : (this.items[this.front]);
    }


    peekBack() {
        return this.isEmpty() ? undefined : (this.items[(this.rear - 1 + this.capacity) % this.capacity]);
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }

    getSize() {
        return this.size;
    }

    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐와 큰 차이는 없다.&lt;/p&gt;

&lt;p&gt;여기서 원형 큐나, 원형 데크나 resize 부분을 알아둬야한다.&lt;/p&gt;

&lt;h2 id=&quot;resize&quot;&gt;Resize&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;resize 부분을 보면 capacity 를 2배(혹은 원하는 만큼) 늘리고나서&lt;/p&gt;

&lt;p&gt;for 문 내부에서 아이템을 복제 및 정렬을 한다.&lt;/p&gt;

&lt;p&gt;언뜻 생각해보면 capacity 만 2배로 복제해도 되지 않을까 싶지만 기존 배열의 순서를 정렬해서 새로운 배열에 적용해야만 한다.&lt;/p&gt;

&lt;p&gt;예시를 들어서 살펴보면,&lt;/p&gt;

&lt;h3 id=&quot;기존-상태-1234-덱에-삽입&quot;&gt;기존 상태 (1,2,3,4 덱에 삽입)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 1  ] [ 2  ] [ 3  ] [ 4  ]  
Front → index 0
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-2-dequeue&quot;&gt;1, 2 dequeue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ X  ] [ X  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-6-enqueue&quot;&gt;5, 6 enqueue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 2 (가득 참)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-enqueue-resize-실행&quot;&gt;7 enqueue (Resize 실행)&lt;/h3&gt;

&lt;p&gt;단순히 Capacity 만 늘리는 경우(잘못된 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
	Index:      0      1      2      3      4      5      6      7
	Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ] [ X  ] [ X  ] [ X  ] [ X  ]
	Front → index 2
	Rear  → index 4
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3 → 4→ 5→ 6 순서가 아니라, 5 → 6 → 3→ 4 가 되어버린다.&lt;/p&gt;

&lt;p&gt;따라서 3,4,5,6 순서로 정렬시켜주는 과정이 필요&lt;/p&gt;

&lt;p&gt;resize 및 정렬 과정(올바른 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3      4      5      6      7
Items:    [ 3  ] [ 4  ] [ 5  ] [ 6  ] [ X  ] [ X  ] [ X  ] [ X  ]
Front → index 0
Rear  → index 4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Algorithm" /><category term="JavaScript" /><category term="TypeScript" /><summary type="html">Object(or Map) 을 활용한 Queue</summary></entry><entry><title type="html">리눅스 컨테이너</title><link href="https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88" rel="alternate" type="text/html" title="리눅스 컨테이너" /><published>2025-01-27T03:16:00+00:00</published><updated>2025-01-27T03:16:00+00:00</updated><id>https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88">&lt;p&gt;도커 등의 컨테이너 기술을 사용하면서, 리눅스의 어떤 명령어들로 이런 컨테이너 기술이 동작할 수 있는지 문득 궁금해졌다.&lt;/p&gt;

&lt;h1 id=&quot;linux-namespace&quot;&gt;Linux Namespace&lt;/h1&gt;

&lt;p&gt;리눅스 네임스페이스는 리눅스 커널에서 제공하는 기능으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스가 시스템의 특정 리소스를 독립적으로 볼 수 있도록 격리하는 매커니즘&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 개의 마운트 네임스페이스 A, B 를 생성했을 때, 각자의 작업이 서로에게 영향을 끼치지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 A 네임스페이스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/test&lt;/code&gt; 를 만들었어도, B 네임스페이스에서는 /test 에 접근 할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;unshare&quot;&gt;unshare&lt;/h2&gt;

&lt;p&gt;마운트 네임스페이스를 직접 생성하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshare --mount {실행파일}&lt;/code&gt; 을 통해서 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;이 명령어를 통해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshare&lt;/code&gt; 이라는 시스템콜이 {실행파일} 인자 (→ CLONE_NEWNS 파라미터)와 함께 사용된다.&lt;/p&gt;

&lt;p&gt;unshare 명령을 사용한 프로세스가 부모 프로세스가 되고, 자식 프로세스를 생성 할 때 마운트 네임스페이스를 생성하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 부모 프로세스가 가지고 있던 마운트 포인트가 자식 프로세스에게 그대로 복사가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;proc&quot;&gt;proc&lt;/h3&gt;

&lt;p&gt;마운트 네임스페이스를 직접 생성해보자.&lt;/p&gt;

&lt;p&gt;마운트 네임스페이스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 디렉토리에 존재한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;proc 디렉토리는 시스템의 프로세스 및 스레드에 대한 상태 정보를 포함한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;proc 파일 시스템은 시스템에 있는 각 활성 프로세스 및 스레드의 상태에 대한 액세스를 제공한다.&lt;/p&gt;

&lt;p&gt;proc 디렉토리 내부를 보게 되면 프로세스 아이디로 이루어진 폴더들과 여러가지 정보(cpuinfo, meminfo, devices…) 등이 있는걸 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;ls /proc&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;현재 사용하고 있는 Shell 의 프로세스 아이디를 찾아서 /proc 에서 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
echo $$

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 명령어를 통해 프로세스 아이디를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 찾아낸 프로세스 아이디를 proc 에서 확인해보면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;ls /proc/{PID} 혹은 ls/proc/$$&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이런식으로 많은 것들이 들어있다.&lt;/p&gt;

&lt;p&gt;여기서 이 프로세스의 마운트 네임스페이스 번호를 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;프로세스의 마운트 네임스페이스&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc/$$/ns/mnt&lt;/code&gt; 로 프로세스의 마운트 네임스페이스를 확인할 수 있는데, 이는 symbolic link 라서 readlink 명령어를 통해서 symbolic link 의 값을 읽어보자.&lt;/p&gt;

&lt;h3 id=&quot;unshare-mount&quot;&gt;unshare —mount&lt;/h3&gt;

&lt;p&gt;4026531841 이 현재 프로세스의 pid 인걸 기억해두고 새로운 shell 창을 하나 더 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;shell 2개&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사진이 조금 이상해보일 수 있지만 쉘 창을 왼쪽과 오른쪽에 띄워놓은 상태이다.&lt;/p&gt;

&lt;p&gt;두 shell 창의 마운트 네임스페이스를 보면 같은 걸 알 수 있는데, 기본적으로 shell 창을 열든 ssh를 통해서 접속하든 새로운 마운트 네임스페이스를 만들지는 않는다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo unshare --mount /bin/sh&lt;/code&gt; 명령어를 통해서 오른쪽에 새로운 마운트 네임스페이스를 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;새로운 마운트 네임스페이스 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--mount&lt;/code&gt; 옵션을 주지 않으면, 새로운 마운트 네임스페이스를 만들지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;—mount 옵션 없이 unshare&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;왼쪽과 오른쪽 쉘의 mount namespace 가 같은 것을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;findmnt--a&quot;&gt;findmnt -A&lt;/h3&gt;

&lt;p&gt;다시 새로운 마운트 네임스페이스로 넘어와서, —mount 옵션을 주면서 새로운 마운트 네임스페이스를 생성하면 부모 네임스페이스로부터 마운트 포인트를 복사해서 자식 네임스페이스로 전달한다는 걸 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findmnt - A&lt;/code&gt; 옵션을 통해 마운트 포인트를 전부 확인할 수 있는데, 출력 순서가 조금 뒤바뀌었지만 값은 전부 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;자식-네임스페이스와-부모-네임스페이스는-서로-영향을-미치지-않는다&quot;&gt;자식 네임스페이스와 부모 네임스페이스는 서로 영향을 미치지 않는다.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;부모 프로세스에서 마운트 포인트 만들기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 부모 마운트 네임스페이스에서 새롭게 마운트를 했을 때, 자식 마운트 네임스페이스에 영향을 미치는지 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
sudo mount -t tmpfs tmpfs /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 위의 명령어를 통해 새로운 마운트 포인트를 하나 만들어볼건데, /tmp/mount_test 라는 디렉토리에 tmpfs 타입을 마운트 한다.&lt;/p&gt;

&lt;p&gt;여기서 tmpfs 는 임시 파일 시스템을 의미하는데, RAM을 기반으로 하는 가상 파일 시스템이다.&lt;/p&gt;

&lt;p&gt;RAM 은 휘발되기 때문에 시스템을 종료하면 당연히 다 없어진다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 를 통해 마운트가 되었는지도 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;df 명령어는 disk free 의 약자로, 파일 시스템의 디스크 사용량을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;-h 옵션은 human-readable, 즉 사람이 읽기 쉽게 포매팅 해준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ df -h
Filesystem                         Size  Used Avail Use% Mounted on
tmpfs                              391M  1.4M  389M   1% /run
efivarfs                           256K   27K  230K  11% /sys/firmware/efi/efivars
/dev/mapper/ubuntu--vg-ubuntu--lv   30G  7.9G   21G  28% /
tmpfs                              2.0G     0  2.0G   0% /dev/shm
tmpfs                              5.0M     0  5.0M   0% /run/lock
/dev/vda2                          2.0G  190M  1.6G  11% /boot
/dev/vda1                          1.1G  6.4M  1.1G   1% /boot/efi
tmpfs                              391M   12K  391M   1% /run/user/1000
tmpfs                              2.0G     0  2.0G   0% /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findmnt -A&lt;/code&gt; 를 통해서도 확인해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ findmnt -A | grep /tmp/mount_test
└─/tmp/mount_test              tmpfs                             tmpfs       rw,relatime,inode64

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 부모 네임스페이스에서는 tmpfs 를 새롭게 마운트했는데, 자식 네임스페이스에서 이를 확인할 수 있는지 살펴보자.&lt;/p&gt;

&lt;p&gt;아래는 자식 네임스페이스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 를 한 결과이다.&lt;/p&gt;

&lt;p&gt;살펴보면 /tmp/mount_test 의 마운트 포인트는 없다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
# df -h
Filesystem                         Size  Used Avail Use% Mounted on
/dev/mapper/ubuntu--vg-ubuntu--lv   30G  7.9G   21G  28% /
tmpfs                              2.0G     0  2.0G   0% /dev/shm
tmpfs                              391M  1.4M  389M   1% /run
tmpfs                              5.0M     0  5.0M   0% /run/lock
tmpfs                              391M   12K  391M   1% /run/user/1000
efivarfs                           256K   27K  230K  11% /sys/firmware/efi/efivars
/dev/vda2                          2.0G  190M  1.6G  11% /boot
/dev/vda1                          1.1G  6.4M  1.1G   1% /boot/efi

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마찬가지로 부모 네임스페이스에서 mount_test 를 언마운트해도 자식 네임스페이스에 영향을 끼치지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ sudo umount /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(이름이 umount 인 이유는 검색해보니 초기 유닉스 시스템에서는 명령어의 길이 제한을 6글자 이하로 하는 경우가 많았기 때문이라고 한다.)&lt;/p&gt;

&lt;p&gt;이처럼 mount namespace 를 활용하면 각 컨테이너마다 독립된 파일 시스템을 만들 수 있다. 이는 도커같은 컨테이너 기술에서 핵심 축을 담당하고 있다.&lt;/p&gt;

&lt;p&gt;심지어 루트 디렉토리도 리눅스 시스템이 부팅될 때, 커널이 루트 파일 시스템(/) 을 마운트하는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;chroot&quot;&gt;chroot&lt;/h1&gt;

&lt;p&gt;chroot 는 change root 의 약자로, 유닉스 운영 체제에서 현재 실행 중인 프로세스와 자식 프로세스 그룹에서 루트 디렉토리를 변경하는 작업이다.&lt;/p&gt;

&lt;p&gt;이렇게 루트 디렉토리가 변경된 환경에서 실행되는 프로그램은 지정된 디렉토리 트리 밖의 파일들의 이름을 지정할 수 없다.&lt;/p&gt;

&lt;p&gt;chroot 환경을 사용하려면, 커널 가상 파일 시스템과 구성 파일 또한 호스트에서 chroot 로 마운트 혹은 복사가 되어야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래와 같은 디렉토리 구조에서, chroot 를 통해 루트 디렉토리를 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;chroot 로 루트 디렉토리 변경&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;만약 왼쪽과 같은 구조에서 Nginx 를 실행시키면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;만약 아무런 설정도 하지 않았다면 당연히 환경변수에 따라 /usr/sbin/nginx, /usr/bin/nginx 등에서 nginx 실행 파일을 찾기 시작할 것이다. 여기서도 마찬가지로 /lib 를 찾지, /test/lib 를 찾지는 않는다. 따라서 환경 변수를 따로 지정해주어야 할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 우리가 컨테이너를 쓰는 이유는 하나의 nginx 를 모든 컨테이너에서 사용하기 위함이 아니라(물론 이런 경우도 있을수도 있지만 보통은), nginx 가 필요한 컨테이너만큼 새로운 nginx 를 설치하기 위함이지 않을까?&lt;/p&gt;

&lt;p&gt;각 컨테이너마다 nginx 의 설정도 다르게 하고 싶은 등의 이유로 nginx 를 컨테이너마다 다 넣어놨더니, 컨테이너의 루트 디렉토리가 호스트의 루트 디렉토리라서 실행을 할 수가 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 각 컨테이너마다 루트 디렉토리를 변경함으로써 오른쪽 그림의 형태로 바꾸어준다면 모든 컨테이너마다 각자 자신의 /etc/nginx 를 참조하면 각기 다른 Nginx 를 실행할 수 있지 않을까?&lt;/p&gt;

&lt;p&gt;따라서 위의 unshare 를 설명하면서 사용했던 옵선에, chroot 도 붙여보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
unshare --mount chroot test /bin/bash
# unshare --mount chroot {directory} /bin/bash

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;취약점&quot;&gt;취약점&lt;/h2&gt;

&lt;p&gt;chroot 는 루트 디렉토리를 바꿈으로써 독립적인 환경을 제공해줄 것 같지만, 사실 그렇지는 않다.&lt;/p&gt;

&lt;p&gt;눈에 보이는 루트 디렉토리를 변경해주는 일을 하지만, 호스트에서 동작하는 프로세스를 kill 하거나 디렉토리를 타고 올라가서 chroot 로 제한한 루트 디렉토리를 벗어나서 탐색할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
# chroot 내부에서 실행
mkdir /escape
mount --bind / /escape  # 호스트 루트 파일 시스템을 다시 마운트
ls /escape              # chroot 외부 파일 시스템에 접근 가능

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 취약점이 발생하는 이유는 chroot 가 root 경로와 현재 작업 경로를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상대경로&lt;/code&gt; 로 바꾸기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;pivot_root&quot;&gt;pivot_root&lt;/h1&gt;

&lt;p&gt;chroot 의 취약점을 개선하기 위해 pivot_root 를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;chroot 는 root 등을 상대경로로 바꾸었다면, pivot_root 는 기존의 루트 디렉토리를 백업해서 다른 경로로 바꿔버리고 원하는 디렉토리를 루트로 바꿔버린다.&lt;/p&gt;

&lt;p&gt;다시 말해서 루트 파일 시스템을 스왑한다.&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=CIvwIplZS1U&quot;&gt;https://www.youtube.com/watch?v=CIvwIplZS1U&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=OYM8OGKlufY&quot;&gt;https://www.youtube.com/watch?v=OYM8OGKlufY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;proc&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/docs/ko/aix/7.3?topic=files-proc-file&quot;&gt;https://www.ibm.com/docs/ko/aix/7.3?topic=files-proc-file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;chroot&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/Chroot&quot;&gt;https://ko.wikipedia.org/wiki/Chroot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;readlink&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man1/readlink.1.html&quot;&gt;https://man7.org/linux/man-pages/man1/readlink.1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Linux" /><summary type="html">도커 등의 컨테이너 기술을 사용하면서, 리눅스의 어떤 명령어들로 이런 컨테이너 기술이 동작할 수 있는지 문득 궁금해졌다.</summary></entry><entry><title type="html">상호 배타적 집합 (Union-Find)</title><link href="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)" rel="alternate" type="text/html" title="상호 배타적 집합 (Union-Find)" /><published>2025-01-26T07:18:00+00:00</published><updated>2025-01-26T07:18:00+00:00</updated><id>https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)</id><content type="html" xml:base="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)">&lt;p&gt;상호 배타적이라는 것은, 공통 원소가 없는 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 상호 배타적 집합이라는 것은 공통 원소가 없은 부분 집합으로 이루어진 집합이다.&lt;/p&gt;

&lt;p&gt;상호 배타적 집합을 Union-FInd 라고도 부르는 이유는, 이러한 집합을 만드는데 아래와 같은 Union, Find 과정을 수행하기 때문이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;처음 상태는 각각 자기 자신만을 포함한 집합을 생성한다. (초기화 단계)&lt;/li&gt;
  &lt;li&gt;이제 두 원소 a, b 가 주어질 때 이들이 속한 두 집합을 하나로 합친다. (Union 연산)&lt;/li&gt;
  &lt;li&gt;어떤 원소 a 가 주어질 때, 이 원소가 속한 집합을 찾는다. (Find 연산)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어 1부터 n 까지의 숫자 중에서 2로 나눈 나머지에 대해 상호 배타적 집합을 만든다고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;2로 나눈 나머지에 따른 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 트리 구조로 원소들을 묶으면서 하나의 부분 집합을 표현할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;union&quot;&gt;Union&lt;/h2&gt;

&lt;p&gt;Union 과정은 이처럼 두 개의 트리 구조를 하나로 합치는 과정을 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 왼쪽의 2로 나눈 나머지가 0인 트리가 합쳐지기 전을 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합 2, 6 이 아직 합쳐지지않은 상태&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;아직 2 와 6 이 같은 트리로 합쳐지지 않은 상황이다.&lt;/p&gt;

&lt;p&gt;여기서 우리는 2와 6은 짝수이기 때문에 같은 집합에 속한다는 것을 알고있다.&lt;/p&gt;

&lt;p&gt;따라서 Union 과정을 거쳐야하고 6의 부모 노드를 2로 지정함으로써 맨 처음의 그래프와 같이 하나의 트리 구조로 만들 수 있는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;find&quot;&gt;Find&lt;/h2&gt;

&lt;p&gt;기본적으로 Find 과정은 부모노드를 타고 올라가면서, 최종적으로는 해당 집합의 루트 노드를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;루트 노드가 집합을 대표하는 격이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 위의 트리에서 4와 12가 같은 집합에 속해있는지 어떻게 알 수 있을까?&lt;/p&gt;

&lt;p&gt;4와 12 각각 루트노드가 나올때까지 부모노드를 타고 올라가보면 된다.&lt;/p&gt;

&lt;p&gt;그렇게 더이상 올라갈 수 있는 노드가 없을 때, 즉 루트 노드까지 왔을 때 4의 루트노드와 12의 루트노드를 비교해보면 된다.&lt;/p&gt;

&lt;p&gt;여기서는 둘 다 루트노드가 2로 같기 때문에 같은 집합에 속하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;최적화를-하지-않은-구현&quot;&gt;최적화를 하지 않은 구현&lt;/h2&gt;

&lt;p&gt;우선 Find 연산에서 봤듯이, 부모 노드에 대한 정보가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;반대로 부모 노드에서 자식 노드로 내려갈 일은 없다.&lt;/p&gt;

&lt;p&gt;따라서 Union-FInd 자료구조를 구현하기 위해서는 부모 노드에 대한 정보를 저장할 수 있는 자료구조를 선택하면 된다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 고려하지 않은, 굉장히 간단한 UnionFind 를 한 번 구현해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size){
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
    }
    
    union(a, b){
        const root_a = this.find(a);
        const root_b = this.find(b);
        
        // 같은 집합에 속해있지 않을 경우
        // 최적화 없는 버전!
        if(root_a !== root_b) this.parent[root_b] = root_a;
    }
    
    find(node){
        // 경로 압축 최적화가 없는 버전!
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 find 메서드부터 개선점을 찾아보자.&lt;/p&gt;

&lt;h3 id=&quot;find-개선하기-경로-압축&quot;&gt;Find 개선하기 (경로 압축)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;초기화 단계&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우선 2,4,6,8,10,12,14 가 초기화 단계로, 각자 자기 자신을 가지고 있는 집합인 상황에서부터 시작해보자.&lt;/p&gt;

&lt;p&gt;여기서 별 생각 없이 2와 4를 Union 하면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;2와 4를 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 이번에 4와 6을 union 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;4 와 6을 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 보아하니 아마도 최종적으로 이런 트리가 생성될 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;일자로 쭉~&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 되면 루트 노드를 찾아야하는 find 연산의 특성 상, 트리의 레벨에 직접적으로 영향을 받을 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 find 를 최적화하기 위해서 트리의 레벨을 줄여야하니까, 이런 그래프가 가장 좋은게 아닐까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;레벨을 1로 최적화한 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 어느 노드에서 find 메서드를 실행해도 바로 루트 노드가 나오게 된다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 이런 식으로 최적화할 수 있을까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
   	// 경로 압축 최적화가 없는 버전!
    find(node){
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }

    // 경로 압축 최적화
    find(node){
        if(this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
            return this.parent[node];
        }
        return node
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;맨 처음부터 완벽하게 최적화된 트리를 얻을 수는 없다. 다만 find 를 한 번 하고나면 최적화되도록 구현할 수는 있다.&lt;/p&gt;

&lt;p&gt;경로 압축을 하지 않는 경우는 루트 노드를 찾으면 그대로 루트 노드를 반환했다.&lt;/p&gt;

&lt;p&gt;반면 경로 압축을 하는 경우에는 루트 노드를 찾았을 때, 루트 노드를 찾기 전까지 거쳐온 노드들의 부모 노드를 루트 노드로 갱신하는 과정이 있다.&lt;/p&gt;

&lt;h3 id=&quot;union-개선하기-union-by-rank&quot;&gt;Union 개선하기 (union by rank)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;레벨이 1, 2 인 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 두 트리를 union 시킨다고 해보자.&lt;/p&gt;

&lt;p&gt;먼저 왼쪽의 레벨2 트리에, 오른쪽 트리의 레벨 1을 합치면 아래와 같은 트리가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;레벨이 1인 트리를, 레벨이 2인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 경우에는 기존의 레벨이 2인 트리와 동일하게 레벨이 2로 유지됨을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이번에는 방향을 거꾸로 해서 합쳐보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;레벨이 2인 트리를, 레벨이 1인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기존의 레벨이 1인 트리의 레벨이 2로 늘어나는 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 트리의 레벨이 늘어나는것을 최소화하기 위해서는 레벨이 높은 트리에, 레벨이 낮은 트리를 합치는 것이 좋다.&lt;/p&gt;

&lt;p&gt;이런 방식을 랭크에 의한 합치기(union by rank) 라고 한다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 해보면,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;최적화를-한-구현union-by-rank-경로-압축&quot;&gt;최적화를 한 구현(union by rank, 경로 압축)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size) {
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
        this.rank = Array(size).fill(0); // 초기 랭크는 모두 0
    }

    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

    find(node) {
        if (this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
        }
        return this.parent[node];
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>[&quot;hoeeeeeh&quot;]</name></author><category term="[&quot;CS&quot;]" /><category term="[&quot;CS&quot;]" /><category term="CS" /><category term="Algorithm" /><summary type="html">상호 배타적이라는 것은, 공통 원소가 없는 것이다.</summary></entry></feed>