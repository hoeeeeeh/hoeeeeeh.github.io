<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hoeeeeeh.github.io/author/hoeeeeeh/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hoeeeeeh.github.io/" rel="alternate" type="text/html" />
  <updated>2025-02-21T16:57:36+00:00</updated>
  <id>https://hoeeeeeh.github.io/author/hoeeeeeh/feed.xml</id>

  
  
  

  
    <title type="html">hoeeeeeh | </title>
  

  
    <subtitle>HOEH 개발 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">네이버 부스트캠프 멤버십 최종 회고</title>
      <link href="https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0" rel="alternate" type="text/html" title="네이버 부스트캠프 멤버십 최종 회고" />
      <published>2025-02-21T07:40:00+00:00</published>
      <updated>2025-02-21T07:40:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EB%84%A4%EC%9D%B4%EB%B2%84_%EB%B6%80%EC%8A%A4%ED%8A%B8%EC%BA%A0%ED%94%84_%EB%A9%A4%EB%B2%84%EC%8B%AD_%EC%B5%9C%EC%A2%85_%ED%9A%8C%EA%B3%A0">&lt;p&gt;1차 문제 해결력 테스트(2024.06.15) → 베이직 → 챌린지 → 멤버십 학습스프린트 → 멤버십 그룹프로젝트(2024.12.06) 를 진행하면서의 기억&lt;/p&gt;

&lt;h1 id=&quot;회고를-할까-말까&quot;&gt;회고를 할까 말까..&lt;/h1&gt;

&lt;p&gt;멤버십이 12월 6일에 끝났고 리팩토링 기간 3주를 해도 회고를 작성하고 있는 지금(2월 21일)은 한두 달은 지난 시점으로 회고가 조금 늦었다. 사실 회고를 작성할까 말까 고민이 있었는데 6월부터 시작했으니 2024년 절반을 거의 네이버 부스트캠프 하나에만 집중해서 살았었다. 그래서 네이버 부스트캠프의 공식 일정이 마무리되었다는게 나에게 있어서는 꽤나 큰 이슈였고 대단원의 막이 내린듯한 느낌이 들었다. 하지만 사실은 네이버 부스트캠프가 마무리되었다고 내 인생이 갑작스러운 전환점을 맞이하는것도 아니고 이제 진짜 시작일 뿐이다. 그래서 네이버 부스트캠프가 끝나서 붕 뜬 느낌을 받기 보다 열심히 했던 것을 이어가고 싶었다.&lt;/p&gt;

&lt;p&gt;그런데 내 블로그를 한 번 씩 읽어보면서 베이직, 챌린지때의 회고에서 내가 어떤 경험을 했고 또 구현과 학습의 사이에서 고민했던 흔적을 볼 수 있었다. 특히 챌린지때는 매주 내가 다음주에 개선해보면 좋을 것들을 생각하고 적용해봤던 것 같은데 그때 당시에 느꼈던 생생한 감정들은 이제는 회고를 통해서만 느낄 수 있다.&lt;/p&gt;

&lt;p&gt;그래서 늦었지만 더 까먹기전에 전체적인 회고를 한 번 진행해보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;네이버-부스트캠프-9기-웹모바일-지원&quot;&gt;네이버 부스트캠프 9기 웹모바일 지원&lt;/h1&gt;

&lt;p&gt;대학교를 다니면서 하고 싶었던게 중구난방으로 많았던 것 같다. 안드로이드, IOS 개발자가 되고 싶었다가 또 어느샌가 졸업프로젝트를 하면서는 자동화에 관심이 생겼다. 그리고 취업시장에 딱 나가려니 나만의 강점이 무엇인지 갈피를 잡지 못했다. 그래서 일단은 선택의 폭이 가장 넓은 백엔드 개발자가 되는것을 목표로 삼았다. 백엔드 개발자라고 하면 범주가 되게 크다고 느꼈고 추후에 여러 가지의 길 중에서 하나를 선택할 수 있을 것 같았다. 그래서 거의 백엔드 개발자의 바이블로 여겨지는 자바 + 스프링을 하면서 준비를 해야하나? 하고 고민하던 차에 네이버 부스트캠프 웹모바일이 눈에 띄었고 그때 당시는 별 고민없이 안되면 말고! 하고 지원했던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;1차-문제-해결력-테스트&quot;&gt;1차 문제 해결력 테스트&lt;/h1&gt;

&lt;p&gt;여기서부터 고민이었던 것은 역시 언어와 프레임워크이다. 자바 + 스프링은 백엔드 취업에 있어서 안정적이고 굳이 벗어날 필요가 없는 길이었다. 지금이라도 자바스프링을 공부해야할 것 같은데 네부캠은 자바스크립트로, 그것도 풀스택 과정을 밟아야 했다.&lt;/p&gt;

&lt;p&gt;그래서 네이버 부스트캠프를 지원할 당시에는 네이버 부스트캠프를 통해서 node.js 개발자가 될 지, 아니면 그냥 자바 + 스프링을 공부해서 자프링 개발자가 될 지 선택해야하는 느낌을 받았다. 내가 어떤 일을 할 지도 모르는데 언어와 프레임워크로 나의 개발 라이프 사이클을 결정하고 있었다.&lt;/p&gt;

&lt;p&gt;그리고 결국, 그래도 한 번 들어보고 결정하자라는 가벼운 마음으로 지원을 하게 되었다.&lt;/p&gt;

&lt;p&gt;1차 문제 해결력 테스트는 아마 기억상으로는 언어 제한이 크게 없었던 것 같다. 그래서 평소 코딩테스트 준비하던 파이썬으로 응시를 했고 무난하게 풀었던 것 같다.&lt;/p&gt;

&lt;p&gt;이제부터 있을 모든 테스트는 JS로 언어 제한이 되면서 사실상 자바스크립트를 무조건 공부해야한다는 생각이 들었다.&lt;/p&gt;

&lt;h1 id=&quot;베이직-과정&quot;&gt;베이직 과정&lt;/h1&gt;

&lt;p&gt;베이직 과정에서, 그때 당시에는 문제 구현이 어렵지 않다고 생각했다. 지금 생각해보면 운영진분들의 의도를 내가 명확하게 캐치하지 못했던 것 같기도 하다. 문제가 주어지면 나 스스로 어떻게 문제를 정의하고 해결할지에 가장 방점을 두었어야 했던 것 같은데 구현하는데 급급하지 않았나 싶다.&lt;/p&gt;

&lt;p&gt;이때까지는 베이직이 아니라 그냥 네이버 부스트캠프 자체를 제대로 이해하지 못했던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;챌린지-과정&quot;&gt;챌린지 과정&lt;/h1&gt;

&lt;p&gt;베이직 과정을 거치고 챌린지에 들어선 순간 정말 분위기가 너무 달랐다. 일단 100퍼센트 구현한다는 것 자체가 너무 어려워보였고 구현을 하기 위해 학습도 필요했다. 다른 캠퍼들은 어떻게 구현했는지도 배우면서 또 적용도 하고 나만의 학습 방식을 찾아가는 등, 챌린지 과정은 정말 힘들었고 열심히 했고 많이 배웠다.&lt;/p&gt;

&lt;p&gt;이때 아마 작년 기수 선배님들이 오셔서 “챌린지 과정 같은 기간은 다시 오지 않을 기간이다” 라고 했던 것이 아직도 기억에 남는다. 정말로 다시 경험하기 힘들 과정이었지만 많은 걸 배웠다.&lt;/p&gt;

&lt;h1 id=&quot;멤버십-과정&quot;&gt;멤버십 과정&lt;/h1&gt;

&lt;p&gt;챌린지 과정은 따로 작성해둔 회고가 있어서 이제 본론인 멤버십 과정에 대해서 얘기해보려고 한다.&lt;/p&gt;

&lt;p&gt;멤버십 과정은 첫 오프라인 일정이 있기도 했고 마지막에는 그룹프로젝트가 있어서 기대 반, 걱정 반으로 임했던 것 같다.&lt;/p&gt;

&lt;p&gt;멤버십 과정을 전반적으로 요약하자면 자기 주도적인 문제 해결이었던 것 같다. 멤버십 과정도 모든 것을 100퍼센트 구현하는게 매우 어려웠다. 그래서 학습과 구현사이에서 고민하고 문제를 어떻게 해결할 것인지에 대한 고민을 많이 했었다.&lt;/p&gt;

&lt;p&gt;미션을 하면서 어떻게 하면 프론트엔드에서 State, View 의 흐름을 최대한 단순하게 만들 수 있을까? 라는 고민을 했고 Flux 패턴을 처음 사용했던 Facebook 의 레포지토리에 들어가서 소스 코드를 직접 읽어보며 이해했던 것이 기억에 남는다. 나는 백엔드 개발자로 가고 싶다는 생각을 하고 있었음에도 프론트엔드에서 자주 사용하는 Flux 패턴이 백엔드 아키텍처에서도 충분히 도움이 될 것 같았다. 이때부터 조금씩 개발의 경계선이 무너졌다? 라고 해야할까 언어나 분야가 안중요한 것은 아니지만 다양한 경험도 해보고 싶어졌었다.&lt;/p&gt;

&lt;p&gt;그룹 프로젝트를 진행하면서 영상 도메인을 1순위로 선택해서 팀 매칭을 했는데, 다시 생각해보면 좋은 선택이었던 것 같다. 기획 1주, 마지막 코드프리징 1주를 제외하면 약 4주 동안에 빠르게 개발을 진행해야 했었는데 모든 팀원이 다같이 영상 도메인에 대해서는 사전 지식이 없었다. 우리는 영상 도메인을 활용해서 어떤 주제, 어떤 프로토콜을 사용할지를 학습했고 이를 다같이 공유하며 초반 기획을 다졌다. 그리고 백로그와 주간 이터레이터를 토대로 빠르게 구현을 진행했고 부족했던 사전 지식은 부딪혀보며 점차 메꾸어나갔다. 이 과정에서 초반에 기획한 백로그의 상당수를 덜어내게 되었는데 다시 생각해도 말도 안되는 양의 백로그를 처음에 작성했던 것 같다. 최소 기능을 만들고 기능을 점차 늘려나가는 것에 대한 필요성을 생각해보게 되었던 경험이었다.&lt;/p&gt;

&lt;p&gt;어느정도 기능과 구조에 가닥이 잡힌 이후로는 다같이 구현을 하며 지속적으로 프로젝트의 방향성에 대한 이야기를 나누었던 것 같다.&lt;/p&gt;

&lt;p&gt;챌린지때는 머리 싸매며 새벽까지 학습하고 구현하는 것에 정말 열심이었고, 멤버십은 프로젝트에 욕심이 계속 나서 더 잘하고 싶다는 생각에 즐겁게 힘들 수 있었던 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;네이버-부스트-캠프&quot;&gt;네이버 부스트 캠프&lt;/h1&gt;

&lt;p&gt;네이버 부스트 캠프를 진행하면서 개발에 대한 생각이 많이 바뀌었다. 막 대학교를 마치고 나서는 자바 + 스프링을 배워서 빠르게 애플리케이션을 만들어보는 것에 집중하는게 맞다고 생각했었다. 지금은 어떤 언어, 어떤 프레임워크를 쓰든 간에 문제를 어떻게 정의하고 해결책에 근거를 가지는 것에 집중하고 있다. 그 과정에서 내가 선택한 기술이 어떤 원리로 돌아가는지까지 학습하는 것이 베스트인 것 같다.  원리를 알아야 응용이 가능하다.&lt;/p&gt;

&lt;p&gt;처음에 회고를 쓸지 말지 고민하던 이유가, ‘네이버 부스트캠프가 끝나면서 열심히 하던 습관을 잃어버릴까봐’ 였던 만큼 앞으로도 네부캠에서 했던 것을 기억하고 유지해나가고 싶다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Review" />
      

      
        <summary type="html">1차 문제 해결력 테스트(2024.06.15) → 베이직 → 챌린지 → 멤버십 학습스프린트 → 멤버십 그룹프로젝트(2024.12.06) 를 진행하면서의 기억</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">운영체제(페이징, 캐시, 자원 경쟁)</title>
      <link href="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)" rel="alternate" type="text/html" title="운영체제(페이징, 캐시, 자원 경쟁)" />
      <published>2025-02-04T04:41:00+00:00</published>
      <updated>2025-02-04T04:41:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)">&lt;h1 id=&quot;pcb-와-컨텍스트-스위칭&quot;&gt;PCB 와 컨텍스트 스위칭&lt;/h1&gt;

&lt;p&gt;PCB(Process Control Block) 은 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터 블록이며, 커널 스택에 저장된다.&lt;/p&gt;

&lt;p&gt;각 프로세스가 생성될 때 마다 고유의 PCB가 생성 되고, 프로세스가 종료되면 PCB 는 제거된다.&lt;/p&gt;

&lt;h2 id=&quot;유저-메모리-커널-메모리&quot;&gt;유저 메모리, 커널 메모리&lt;/h2&gt;

&lt;p&gt;가상메모리는 유저메모리와 커널 메모리로 나뉜다.&lt;/p&gt;

&lt;p&gt;유저 메모리와 커널 메모리는 전부 스택 영역을 사용하기 때문에 유저 스택, 커널 스택이라고 부르기도 한다.&lt;/p&gt;

&lt;p&gt;여기서 커널 모드일때만 사용할 수 있는 메모리를 커널 메모리(스택)이라고 한다.&lt;/p&gt;

&lt;p&gt;반대로 유저 모드일때만 사용할 수 있는 메모리는 유저 메모리(스택) 이라고 한다.&lt;/p&gt;

&lt;h1 id=&quot;pcb의-구조&quot;&gt;PCB의 구조&lt;/h1&gt;

&lt;p&gt;Process State : 대기중, 실행 중 등의 프로세스 상태를 나타낸다.&lt;/p&gt;

&lt;p&gt;Process Number : 각 프로세스의 고유 식별 번호&lt;/p&gt;

&lt;p&gt;Program Counter : 이 프로세스에 대해 실행될 다음 명령의 주소에 대한 포인터&lt;/p&gt;

&lt;p&gt;Registers : 레지스터 관련 정보&lt;/p&gt;

&lt;p&gt;Memory Limits : 프로세스의 메모리 관련 정보&lt;/p&gt;

&lt;p&gt;List of Open Files : 프로세스를 위해 열린 파일 목록들&lt;/p&gt;

&lt;h1 id=&quot;컨텍스트-스위칭&quot;&gt;컨텍스트 스위칭&lt;/h1&gt;

&lt;p&gt;앞서 설명한 PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정&lt;/p&gt;

&lt;p&gt;이는 프로세스가 종료되거나 인터럽트에 의해 발생된다.&lt;/p&gt;

&lt;h2 id=&quot;컨텍스트-스위칭의-비용&quot;&gt;컨텍스트 스위칭의 비용&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;유휴시간의 발생 : 컨텍스트 스위칭을 할 때 마다 유휴시간이 생겨서 CPU의 가용성이 떨어진다.&lt;/li&gt;
  &lt;li&gt;캐시 미스 : 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시 클리어 과정이 무조건 일어나게되고, 이 때문에 캐시 미스가 발생
페이지 테이블에 가상 주소가 실제 주소와 매칭 되어 있음. 그 위에 TLB 캐싱 계층이 있는데, 계속 컨텍스트 스위칭을 하면 캐시 미스가 발생하게 된다. 따라서 캐시를 계속 바꿔야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;프로세스의-상태&quot;&gt;프로세스의 상태&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;프로세스의 상태변화&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;create&quot;&gt;CREATE&lt;/h2&gt;

&lt;p&gt;프로세스가 생성된 상태&lt;/p&gt;

&lt;p&gt;fork, exec 시스템 콜 등을 통해 프로세스가 생성된 상태이며 PCB 가 할당된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fork : 부모 프로세스를 복제해서 자식 프로세스를 생성한다.&lt;/li&gt;
  &lt;li&gt;exec: 현재 프로세스의 메모리 공간에 새로운 실행 파일을 로드하여 기존 프로그램을 대체한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보통은 fork 로 자식 프로세스를 생성한 후에, exec 로 해당 프로그램을 대체하는 방식을 주로 쓴다.&lt;/p&gt;

&lt;p&gt;생성되고 나서는 대기(Ready) 상태로 간다.&lt;/p&gt;

&lt;h2 id=&quot;ready&quot;&gt;Ready&lt;/h2&gt;

&lt;p&gt;처음 프로세스가 생성된 이후, 메모리 공간이 충분하면 메모리를 할당받고 아니면 준비큐에 들어가서 대기중인 상태&lt;/p&gt;

&lt;p&gt;이는 CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다리는 상태&lt;/p&gt;

&lt;h2 id=&quot;ready-suspend&quot;&gt;Ready Suspend&lt;/h2&gt;

&lt;p&gt;Ready 큐가 꽉찬 상태라서, 메모리가 부족하기 때문에 Ready 상태가 아닌 Ready Suspend 가 된 상태&lt;/p&gt;

&lt;h2 id=&quot;running&quot;&gt;Running&lt;/h2&gt;

&lt;p&gt;실행 상태는 CPU 소유권과 메모리를 할당받고 명령어를 수행 중인 상태.&lt;/p&gt;

&lt;p&gt;CPU Burst 가 일어났다고도 표현한다.&lt;/p&gt;

&lt;h2 id=&quot;blocked&quot;&gt;Blocked&lt;/h2&gt;

&lt;p&gt;어떤 이벤트가 발생한 이후, 잠시 중단되어 프로세스가 차단된 상태&lt;/p&gt;

&lt;p&gt;예를 들어 프린트 인쇄 버튼을 눌렀을 때 프린트 인쇄 I/O 인터럽트에 의해, 현재 실행중이던 프로세스가 잠시 Blocked 상태로 들어갈 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;blocked-suspend&quot;&gt;Blocked Suspend&lt;/h2&gt;

&lt;p&gt;Blocked 된 상태에서 프로세스가 실행되려고 했지만, 레디 큐로 들어가지 못하고 메모리 부족으로 또 다시 중단된 상태&lt;/p&gt;

&lt;h2 id=&quot;terminated--exit&quot;&gt;Terminated / Exit&lt;/h2&gt;

&lt;p&gt;프로세스 실행이 완료되어 해당 프로세스에 대한 자원을 반납하고, PCB 가 삭제된 상태.&lt;/p&gt;

&lt;p&gt;부모 프로세스가 자식 프로세스를 강제로 종료시킨 경우도 있다.&lt;/p&gt;

&lt;h1 id=&quot;브라우저&quot;&gt;브라우저&lt;/h1&gt;

&lt;p&gt;멀티 프로세싱 + 멀티 스레딩&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/5237120&quot;&gt;https://d2.naver.com/helloworld/5237120&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티-프로세싱&quot;&gt;멀티 프로세싱&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;브라우저의 멀티 프로세싱&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;멀티-스레딩&quot;&gt;멀티 스레딩&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc&quot;&gt;IPC&lt;/h1&gt;

&lt;p&gt;Inter Process Communication 이란 프로세스끼리 데이터를 주고 받고 공유 데이터를 관리하는 매커니즘이다.&lt;/p&gt;

&lt;p&gt;IPC 의 종류로는 공유 메모리, 파일, 소켓, 파이프, 메시지 큐가 있다.&lt;/p&gt;

&lt;h2 id=&quot;공유-메모리&quot;&gt;공유 메모리&lt;/h2&gt;

&lt;p&gt;프로세스와 프로세스가 메모리를 공유해서 데이터를 주고 받는 방식&lt;/p&gt;

&lt;p&gt;메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르지만, 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 동기화가 필요&lt;/p&gt;

&lt;p&gt;IPC 중에서 가장 빠른 통신 방법.&lt;/p&gt;

&lt;h2 id=&quot;파일&quot;&gt;파일&lt;/h2&gt;

&lt;p&gt;디스크에 저장된 데이터를 기반으로 통신한다.&lt;/p&gt;

&lt;p&gt;요즘엔 잘 쓰이지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;파이프&quot;&gt;파이프&lt;/h2&gt;

&lt;p&gt;파이프는 통신을 위한 메모리 공간(버퍼)를 생성해서 프로세스 간 통신을 하는 방식이다.&lt;/p&gt;

&lt;h3 id=&quot;unnamed-pipe-익명-파이프&quot;&gt;(Unnamed Pipe) 익명 파이프&lt;/h3&gt;

&lt;p&gt;익명 파이프는 프로세스 사이에 FIFO 기반의 통신 채널을 만들어 통신하는 방식&lt;/p&gt;

&lt;p&gt;이름이 정해지지 않은, 즉 부를 수 없는 파이프라서 외부에서 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;단방향 통신이므로 양방향 통신을 하려면 2개의 익명 파이프가 필요&lt;/p&gt;

&lt;p&gt;부모, 자식 프로세스 간에서는 파일 디스크립션을 상속 받아서 사용할 수 있으며 다른 네트워크상에서는 사용이 불가능&lt;/p&gt;

&lt;p&gt;파이프의 데이터 용량은 제한되어 있으며 쓰기 프로세스가 읽기 프로세스보다 더 빠르게 데이터를 쓸 수는 없다&lt;/p&gt;

&lt;h3 id=&quot;named-pipe-명명-파이프&quot;&gt;Named Pipe (명명 파이프)&lt;/h3&gt;

&lt;p&gt;익명 파이프의 확장된 개념이며 부모, 자식 뿐만 아니라 다른 네트워크 상에서도 통신할 수 있는 파이프&lt;/p&gt;

&lt;p&gt;보통 서버, 클라이언트용 파이프를 구분해서 동작한다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;파이프 시나리오&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;메세지-큐&quot;&gt;메세지 큐&lt;/h2&gt;

&lt;p&gt;메세지 큐는 자료구조 형태로 관리하는 버퍼를 만들어 통신하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;매세지 큐의 동작 방식&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스가 메세지를 보내거나 받기 전에 메세지 큐를 초기화&lt;/li&gt;
  &lt;li&gt;Sender 의 메세지는 큐에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복사&lt;/code&gt;되어 Receiver 에 전달된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;자원-경쟁&quot;&gt;자원 경쟁&lt;/h1&gt;

&lt;h2 id=&quot;공유자원&quot;&gt;공유자원&lt;/h2&gt;

&lt;p&gt;공유자원이란 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태&quot;&gt;경쟁 상태&lt;/h2&gt;

&lt;p&gt;경쟁 상태(Race Condition)은 이 공유 자원을 둘 이상의 프로세스 또는 스레드가 동시에 읽거나 쓰는 상황을 말하며, 동시에 접근을 시도할 때 예상되는 결과값에 영향을 줄 수 있는 상태를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;임계-영역&quot;&gt;임계 영역&lt;/h2&gt;

&lt;p&gt;임계 영역(Critical Section) 은 둘 이상의 프로세스 또는 스레드가 공유 자원에 접근할 때, 순서 등의 이유로 결과가 달라지는 코드 영역을 의미한다.&lt;/p&gt;

&lt;p&gt;즉 경쟁 상태에 있는 영역&lt;/p&gt;

&lt;p&gt;이 영역은 한 번에 둘 이상의 프로세스나 스레드가 접근할 수 없도록 설계된다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁-상태-관리의-중요성&quot;&gt;경쟁 상태 관리의 중요성&lt;/h2&gt;

&lt;h3 id=&quot;데이터-정합성&quot;&gt;데이터 정합성&lt;/h3&gt;

&lt;p&gt;데이터 정합성(data consistency) 는 예상되는 데이터와 값이 같아야함을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;데이터-무결성&quot;&gt;데이터 무결성&lt;/h3&gt;

&lt;p&gt;데이터 무결성(data integrity) 는 데이터의 어떠한 규칙을 위반하지 않아야 함을 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 잔고가 음수가 될 수는 없다.&lt;/p&gt;

&lt;p&gt;또한 데이터가 전송, 저장되고 처리되는 모든 과정에서 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성을 말한다.&lt;/p&gt;

&lt;h1 id=&quot;경쟁-상태의-해결-조건&quot;&gt;경쟁 상태의 해결 조건&lt;/h1&gt;

&lt;p&gt;아래의 세 조건을 만족해야 경쟁 상태를 해결할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;상호-배제&quot;&gt;상호 배제&lt;/h2&gt;

&lt;p&gt;상호 배제(mutual exclusion) 은 한 프로세스가 임계 영역에 들어갔을 때, 다른 프로세스는 들어갈 수 없음을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;한정-대기&quot;&gt;한정 대기&lt;/h2&gt;

&lt;p&gt;한정 대기(bounded waiting) 은 특정 프로세스가 임계영역 진입을 요청한 후, 해당 요청이 승인되기 전까지 다른 프로세스가 임계영역에 진입하는 횟수를 제한하는 것을 말하며, 이를 통해 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 되는 것을 방지한다.&lt;/p&gt;

&lt;p&gt;(자원이 독점되지 않도록)&lt;/p&gt;

&lt;h2 id=&quot;진행의-융통성&quot;&gt;진행의 융통성&lt;/h2&gt;

&lt;p&gt;진행의 융통성(progress) 는 만약 어떠한 프로세스도 임계 영역을 사용하지 않는다면, 임계영역 외부의 어떠한 프로세스도 들어갈 수 있으며 이 때 프로세스끼리 서로 방해하지 않는 것을 의미한다.&lt;/p&gt;

&lt;h1 id=&quot;경쟁-상태의-해결-방법&quot;&gt;경쟁 상태의 해결 방법&lt;/h1&gt;

&lt;h2 id=&quot;뮤텍스&quot;&gt;뮤텍스&lt;/h2&gt;

&lt;p&gt;뮤텍스(mutex) 는 공유 자원을 lock() 을 통해 잠금 설정하고 사용한 후에, unlock() 을 통해 잠금해제한다.&lt;/p&gt;

&lt;p&gt;이러한 객체 Lock 을 기반으로 경쟁 상태를 해결하는데, 잠금 상태가 되면 다른 프로세스나 스레드는 해당 코드 영역에 접근할 수 없고, 해제되면 가능하다.&lt;/p&gt;

&lt;p&gt;한 번에 하나의 프로세스만 임계 영역에 있을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;세마포어&quot;&gt;세마포어&lt;/h2&gt;

&lt;p&gt;세마포어(semaphore) 는 일반화된 뮤텍스를 의미한다.&lt;/p&gt;

&lt;p&gt;정수 S, Wait(), Signal() 을 통해서 공유 자원에 대한 접근을 처리한다. 이를 통해 여러 프로세스가 동시에 임계 영역에 접근할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S : 현재 쓸 수 있는 공유 자원의 수&lt;/li&gt;
  &lt;li&gt;Wait() : S 를 1씩 감소 시킨다. 만약 S가 음수라면 공유 자원에 대한 접근은 못하고 블락된 채, 대기열로 들어간다.&lt;/li&gt;
  &lt;li&gt;Signal() : S 를 1씩 증가 시킨다. 프로세스가 공유 자원 사용을 마친 상태이고, S 가 0 이하라면 대기열에 있던 프로세스가 동작하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;바이너리-세마포어&quot;&gt;바이너리 세마포어&lt;/h3&gt;

&lt;p&gt;바이너리 세마포어는 0과 1 두 가지 값만 가질 수 있는 세마포어이다.&lt;/p&gt;

&lt;p&gt;구현의 유사성으로 인해 뮤텍스는 바이너리 세마포어와 유사하다고 할 수 있으나, 뮤텍스는 잠금을 기반으로 상호 배제가 일어나는 잠금 매커니즘이고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 매커니즘이다.&lt;/p&gt;

&lt;h3 id=&quot;카운팅-세마포어&quot;&gt;카운팅 세마포어&lt;/h3&gt;

&lt;p&gt;카운팅 세마포어는 S의 숫자가 1보다 큰, 세마포어를 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;모니터&quot;&gt;모니터&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;모니터&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체이다.&lt;/p&gt;

&lt;p&gt;이를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다.&lt;/p&gt;

&lt;h1 id=&quot;교착-상태&quot;&gt;교착 상태&lt;/h1&gt;

&lt;p&gt;교착상태(deadlock) 은 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말한다.&lt;/p&gt;

&lt;p&gt;각각의 프로세스는 서로가 원하는 자원을 유지한 채, 다른 프로세스의 자원을 얻기를 기다린다.&lt;/p&gt;

&lt;p&gt;교착상태가 발생하기 위한 4가지 필요조건은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상호 배제: 주어진 시간 내에 하나의 프로세스만 자원을 독점할 수 있다. 즉 다른 프로세스들은 접근이 불가능&lt;/li&gt;
  &lt;li&gt;점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하며 대기하는 상태&lt;/li&gt;
  &lt;li&gt;비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.&lt;/li&gt;
  &lt;li&gt;환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해결-방법-1-bankers-algorithm&quot;&gt;해결 방법 1. Banker’s Algorithm&lt;/h2&gt;

&lt;p&gt;교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당가능 여부를 파악하는 ‘은행원 알고리즘(banker’s algorithm)’&lt;/p&gt;

&lt;p&gt;은행원 알고리즘은 교착 상태를 회피하는 알고리즘으로, 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정, 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘&lt;/p&gt;

&lt;p&gt;안정 상태 : 교착 상태를 일으키지 않은 상태이며, 프로세스의 최대 자원 요구량을 운영체제가 충족시킬 수 있는 상태&lt;/p&gt;

&lt;p&gt;불안정 상태 : 안전 상태로 가는 순서열이 존재하지 않는 상태&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;은행원 알고리즘 예시1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;은행원 알고리즘 예시1&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;해결방법-2-3&quot;&gt;해결방법 2, 3&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지우기&lt;/li&gt;
  &lt;li&gt;해결 방법은 아니지만, 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 오히려 더 클 수도 있다. 따라서 교착 상태가 발생하면 사용자의 작업을 종료시켜버린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;cpu-스케줄링-알고리즘&quot;&gt;CPU 스케줄링 알고리즘&lt;/h1&gt;

&lt;p&gt;스케줄링 알고리즘에는 선점형(preemptive) 알고리즘과, 비선점(non-preemtive)형 알고리즘이 있다.&lt;/p&gt;

&lt;p&gt;중간에 인터럽트를 발생시켜서 강제적으로 컨텍스트 스위칭을 일으키는 것이 선점형알고리즘,&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 종료될 때 까지 대기하고 컨텍스트 스위칭을 일으키는 것이 비선점형 알고리즘이다.&lt;/p&gt;

&lt;h2 id=&quot;비선점형-알고리즘&quot;&gt;비선점형 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;fcfsfirst-come-first-saved&quot;&gt;FCFS(First Come, First Saved)&lt;/h3&gt;

&lt;p&gt;가장 먼저 온 것을 가장 먼저 처리하는 알고리즘&lt;/p&gt;

&lt;p&gt;길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상(convoy effect) 가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;FCFS 알고리즘 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;p1 → p2 → p3 → p4&lt;/p&gt;

&lt;p&gt;p1 이 버스트 타임이 길기 때문에 나머지가 오래 기다려야 한다.&lt;/p&gt;

&lt;h3 id=&quot;sjf-shortest-job-first&quot;&gt;SJF (Shortest Job First)&lt;/h3&gt;

&lt;p&gt;실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘.&lt;/p&gt;

&lt;p&gt;긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation) 이 일어날 수 있지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;평균 대기 시간이 가장 짧다&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;하지만 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행 정보를 토대로 추측해야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;실행시간이 매우 긴 프로세스가 있으면 레디큐에서 계속 대기할 확률이 매우 높다.&lt;/p&gt;

&lt;h3 id=&quot;우선-순위-알고리즘&quot;&gt;우선 순위 알고리즘&lt;/h3&gt;

&lt;p&gt;오래된 작업일수록 우선순위를 높이는 방법(aging) 을 통해 SJF 의 단점을 보완한 알고리즘&lt;/p&gt;

&lt;p&gt;우선순위는 작업의 시간, 프로세스의 메모리 요구사항, 열린 파일 수, 평균 CPU 사용량 등을 고려해서 설정&lt;/p&gt;

&lt;h2 id=&quot;선점형-알고리즘&quot;&gt;선점형 알고리즘&lt;/h2&gt;

&lt;p&gt;현대 운영체제가 쓰고 있는 방식으로, 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권을 할당할 수 있는 방식&lt;/p&gt;

&lt;h3 id=&quot;라운드-로빈-rr-round-robin&quot;&gt;라운드 로빈 (RR, Round Robin)&lt;/h3&gt;

&lt;p&gt;현재 컴퓨터가 쓰는 스케쥴링 방법이자 단순한 선점형 알고리즘&lt;/p&gt;

&lt;p&gt;각 프로세스에게 동일한 할당 시간을 주고, 그 시간 안에 끝나지 않으면 다시 준비 큐의 마지막으로 들어가는 알고리즘.&lt;/p&gt;

&lt;p&gt;그런데 동일한 할당 시간을 q 라고 할 때, q 를 너무 크게 주면 사실 상 들어온 순서대로 프로세스를 진행하는 FCFS 가 되어버린다. 따라서 q 를 적절히 조절할 수 있어야 한다.&lt;/p&gt;

&lt;p&gt;너무 작게 하면 컨텍스트 스위칭이 너무 많이 일어나면서 오버헤드가 과하게 생길 수 있다.&lt;/p&gt;

&lt;p&gt;일반적으로 전체 작업 시간은 길어지지만, 평균 응답 시간은 짧아진다는 특징이 있다.&lt;/p&gt;

&lt;h3 id=&quot;srfshortest-remaining-time-first&quot;&gt;SRF(Shortest Remaining Time First)&lt;/h3&gt;

&lt;p&gt;SRF 는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 즉시 중지하고 더 짧은 프로세스를 수행한다.&lt;/p&gt;

&lt;p&gt;SJF 는 비선점형이기 때문에 해당 프로세스가 끝나야 그 다음 제일 짧은 프로세스를 수행하는 것과의 차이가 있다.&lt;/p&gt;

&lt;h3 id=&quot;다단계-큐&quot;&gt;다단계 큐&lt;/h3&gt;

&lt;p&gt;우선순위에 따른 준비 큐를 여러 개 사용하고, 큐 마다 라운드 로빈이나 FCFS 등 다른 스케쥴링 알고리즘을 적용한 것을 말한다.&lt;/p&gt;

&lt;p&gt;큐 간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징이 있다.&lt;/p&gt;

&lt;p&gt;우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리 되지 않는 기아 현상(starvation) 이 발생할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;캐시&quot;&gt;캐시&lt;/h1&gt;

&lt;p&gt;데이터를 미리 복사해 놓는 임시 저장소이자, 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다. 이를 통해 데이터 접근 시간의 단축, 데이터를 다시 계산하는 등의 시간을 절약할 수 있다.&lt;/p&gt;

&lt;p&gt;캐시의 예로 CPU 레지스터를 들 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;캐시-설정-원리&quot;&gt;캐시 설정 원리&lt;/h2&gt;

&lt;p&gt;캐시를 설정할 때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자주 사용하는 데이터&lt;/code&gt; 를 기반으로 설정해야 한다.&lt;/p&gt;

&lt;p&gt;이 때 지역성을 기반으로 설정하게 되는데 지역성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시간 지역성&lt;/code&gt; 과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공간 지역성&lt;/code&gt; 으로 나뉜다.&lt;/p&gt;

&lt;h3 id=&quot;시간-지역성&quot;&gt;시간 지역성&lt;/h3&gt;

&lt;p&gt;시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성&lt;/p&gt;

&lt;h3 id=&quot;공간-지역성&quot;&gt;공간 지역성&lt;/h3&gt;

&lt;p&gt;공간 지역성은 최근 접근한 데이터를 이루고 이쓴ㄴ 공간이나 그 가까운 공간에 접근하는 특성&lt;/p&gt;

&lt;h2 id=&quot;캐시-매핑&quot;&gt;캐시 매핑&lt;/h2&gt;

&lt;p&gt;캐시의 크기는 메모리보다 항상 작기 때문에 효율적으로 매핑하는 것이 중요하며 매핑 방식에는 직접 매핑, 연관 매핑, 집합 - 연관 매핑이 있다.&lt;/p&gt;

&lt;h3 id=&quot;직접-매핑direct-mapping&quot;&gt;직접 매핑(direct mapping)&lt;/h3&gt;

&lt;p&gt;직접 블록별로 매핑을 한다.&lt;/p&gt;

&lt;p&gt;캐시가 다섯 블록이라면, 메모리를 5개의 영역으로 나누어서 각각의 영역당 하나의 캐시에 매핑 할 수 있도록 만든다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;특정 라인과 특정 블록이 매핑되어 있는 것&lt;/p&gt;

&lt;p&gt;메모리 블록의 사이즈는 메모리의 크기 / 캐시의 블록 개수&lt;/p&gt;

&lt;p&gt;운영체제는 보통 메모리를 똑같은 크기의 페이지(보통 4kb)&lt;/p&gt;

&lt;p&gt;4kb 인 이유? : &lt;a href=&quot;https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80&quot;&gt;https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;블록 당 영역이 정해져있기 때문에, 같은 블록에서 여러 개를 캐싱할 수 없다.&lt;/p&gt;

    &lt;p&gt;따라서 같은 블록의 참조가 빈번하다면 계속 캐시를 스와핑해주어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;대신 특정 정보의 캐시를 찾을 때 특정 블록만 찾으면 된다는 장점이 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연관-매핑associative-mapping&quot;&gt;연관 매핑(associative mapping)&lt;/h3&gt;

&lt;p&gt;순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하며 메모리의 컨텐츠가 캐시의 어느 위치에도 올라갈 수 있는 방법(자유롭게 캐싱)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특정 정보의 캐시를 찾을 때, 모든 캐시를 탐색해야한다.&lt;/li&gt;
  &lt;li&gt;그러나 스와핑이 빈번하게 일어나지는 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;집합-연관-매핑set-associate-mapping&quot;&gt;집합 연관 매핑(set associate mapping)&lt;/h2&gt;

&lt;p&gt;집합을 나누고(집합 매핑과 유사) 해당 집합에는 block descriptor 만 같으면 들어올 수 있게 하는데, 이 때 어떤 블럭에도 들어갈 수 있게 한다.(연관 매핑과 유사)&lt;/p&gt;

&lt;p&gt;즉 캐시의 집합을 나누었는데, 집합에 1개의 블록만 있다면 직접 매핑이고, 캐시 집합이 1개라면 연관 매핑인 것이다.&lt;/p&gt;

&lt;p&gt;이를 통해 모든 블럭을 찾을 필요 없이, 특정 블럭을 찾게 해 탐색 비용을 낮춘 직접매핑의 장점과 스와핑을 완화시키는 연관매핑의 장점을 모두 지니게 된다.&lt;/p&gt;

&lt;h1 id=&quot;메모리-할당&quot;&gt;메모리 할당&lt;/h1&gt;

&lt;p&gt;프로그램에 필요한 메모리를 할당할 때 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데 이는 연속할당과 불연속 할당으로 나뉜다.&lt;/p&gt;

&lt;h2 id=&quot;연속-할당&quot;&gt;연속 할당&lt;/h2&gt;

&lt;p&gt;메모리에 연속적으로 공간을 할당하는 것. 사용 가능한 모든 메모리 공간이 같은 위치에 있다.&lt;/p&gt;

&lt;p&gt;즉 메모리 파티션이 전체 메모리 공간에 분산되어 있지 않다.&lt;/p&gt;

&lt;p&gt;이는 고정분할방식과 가변분할방식이 있다.&lt;/p&gt;

&lt;h3 id=&quot;고정-분할-방식&quot;&gt;고정 분할 방식&lt;/h3&gt;

&lt;p&gt;고정분할방식은 메모리를 미리 같은 크기로 분할해서 할당하는 방법.&lt;/p&gt;

&lt;p&gt;고정 크기를 프로그램에 할당하므로, 프로그램의 크기보다 더 큰 메모리를 할당하게 된다.&lt;/p&gt;

&lt;p&gt;따라서 내부 단편화(internal framentation)가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;가변-분할-방식&quot;&gt;가변 분할 방식&lt;/h3&gt;

&lt;p&gt;가변분할방식은 프로그램에 필요한 만큼 동적으로 할당하는 방법.&lt;/p&gt;

&lt;p&gt;내부 단편화가 아닌 외부 단편화가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/13.png&quot; alt=&quot;13&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;가변 분할 방식에는 최초 적합, 최적 적합, 최악 적합이 있다.&lt;/p&gt;

&lt;p&gt;홀(hole) : 할당할 수 있는, 비어 있는 메모리 공간&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최초 적합(frist fit) : 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당&lt;/li&gt;
  &lt;li&gt;최적 적합(best fit) : 필요한 메모리 크기 이상인 공간 중에서 가장 작은 홀에 할당&lt;/li&gt;
  &lt;li&gt;최악 적합(worst fit) : 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불연속-할당&quot;&gt;불연속 할당&lt;/h2&gt;

&lt;p&gt;메모리를 연속적으로 할당하지 않는 방법으로, 현대 운영체제가 쓰는 방법.&lt;/p&gt;

&lt;p&gt;프로그램에 필요한 메모리를 쪼개어 서로 다른 위치에 있는 메모리 공간에 할당&lt;/p&gt;

&lt;p&gt;페이징, 세그멘테이션, 페이지드 세그멘테이션 기법이 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이징&quot;&gt;페이징&lt;/h3&gt;

&lt;p&gt;페이징은 동일한 크기의 페이지 단위(보통 4kb)로 나누어 메모리의 서로 다른 위치에 프로세스를 할당&lt;/p&gt;

&lt;p&gt;홀의 크기가 균일하지 않은 문제는 없어지지만 주소 변환을 페이지별로 해야 하기 때문에 주소 변환이 복잡해지는 단점이 있다.&lt;/p&gt;

&lt;p&gt;외부 단편화가 생겨도 분할해서 할당할 수 있기 때문에, 외부 단편화를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;그렇지만 결국 동일한 크기의 페이지 단위로 나눈다는 것은 언제나 내부 단편화를 유발할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;세그멘테이션&quot;&gt;세그멘테이션&lt;/h3&gt;

&lt;p&gt;페이지 단위가 아닌, 의미 단위인 세그먼트로 나누는 방식(즉, 동일한 크기가 아닐 수 있다.)&lt;/p&gt;

&lt;p&gt;프로세스는 코드, 데이터, 스택, 힙으로 나누어져서 메모리가 할당되는데 코드와 데이터, 또는 코드와 스택 등으로 나눌 수도 있으며 함수 단위로도 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;공유와 보안 측면에서 좋지만 홀 크기가 균일하지 않게 된다.&lt;/p&gt;

&lt;p&gt;내부 단편화는 해결될 수 있지만, 다시 외부 단편화가 일어날 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;페이지드-세그멘테이션&quot;&gt;페이지드 세그멘테이션&lt;/h3&gt;

&lt;p&gt;세그멘테이션으로 나누되, 해당 세그멘테이션을 동일한 크기의 페이지로 나누는 방법&lt;/p&gt;

&lt;p&gt;세그먼트에 의해 1kb, 5kb 로 나뉘었다면 이를 2kb 기준으로 나누어 2kb, (2kb, 2kb, 2kb) 로 나누는 방식&lt;/p&gt;

&lt;h1 id=&quot;busy-wait&quot;&gt;busy wait&lt;/h1&gt;

&lt;p&gt;busy wait 는 프로세스, 스레드가 어떠한 일을 실행하기 전에 만족하는 조건을 지속적으로 확인하는 동기화 기술이다.&lt;/p&gt;

&lt;p&gt;프로세스1이 점유하고 있는 자원을, 프로세스 2가 사용하고 싶을 때 blocking 되고 대기하는 과정이다.&lt;/p&gt;

&lt;h1 id=&quot;운영체제와-펌웨어의-차이&quot;&gt;운영체제와 펌웨어의 차이&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;펌웨어는 ROM 이라고 불리는 비휘발성 메모리 하나를 쓰는 반면, 운영체제는 휘발성 비휘발성 메모리를 계층화해서 사용한다.&lt;/li&gt;
  &lt;li&gt;펌웨어는 자유롭게 프로그램을 설치할 수 없으며, 미리 설치해놓은 프로그램을 기반으로 업데이트가 일어난다.
ROM 에 해당 소프트웨어를 지우고 덮어쓰면서 업데이트가 발생. → 멱등성처럼 변화를 최소화 하는 느낌인거 같다
반면, 운영체제는 정기적으로 업데이트 되며 프로그램을 자유롭게 설치할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="운영체제" />
      

      
        <summary type="html">PCB 와 컨텍스트 스위칭</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">백준 21939 문제 추천 시스템 Version 1</title>
      <link href="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1" rel="alternate" type="text/html" title="백준 21939 문제 추천 시스템 Version 1" />
      <published>2025-02-03T08:07:00+00:00</published>
      <updated>2025-02-03T08:07:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1">&lt;p&gt;&lt;img src=&quot;/upload/2025-02-03-백준_21939_문제_추천_시스템_Version_1.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;문제 추천 시스템 Version 1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;recommend(x) : x 가 1이면 난이도 가장 높은 문제를 우선순위 큐에서 출력, x 가 -1 이면 난이도가 가장 쉬운 문제를 출력.&lt;/p&gt;

    &lt;p&gt;→ 우선 순위큐를 minHeap, maxHeap 두 개를 써야겠다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;add(P, L) : 문제 번호가 P, 난이도가 L 인 문제를 추가&lt;/p&gt;

    &lt;p&gt;→ 2개의 우선순위 큐에 전부 넣어야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;solved(P) : 문제 번호가 P인 문제를 풀었다는 의미이므로, recommend 를 할 때 풀었던 문제는 추천하지 않도록 어딘가에 저장해두어야 함.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제는 우선순위 큐와 Map 혹은 Object 를 쓰면 쉽게 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;문제가 Solved 되면 Map 혹은 Object 에 기억해뒀다가, recommend 명령어에 의해서 문제를 추천할 때 Solved 된 문제라면 다음 Min (혹은 Max) Heap 에서 하나를 더 꺼내면 된다.&lt;/p&gt;

&lt;p&gt;그래서 문제 난이도가 그렇게 높게 잡히지는 않았는데 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javascript 에 우선순위 큐가 없다&lt;/code&gt;는 점이다.&lt;/p&gt;

&lt;p&gt;추가로 PriorityQueue 의 heap 을 일반 배열이 아닌 Queue 를 직접 구현했는데, 문제를 풀면서 heap 에 직접 shift 를 해야하는 경우가 필요하다고 착각했다.  dequeue 를 여러 번 하면 되는 일이었는데.&lt;/p&gt;

&lt;p&gt;자바스크립트는 배열의 shift 가 O(1) 이 아닌 O(n) 이다보니, shift 를 하려면 Queue 를 직접 구현해야해서 사용하면서도 일반 배열처럼 사용할 수 있는 방법을 고민하면서 풀었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Queue 에 배열처럼 index 만으로 접근하고 싶었는데 내가 만든 Queue 는 head 와 tail 로 이동하기 때문에 head 로 인덱스의 값을 보정해야했다.&lt;/p&gt;

&lt;p&gt;덕분에 모든 자료구조를 다 직접 짜면서 하다보니 코드가 엄청나게 길어졌다.&lt;/p&gt;

&lt;p&gt;아래는 삽질한 코드이다..&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Problem {
    constructor(num, level) {
        this.num = num;
        this.level = level;
    }
}

class PriorityQueue {
    heap = new Queue();

    constructor(comparator) {
        if(comparator) this.comparator = comparator.bind(this);
        else this.comparator = (a, b) =&amp;gt; this.heap.get(a) - this.heap.get(b);
    }

    enqueue(value){
        const heapLength = this.heap.push(value);
        this.bubbleUp(heapLength - 1);
    }

    peek(){
        return this.heap.get(0);
    }

    dequeue(){
        if(this.isEmpty()) return undefined;

        const root = this.heap.get(0);
        const leap = this.heap.pop();
        if(this.isEmpty()) return root;
        this.heap.set(0, leap);
        this.bubbleDown(0);

        return root;
    }

    bubbleUp(index_){
        let index = index_;
        while(index &amp;gt; 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if(this.comparator(index, parentIndex) &amp;gt;= 0) break;
            this.swap(index, parentIndex);
            index = parentIndex;
        }
        return index;
    }

    bubbleDown(index_){
        let index = index_;
        let smallestIndex = index;
        while(smallestIndex &amp;lt; this.heap.length){

            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;

            if(leftChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(leftChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = leftChildIndex;
            }
            if(rightChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(rightChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = rightChildIndex;
            }

            if(smallestIndex === index) break;
            this.swap(index, smallestIndex);
            index = smallestIndex;
        }
        return index;
    }

    isEmpty(){
        return this.heap.length === 0;
    }

    swap(i, j){
        const restore = this.heap.get(i);
        this.heap.set(i, this.heap.get(j));
        this.heap.set(j, restore);
    }
}

class Queue {
    items = {}
    head = 0;
    tail = 0;

    get length(){
        return this.tail - this.head;
    }

    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }

    constructor() {}

    push(value){
        this.items[this.tail] = value;
        this.tail += 1;
        return this.length;
    }

    pop(){
        if(this.isEmpty()) return undefined;
        const leaf = this.items[this.tail - 1];
        delete this.items[this.tail - 1];

        if(!this.isEmpty()) this.tail -= 1;
        return leaf;
    }

    isEmpty(){
        if(this.head !== this.tail) return false

        this.head = this.tail = 0;
        return true

    }
}

class ProblemPriorityQueue extends PriorityQueue {
    solvedProblems = {}
    constructor(comparator) {
        super(comparator);
    }
    solved(index){
        this.solvedProblems[index] = true;
    }

    peek(){
        this.removeSolvedProblem();
        return super.peek();
    }

    removeSolvedProblem(){
        let peek = super.peek();
        while(peek.num in this.solvedProblems){
            super.dequeue();
            delete this.solvedProblems[peek.num];
            peek = super.peek();
        }
    }
}

function minComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(a).level - this.heap.get(b).level;
    return this.heap.get(a).num - this.heap.get(b).num;
}

function maxComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(b).level - this.heap.get(a).level;
    return this.heap.get(b).num - this.heap.get(a).num;
}

function add(P, L){
    minPPQ.enqueue(new Problem(P, L));
    maxPPQ.enqueue(new Problem(P, L));
}

function solved(P) {
    minPPQ.solved(P);
    maxPPQ.solved(P);
}

function recommend(x){
    if(x === -1) {
        return minPPQ.peek().num;
    } else {
        return maxPPQ.peek().num;
    }
}

const readline = require(&quot;readline&quot;);
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let N = -1;
let M = -1;
let count = -1;
let answer = [];
const minPPQ = new ProblemPriorityQueue(minComparator);
const maxPPQ = new ProblemPriorityQueue(maxComparator);

rl.on(&quot;line&quot;, (line) =&amp;gt; {
    if(N === -1){
        N = parseInt(line);
        count = N;
    } else if (count &amp;gt; 0) {
        const [num, level] = line.split(&apos; &apos;).map((n) =&amp;gt; parseInt(n))
        add(num, level);
        count -= 1;
    } else {
        if(M === -1) M = parseInt(line);
        else {
            const [cmd, num1, num2] = line.split(&apos; &apos;);
            if (cmd === &apos;recommend&apos;) {
                const log = recommend(parseInt(num1));
                answer.push(log);
            } else if (cmd === &apos;solved&apos;) {
                solved(parseInt(num1));
            } else {
                add(parseInt(num1), parseInt(num2))
            }
        }
    }
}).on(&quot;close&quot;, () =&amp;gt; {
    console.log(answer.join(&apos;\n&apos;));
})


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      
        <category term="JavaScript" />
      

      
        <summary type="html">문제 추천 시스템 Version 1</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JS TS 로 Queue 구현</title>
      <link href="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84" rel="alternate" type="text/html" title="JS TS 로 Queue 구현" />
      <published>2025-01-31T07:42:00+00:00</published>
      <updated>2025-01-31T07:42:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84">&lt;h1 id=&quot;objector-map-을-활용한-queue&quot;&gt;Object(or Map) 을 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class ObjectQueue {
    item = {};
    start = 0;
    end = 0;

    constructor() {}

    enqueue(value){
        this.item[this.end] = value;
        this.end += 1;
        return this.end - 1;
    }
    
     // 큐가 비어 있을 때는 undefined, 그렇지 않은 경우 0 번째 원소를 반환
    dequeue(){
        if(this.isEmpty()) return undefined;
        const value = this.item[this.start];
        delete this.item[this.start];
        this.start += 1;
        return value;
    }

    isEmpty(){
        if(this.start === this.end) {
            this.start = 0;
            this.end = 0;
            return true;
        }
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Object 나 Map 을 활용해서 key-value 형식으로 저장한다.&lt;/p&gt;

&lt;p&gt;다만 Object, Map 이 사용하는 메모리가 다른 방법에 비해 많아, 메모리 효율은 다소 떨어질 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;linkedlist-를-활용한-queue&quot;&gt;LinkedList 를 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Node {
    value = null;
    next = null
    constructor(value) {
        this.value = value;
    }
}

class LinkedListQueue {
    front = null;
    rear = null;
    length = 0;

    enqueue(value){
        const newNode = new Node(value);
        // rear 가 null 인, 초기 상황일 때
        if(!this.rear) {
            this.front = this.rear = newNode;
        } else {
            // 현재 맨 마지막 노드의 다음 노드를 newNode 로 지정하고, newNode 를 마지막 노드로 지정
            this.rear.next = newNode;
            this.rear = newNode;
        }
        this.length += 1;
    }

    dequeue() {
        if(!this.front) {
            return undefined;
        }
        const value = this.front.value;
        this.front = this.front.next;

        // 하나를 dequeue 하고 Queue 에 아무것도 없을 때
        if(!this.front) {
            this.rear = null;
        }
        this.length -= 1;

        return value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;원형-큐&quot;&gt;원형 큐&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularQueue&amp;lt;T&amp;gt; {
    private readonly items: (T | null)[];
    private readonly capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueue(value: T) {
        if (this.isFull()) return false;
        this.items[this.rear] = value;

        // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 front 까지 다시 사용
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
        return true;
    }

    dequeue() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        
         // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 rear 까지 다시 사용
        this.front = (this.front + 1) % this.capacity; 
        this.size--;
        return value;
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐는 고정 사이즈를 정하고, 고정 사이즈만큼의 배열을 순환하면서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 만약 배열이 꽉 찼는데도 enqueue 가 일어나면 문제가 된다. 배열에 이미 값이 존재하는데 그 위에 덮어쓰게 되기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 원형큐가 가득 찼으면 배열을 그 순간에 늘리거나 해야한다.&lt;/p&gt;

&lt;p&gt;이 과정에서 기존 배열을 복사해야해서 시간이 많이 소요된다.&lt;/p&gt;

&lt;p&gt;이렇게 보면 원형큐는 dequeue 보다 enqueue 가 월등히 많은 경우, 썩 좋지 못할 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;원형-덱deque-double-ended-queue&quot;&gt;원형 덱(deque, Double Ended Queue)&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularDeque&amp;lt;T&amp;gt; {
    private items: (T | null)[];
    private capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueueFront(value: T) {
        if (this.isFull()) this.resize();
        this.front = (this.front - 1 + this.capacity) % this.capacity;
        this.items[this.front] = value;
        this.size++;
    }

    enqueueBack(value: T) {
        if (this.isFull()) this.resize();
        this.items[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
    }

    dequeueFront() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        return value as T;
    }

    dequeueBack() {
        if (this.isEmpty()) return undefined;
        this.rear = (this.rear - 1 + this.capacity) % this.capacity;
        const value = this.items[this.rear];
        this.items[this.rear] = null;
        this.size--;
        return value as T;
    }

    peekFront() {
        return this.isEmpty() ? undefined : (this.items[this.front]);
    }


    peekBack() {
        return this.isEmpty() ? undefined : (this.items[(this.rear - 1 + this.capacity) % this.capacity]);
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }

    getSize() {
        return this.size;
    }

    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐와 큰 차이는 없다.&lt;/p&gt;

&lt;p&gt;여기서 원형 큐나, 원형 데크나 resize 부분을 알아둬야한다.&lt;/p&gt;

&lt;h2 id=&quot;resize&quot;&gt;Resize&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;resize 부분을 보면 capacity 를 2배(혹은 원하는 만큼) 늘리고나서&lt;/p&gt;

&lt;p&gt;for 문 내부에서 아이템을 복제 및 정렬을 한다.&lt;/p&gt;

&lt;p&gt;언뜻 생각해보면 capacity 만 2배로 복제해도 되지 않을까 싶지만 기존 배열의 순서를 정렬해서 새로운 배열에 적용해야만 한다.&lt;/p&gt;

&lt;p&gt;예시를 들어서 살펴보면,&lt;/p&gt;

&lt;h3 id=&quot;기존-상태-1234-덱에-삽입&quot;&gt;기존 상태 (1,2,3,4 덱에 삽입)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 1  ] [ 2  ] [ 3  ] [ 4  ]  
Front → index 0
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-2-dequeue&quot;&gt;1, 2 dequeue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ X  ] [ X  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-6-enqueue&quot;&gt;5, 6 enqueue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 2 (가득 참)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-enqueue-resize-실행&quot;&gt;7 enqueue (Resize 실행)&lt;/h3&gt;

&lt;p&gt;단순히 Capacity 만 늘리는 경우(잘못된 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
	Index:      0      1      2      3      4      5      6      7
	Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ] [ X  ] [ X  ] [ X  ] [ X  ]
	Front → index 2
	Rear  → index 4
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3 → 4→ 5→ 6 순서가 아니라, 5 → 6 → 3→ 4 가 되어버린다.&lt;/p&gt;

&lt;p&gt;따라서 3,4,5,6 순서로 정렬시켜주는 과정이 필요&lt;/p&gt;

&lt;p&gt;resize 및 정렬 과정(올바른 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3      4      5      6      7
Items:    [ 3  ] [ 4  ] [ 5  ] [ 6  ] [ X  ] [ X  ] [ X  ] [ X  ]
Front → index 0
Rear  → index 4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      
        <category term="JavaScript" />
      
        <category term="TypeScript" />
      

      
        <summary type="html">Object(or Map) 을 활용한 Queue</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">리눅스 컨테이너</title>
      <link href="https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88" rel="alternate" type="text/html" title="리눅스 컨테이너" />
      <published>2025-01-27T03:16:00+00:00</published>
      <updated>2025-01-27T03:16:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88">&lt;p&gt;도커 등의 컨테이너 기술을 사용하면서, 리눅스의 어떤 명령어들로 이런 컨테이너 기술이 동작할 수 있는지 문득 궁금해졌다.&lt;/p&gt;

&lt;h1 id=&quot;linux-namespace&quot;&gt;Linux Namespace&lt;/h1&gt;

&lt;p&gt;리눅스 네임스페이스는 리눅스 커널에서 제공하는 기능으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스가 시스템의 특정 리소스를 독립적으로 볼 수 있도록 격리하는 매커니즘&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 개의 마운트 네임스페이스 A, B 를 생성했을 때, 각자의 작업이 서로에게 영향을 끼치지 않는다.&lt;/p&gt;

&lt;p&gt;따라서 A 네임스페이스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/test&lt;/code&gt; 를 만들었어도, B 네임스페이스에서는 /test 에 접근 할 수 없다.&lt;/p&gt;

&lt;h2 id=&quot;unshare&quot;&gt;unshare&lt;/h2&gt;

&lt;p&gt;마운트 네임스페이스를 직접 생성하려면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshare --mount {실행파일}&lt;/code&gt; 을 통해서 생성할 수 있다.&lt;/p&gt;

&lt;p&gt;이 명령어를 통해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshare&lt;/code&gt; 이라는 시스템콜이 {실행파일} 인자 (→ CLONE_NEWNS 파라미터)와 함께 사용된다.&lt;/p&gt;

&lt;p&gt;unshare 명령을 사용한 프로세스가 부모 프로세스가 되고, 자식 프로세스를 생성 할 때 마운트 네임스페이스를 생성하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 부모 프로세스가 가지고 있던 마운트 포인트가 자식 프로세스에게 그대로 복사가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;proc&quot;&gt;proc&lt;/h3&gt;

&lt;p&gt;마운트 네임스페이스를 직접 생성해보자.&lt;/p&gt;

&lt;p&gt;마운트 네임스페이스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 디렉토리에 존재한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;proc 디렉토리는 시스템의 프로세스 및 스레드에 대한 상태 정보를 포함한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;proc 파일 시스템은 시스템에 있는 각 활성 프로세스 및 스레드의 상태에 대한 액세스를 제공한다.&lt;/p&gt;

&lt;p&gt;proc 디렉토리 내부를 보게 되면 프로세스 아이디로 이루어진 폴더들과 여러가지 정보(cpuinfo, meminfo, devices…) 등이 있는걸 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;ls /proc&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;현재 사용하고 있는 Shell 의 프로세스 아이디를 찾아서 /proc 에서 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
echo $$

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 명령어를 통해 프로세스 아이디를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;이제 찾아낸 프로세스 아이디를 proc 에서 확인해보면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;ls /proc/{PID} 혹은 ls/proc/$$&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이런식으로 많은 것들이 들어있다.&lt;/p&gt;

&lt;p&gt;여기서 이 프로세스의 마운트 네임스페이스 번호를 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;프로세스의 마운트 네임스페이스&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc/$$/ns/mnt&lt;/code&gt; 로 프로세스의 마운트 네임스페이스를 확인할 수 있는데, 이는 symbolic link 라서 readlink 명령어를 통해서 symbolic link 의 값을 읽어보자.&lt;/p&gt;

&lt;h3 id=&quot;unshare-mount&quot;&gt;unshare —mount&lt;/h3&gt;

&lt;p&gt;4026531841 이 현재 프로세스의 pid 인걸 기억해두고 새로운 shell 창을 하나 더 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;shell 2개&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사진이 조금 이상해보일 수 있지만 쉘 창을 왼쪽과 오른쪽에 띄워놓은 상태이다.&lt;/p&gt;

&lt;p&gt;두 shell 창의 마운트 네임스페이스를 보면 같은 걸 알 수 있는데, 기본적으로 shell 창을 열든 ssh를 통해서 접속하든 새로운 마운트 네임스페이스를 만들지는 않는다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo unshare --mount /bin/sh&lt;/code&gt; 명령어를 통해서 오른쪽에 새로운 마운트 네임스페이스를 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;새로운 마운트 네임스페이스 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--mount&lt;/code&gt; 옵션을 주지 않으면, 새로운 마운트 네임스페이스를 만들지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;—mount 옵션 없이 unshare&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;왼쪽과 오른쪽 쉘의 mount namespace 가 같은 것을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;findmnt--a&quot;&gt;findmnt -A&lt;/h3&gt;

&lt;p&gt;다시 새로운 마운트 네임스페이스로 넘어와서, —mount 옵션을 주면서 새로운 마운트 네임스페이스를 생성하면 부모 네임스페이스로부터 마운트 포인트를 복사해서 자식 네임스페이스로 전달한다는 걸 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findmnt - A&lt;/code&gt; 옵션을 통해 마운트 포인트를 전부 확인할 수 있는데, 출력 순서가 조금 뒤바뀌었지만 값은 전부 동일하다.&lt;/p&gt;

&lt;h3 id=&quot;자식-네임스페이스와-부모-네임스페이스는-서로-영향을-미치지-않는다&quot;&gt;자식 네임스페이스와 부모 네임스페이스는 서로 영향을 미치지 않는다.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;부모 프로세스에서 마운트 포인트 만들기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 부모 마운트 네임스페이스에서 새롭게 마운트를 했을 때, 자식 마운트 네임스페이스에 영향을 미치는지 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
sudo mount -t tmpfs tmpfs /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 위의 명령어를 통해 새로운 마운트 포인트를 하나 만들어볼건데, /tmp/mount_test 라는 디렉토리에 tmpfs 타입을 마운트 한다.&lt;/p&gt;

&lt;p&gt;여기서 tmpfs 는 임시 파일 시스템을 의미하는데, RAM을 기반으로 하는 가상 파일 시스템이다.&lt;/p&gt;

&lt;p&gt;RAM 은 휘발되기 때문에 시스템을 종료하면 당연히 다 없어진다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 를 통해 마운트가 되었는지도 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;df 명령어는 disk free 의 약자로, 파일 시스템의 디스크 사용량을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;-h 옵션은 human-readable, 즉 사람이 읽기 쉽게 포매팅 해준다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ df -h
Filesystem                         Size  Used Avail Use% Mounted on
tmpfs                              391M  1.4M  389M   1% /run
efivarfs                           256K   27K  230K  11% /sys/firmware/efi/efivars
/dev/mapper/ubuntu--vg-ubuntu--lv   30G  7.9G   21G  28% /
tmpfs                              2.0G     0  2.0G   0% /dev/shm
tmpfs                              5.0M     0  5.0M   0% /run/lock
/dev/vda2                          2.0G  190M  1.6G  11% /boot
/dev/vda1                          1.1G  6.4M  1.1G   1% /boot/efi
tmpfs                              391M   12K  391M   1% /run/user/1000
tmpfs                              2.0G     0  2.0G   0% /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;findmnt -A&lt;/code&gt; 를 통해서도 확인해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ findmnt -A | grep /tmp/mount_test
└─/tmp/mount_test              tmpfs                             tmpfs       rw,relatime,inode64

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 부모 네임스페이스에서는 tmpfs 를 새롭게 마운트했는데, 자식 네임스페이스에서 이를 확인할 수 있는지 살펴보자.&lt;/p&gt;

&lt;p&gt;아래는 자식 네임스페이스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;df -h&lt;/code&gt; 를 한 결과이다.&lt;/p&gt;

&lt;p&gt;살펴보면 /tmp/mount_test 의 마운트 포인트는 없다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
# df -h
Filesystem                         Size  Used Avail Use% Mounted on
/dev/mapper/ubuntu--vg-ubuntu--lv   30G  7.9G   21G  28% /
tmpfs                              2.0G     0  2.0G   0% /dev/shm
tmpfs                              391M  1.4M  389M   1% /run
tmpfs                              5.0M     0  5.0M   0% /run/lock
tmpfs                              391M   12K  391M   1% /run/user/1000
efivarfs                           256K   27K  230K  11% /sys/firmware/efi/efivars
/dev/vda2                          2.0G  190M  1.6G  11% /boot
/dev/vda1                          1.1G  6.4M  1.1G   1% /boot/efi

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;마찬가지로 부모 네임스페이스에서 mount_test 를 언마운트해도 자식 네임스페이스에 영향을 끼치지 않는다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
hoeh@hoeeeeeh-server:/tmp$ sudo umount /tmp/mount_test

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(이름이 umount 인 이유는 검색해보니 초기 유닉스 시스템에서는 명령어의 길이 제한을 6글자 이하로 하는 경우가 많았기 때문이라고 한다.)&lt;/p&gt;

&lt;p&gt;이처럼 mount namespace 를 활용하면 각 컨테이너마다 독립된 파일 시스템을 만들 수 있다. 이는 도커같은 컨테이너 기술에서 핵심 축을 담당하고 있다.&lt;/p&gt;

&lt;p&gt;심지어 루트 디렉토리도 리눅스 시스템이 부팅될 때, 커널이 루트 파일 시스템(/) 을 마운트하는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;chroot&quot;&gt;chroot&lt;/h1&gt;

&lt;p&gt;chroot 는 change root 의 약자로, 유닉스 운영 체제에서 현재 실행 중인 프로세스와 자식 프로세스 그룹에서 루트 디렉토리를 변경하는 작업이다.&lt;/p&gt;

&lt;p&gt;이렇게 루트 디렉토리가 변경된 환경에서 실행되는 프로그램은 지정된 디렉토리 트리 밖의 파일들의 이름을 지정할 수 없다.&lt;/p&gt;

&lt;p&gt;chroot 환경을 사용하려면, 커널 가상 파일 시스템과 구성 파일 또한 호스트에서 chroot 로 마운트 혹은 복사가 되어야 한다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래와 같은 디렉토리 구조에서, chroot 를 통해 루트 디렉토리를 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-27-리눅스_컨테이너.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;chroot 로 루트 디렉토리 변경&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;만약 왼쪽과 같은 구조에서 Nginx 를 실행시키면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;만약 아무런 설정도 하지 않았다면 당연히 환경변수에 따라 /usr/sbin/nginx, /usr/bin/nginx 등에서 nginx 실행 파일을 찾기 시작할 것이다. 여기서도 마찬가지로 /lib 를 찾지, /test/lib 를 찾지는 않는다. 따라서 환경 변수를 따로 지정해주어야 할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 우리가 컨테이너를 쓰는 이유는 하나의 nginx 를 모든 컨테이너에서 사용하기 위함이 아니라(물론 이런 경우도 있을수도 있지만 보통은), nginx 가 필요한 컨테이너만큼 새로운 nginx 를 설치하기 위함이지 않을까?&lt;/p&gt;

&lt;p&gt;각 컨테이너마다 nginx 의 설정도 다르게 하고 싶은 등의 이유로 nginx 를 컨테이너마다 다 넣어놨더니, 컨테이너의 루트 디렉토리가 호스트의 루트 디렉토리라서 실행을 할 수가 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 각 컨테이너마다 루트 디렉토리를 변경함으로써 오른쪽 그림의 형태로 바꾸어준다면 모든 컨테이너마다 각자 자신의 /etc/nginx 를 참조하면 각기 다른 Nginx 를 실행할 수 있지 않을까?&lt;/p&gt;

&lt;p&gt;따라서 위의 unshare 를 설명하면서 사용했던 옵선에, chroot 도 붙여보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
unshare --mount chroot test /bin/bash
# unshare --mount chroot {directory} /bin/bash

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;취약점&quot;&gt;취약점&lt;/h2&gt;

&lt;p&gt;chroot 는 루트 디렉토리를 바꿈으로써 독립적인 환경을 제공해줄 것 같지만, 사실 그렇지는 않다.&lt;/p&gt;

&lt;p&gt;눈에 보이는 루트 디렉토리를 변경해주는 일을 하지만, 호스트에서 동작하는 프로세스를 kill 하거나 디렉토리를 타고 올라가서 chroot 로 제한한 루트 디렉토리를 벗어나서 탐색할 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash
# chroot 내부에서 실행
mkdir /escape
mount --bind / /escape  # 호스트 루트 파일 시스템을 다시 마운트
ls /escape              # chroot 외부 파일 시스템에 접근 가능

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 취약점이 발생하는 이유는 chroot 가 root 경로와 현재 작업 경로를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상대경로&lt;/code&gt; 로 바꾸기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;pivot_root&quot;&gt;pivot_root&lt;/h1&gt;

&lt;p&gt;chroot 의 취약점을 개선하기 위해 pivot_root 를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;chroot 는 root 등을 상대경로로 바꾸었다면, pivot_root 는 기존의 루트 디렉토리를 백업해서 다른 경로로 바꿔버리고 원하는 디렉토리를 루트로 바꿔버린다.&lt;/p&gt;

&lt;p&gt;다시 말해서 루트 파일 시스템을 스왑한다.&lt;/p&gt;

&lt;h1 id=&quot;참고-자료&quot;&gt;참고 자료&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=CIvwIplZS1U&quot;&gt;https://www.youtube.com/watch?v=CIvwIplZS1U&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=OYM8OGKlufY&quot;&gt;https://www.youtube.com/watch?v=OYM8OGKlufY&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;proc&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/docs/ko/aix/7.3?topic=files-proc-file&quot;&gt;https://www.ibm.com/docs/ko/aix/7.3?topic=files-proc-file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;chroot&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/Chroot&quot;&gt;https://ko.wikipedia.org/wiki/Chroot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;readlink&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man1/readlink.1.html&quot;&gt;https://man7.org/linux/man-pages/man1/readlink.1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Linux" />
      

      
        <summary type="html">도커 등의 컨테이너 기술을 사용하면서, 리눅스의 어떤 명령어들로 이런 컨테이너 기술이 동작할 수 있는지 문득 궁금해졌다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">상호 배타적 집합 (Union-Find)</title>
      <link href="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)" rel="alternate" type="text/html" title="상호 배타적 집합 (Union-Find)" />
      <published>2025-01-26T07:18:00+00:00</published>
      <updated>2025-01-26T07:18:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)">&lt;p&gt;상호 배타적이라는 것은, 공통 원소가 없는 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 상호 배타적 집합이라는 것은 공통 원소가 없은 부분 집합으로 이루어진 집합이다.&lt;/p&gt;

&lt;p&gt;상호 배타적 집합을 Union-FInd 라고도 부르는 이유는, 이러한 집합을 만드는데 아래와 같은 Union, Find 과정을 수행하기 때문이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;처음 상태는 각각 자기 자신만을 포함한 집합을 생성한다. (초기화 단계)&lt;/li&gt;
  &lt;li&gt;이제 두 원소 a, b 가 주어질 때 이들이 속한 두 집합을 하나로 합친다. (Union 연산)&lt;/li&gt;
  &lt;li&gt;어떤 원소 a 가 주어질 때, 이 원소가 속한 집합을 찾는다. (Find 연산)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어 1부터 n 까지의 숫자 중에서 2로 나눈 나머지에 대해 상호 배타적 집합을 만든다고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;2로 나눈 나머지에 따른 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 트리 구조로 원소들을 묶으면서 하나의 부분 집합을 표현할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;union&quot;&gt;Union&lt;/h2&gt;

&lt;p&gt;Union 과정은 이처럼 두 개의 트리 구조를 하나로 합치는 과정을 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 왼쪽의 2로 나눈 나머지가 0인 트리가 합쳐지기 전을 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합 2, 6 이 아직 합쳐지지않은 상태&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;아직 2 와 6 이 같은 트리로 합쳐지지 않은 상황이다.&lt;/p&gt;

&lt;p&gt;여기서 우리는 2와 6은 짝수이기 때문에 같은 집합에 속한다는 것을 알고있다.&lt;/p&gt;

&lt;p&gt;따라서 Union 과정을 거쳐야하고 6의 부모 노드를 2로 지정함으로써 맨 처음의 그래프와 같이 하나의 트리 구조로 만들 수 있는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;find&quot;&gt;Find&lt;/h2&gt;

&lt;p&gt;기본적으로 Find 과정은 부모노드를 타고 올라가면서, 최종적으로는 해당 집합의 루트 노드를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;루트 노드가 집합을 대표하는 격이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 위의 트리에서 4와 12가 같은 집합에 속해있는지 어떻게 알 수 있을까?&lt;/p&gt;

&lt;p&gt;4와 12 각각 루트노드가 나올때까지 부모노드를 타고 올라가보면 된다.&lt;/p&gt;

&lt;p&gt;그렇게 더이상 올라갈 수 있는 노드가 없을 때, 즉 루트 노드까지 왔을 때 4의 루트노드와 12의 루트노드를 비교해보면 된다.&lt;/p&gt;

&lt;p&gt;여기서는 둘 다 루트노드가 2로 같기 때문에 같은 집합에 속하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;최적화를-하지-않은-구현&quot;&gt;최적화를 하지 않은 구현&lt;/h2&gt;

&lt;p&gt;우선 Find 연산에서 봤듯이, 부모 노드에 대한 정보가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;반대로 부모 노드에서 자식 노드로 내려갈 일은 없다.&lt;/p&gt;

&lt;p&gt;따라서 Union-FInd 자료구조를 구현하기 위해서는 부모 노드에 대한 정보를 저장할 수 있는 자료구조를 선택하면 된다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 고려하지 않은, 굉장히 간단한 UnionFind 를 한 번 구현해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size){
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
    }
    
    union(a, b){
        const root_a = this.find(a);
        const root_b = this.find(b);
        
        // 같은 집합에 속해있지 않을 경우
        // 최적화 없는 버전!
        if(root_a !== root_b) this.parent[root_b] = root_a;
    }
    
    find(node){
        // 경로 압축 최적화가 없는 버전!
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 find 메서드부터 개선점을 찾아보자.&lt;/p&gt;

&lt;h3 id=&quot;find-개선하기-경로-압축&quot;&gt;Find 개선하기 (경로 압축)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;초기화 단계&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우선 2,4,6,8,10,12,14 가 초기화 단계로, 각자 자기 자신을 가지고 있는 집합인 상황에서부터 시작해보자.&lt;/p&gt;

&lt;p&gt;여기서 별 생각 없이 2와 4를 Union 하면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;2와 4를 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 이번에 4와 6을 union 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;4 와 6을 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 보아하니 아마도 최종적으로 이런 트리가 생성될 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;일자로 쭉~&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 되면 루트 노드를 찾아야하는 find 연산의 특성 상, 트리의 레벨에 직접적으로 영향을 받을 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 find 를 최적화하기 위해서 트리의 레벨을 줄여야하니까, 이런 그래프가 가장 좋은게 아닐까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;레벨을 1로 최적화한 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 어느 노드에서 find 메서드를 실행해도 바로 루트 노드가 나오게 된다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 이런 식으로 최적화할 수 있을까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
   	// 경로 압축 최적화가 없는 버전!
    find(node){
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }

    // 경로 압축 최적화
    find(node){
        if(this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
            return this.parent[node];
        }
        return node
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;맨 처음부터 완벽하게 최적화된 트리를 얻을 수는 없다. 다만 find 를 한 번 하고나면 최적화되도록 구현할 수는 있다.&lt;/p&gt;

&lt;p&gt;경로 압축을 하지 않는 경우는 루트 노드를 찾으면 그대로 루트 노드를 반환했다.&lt;/p&gt;

&lt;p&gt;반면 경로 압축을 하는 경우에는 루트 노드를 찾았을 때, 루트 노드를 찾기 전까지 거쳐온 노드들의 부모 노드를 루트 노드로 갱신하는 과정이 있다.&lt;/p&gt;

&lt;h3 id=&quot;union-개선하기-union-by-rank&quot;&gt;Union 개선하기 (union by rank)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;레벨이 1, 2 인 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 두 트리를 union 시킨다고 해보자.&lt;/p&gt;

&lt;p&gt;먼저 왼쪽의 레벨2 트리에, 오른쪽 트리의 레벨 1을 합치면 아래와 같은 트리가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;레벨이 1인 트리를, 레벨이 2인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 경우에는 기존의 레벨이 2인 트리와 동일하게 레벨이 2로 유지됨을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이번에는 방향을 거꾸로 해서 합쳐보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;레벨이 2인 트리를, 레벨이 1인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기존의 레벨이 1인 트리의 레벨이 2로 늘어나는 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 트리의 레벨이 늘어나는것을 최소화하기 위해서는 레벨이 높은 트리에, 레벨이 낮은 트리를 합치는 것이 좋다.&lt;/p&gt;

&lt;p&gt;이런 방식을 랭크에 의한 합치기(union by rank) 라고 한다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 해보면,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;최적화를-한-구현union-by-rank-경로-압축&quot;&gt;최적화를 한 구현(union by rank, 경로 압축)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size) {
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
        this.rank = Array(size).fill(0); // 초기 랭크는 모두 0
    }

    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

    find(node) {
        if (this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
        }
        return this.parent[node];
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">상호 배타적이라는 것은, 공통 원소가 없는 것이다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">스패닝 트리</title>
      <link href="https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC" rel="alternate" type="text/html" title="스패닝 트리" />
      <published>2025-01-20T02:16:00+00:00</published>
      <updated>2025-01-20T02:16:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC">&lt;h1 id=&quot;스패닝-트리&quot;&gt;스패닝 트리&lt;/h1&gt;

&lt;p&gt;어떤 무향 그래프의 스패닝 트리는 원래 그래프의 정점 전부와 간선의 부분 집합으로 구성된 부분 그래프이다.&lt;/p&gt;

&lt;p&gt;스패닝 트리에 포함된 간선들은 정점들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 형태로 전부 연결해야하는데, 이는 사이클이 없고 정점들이 꼭 부모-자식 관계로 연결될 필요는 없다는걸 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;예시 그래프&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 예시 그래프에서 스패닝 트리를 그려보자. 스패닝 트리는 유일하지 않을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/1.png&quot; alt=&quot;1&quot; /&gt;_올바른 스패닝 트리 1 _&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;올바른 스패닝 트리 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;스패닝 트리는 모든 정점이 연결되어 있거나, 사이클이 있으면 안된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;잘못된 스패닝 트리 1 (모든 정점이 연결되어 있지 않음)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;잘못된 스패닝 트리 2 (모든 정점이 연결되어 있지만 사이클이 존재)&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;최소-스패닝-트리&quot;&gt;최소 스패닝 트리&lt;/h1&gt;

&lt;p&gt;가중치가 있는 그래프에서, 스패닝 트리 중 가중치의 합이 가장 작은 트리를 최소 스패닝 트리라고 한다.&lt;/p&gt;

&lt;p&gt;최소 스패닝 트리를 찾는 알고리즘에는 크게 두 가지가 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;크루스칼&lt;/li&gt;
  &lt;li&gt;프림&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;간선이 하나도 없는 상태&lt;/code&gt; 에서 시작해 하나씩 트리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치가 가장 작은 간선&lt;/code&gt;을 추가해 가는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그리디 알고리즘&lt;/code&gt; 으로, 접근 방법이 달라보이지만 같은 방법으로 증명할 수 있다는 특징도 있다.&lt;/p&gt;

&lt;h2 id=&quot;크루스칼-알고리즘&quot;&gt;크루스칼 알고리즘&lt;/h2&gt;

&lt;p&gt;크루스칼의 기본적인 아이디어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치가 작은 간선이 최소 스패닝 트리에 포함될 가능성이 높다&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;그래서&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 간선의 가중치를 오름차순으로 정렬한다&lt;/li&gt;
  &lt;li&gt;가중치가 작은 순서대로 스패닝 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt;단, 스패닝 트리에 사이클이 생기지 않도록 한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 방식으로 모든 간선을 한 번씩 검사하고 나면 크루스칼 알고리즘은 종료된다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-동작-방식&quot;&gt;알고리즘 동작 방식&lt;/h3&gt;

&lt;p&gt;이제 예시를 들어, 한 번 직접 진행해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;크루스칼 알고리즘의 예시 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우선 가중치들을 정렬하면 [1, 2, 3, 4, 5, 6, 7, 9] 가 될 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가중치가 가장 작은 A - C (1) 을 선택해보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;처음 뽑는 간선이다보니 당연히 사이클은 그려지지 않을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;가중치가 1인 A - C 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;두 번째로 작은 E - F (2) 를 선택하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;가중치가 2인 E - F 산텍&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;마찬가지로, C - D (3) 과 A - B (4) 를 선택해보자&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;가중치가 3인 C - D, 가중치가 4인 A - B 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이제 남은 간선중에 가중치가 가장 작은 B - C (5) 를 선택하려고 보니, A - B - C 간의 사이클이 발생한다.
마찬가지로 그 다음 가중치가 작은 B - D (6) 을 선택하면 A - B - D -C 간의 사이클이 발생한다.&lt;/li&gt;
  &lt;li&gt;사이클이 생기지 않는 선에서 가장 작은 가중치를 갖는 D - F (7) 을 연결한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;가중치가 7인 D - F 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;C - E 도 마찬가지로 사이클이 생기기 때문에 선택하지 않는다.&lt;/li&gt;
  &lt;li&gt;모든 간선에 대해 검사를 완료했으므로 종료한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;사이클-검사-방법&quot;&gt;사이클 검사 방법&lt;/h3&gt;

&lt;p&gt;알고리즘 동작 방식을 봤을 때, 딱히 어려울 게 없어 보이는 단순한 방식으로 보인다.&lt;/p&gt;

&lt;p&gt;다만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사이클이 생기는지&lt;/code&gt; 확인하는 작업을 어떻게 하는지를 고민해봐야 할 것 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결국 스패닝 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 이므로 트리에 간선을 추가한 뒤에, 이 간선의 역방향 간선이 존재하는지를 DFS 로 탐색하면 어떨까?&lt;/p&gt;

&lt;p&gt;예를 들어 A - B (4) 를 스패닝 트리에 추가하고 모든 간선마다 DFS 를 수행한다.&lt;/p&gt;

&lt;p&gt;방문 기록을 저장해두면서 DFS 를 타고가다가, 이미 방문했던 곳을 방문한다면 사이클이 생긴 것이다.&lt;/p&gt;

&lt;p&gt;이 과정을 간선을 추가할 때 마다 진행하면 된다.&lt;/p&gt;

&lt;p&gt;이 방법은 구현하기에 매우 간단하겠지만 시간 복잡도를 생각해봤을 때, DFS 의 시간복잡도인 O(V+E) 에 E 를 곱한, O(E^2) 가 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Union-Find&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 정점을 잇는 간선에서, 이 간선이 사이클을 만들어내는지 확인하려면 두 정점이 같은 그룹에 있는지 확인하면 된다. 그리고 같은 그룹이 아니라면, 간선을 추가하면서 같은 그룹으로 만들어주는 작업을 반복하면 사이클 검사를 쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 자료구조를 만족하는 Union-Find 를 활용하면 쉽게 사이클을 검사할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;Union-Find 사이클 탐색 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 가중치가 1인 A - C 를 검사해보자.&lt;/p&gt;

&lt;p&gt;초기화단계에서는 A부터 F까지 어디에도 연결되지 않은 상태이므로, 당연히 자기 자신을 부모노드로 가진 채 초기화되어있을 것이다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 A 와 C 는 같은 집합에 존재하지 않기 때문에 사이클이 생기지 않는다고 확신할 수 있다.&lt;/p&gt;

&lt;p&gt;이후에 C 의 부모 노드를 A 로 바꾸면서 같은 집합으로 만들어준다.&lt;/p&gt;

&lt;p&gt;이어서 E - F (2) 도 Union 하고 나서 C - D(3) 를 보자.&lt;/p&gt;

&lt;p&gt;C 의 부모노드는 이미 A 이고, D 의 부모노드는 자신(D) 이다.&lt;/p&gt;

&lt;p&gt;둘이 같은 집합이 아니므로 D의 부모노드를 A로 바꾼다.&lt;/p&gt;

&lt;p&gt;A - B 도 마찬가지로, B의 부모노드가 A 로 바뀐다.&lt;/p&gt;

&lt;p&gt;이제 가중치가 5인 B - C 를 추가할지 말지 결정해야한다.&lt;/p&gt;

&lt;p&gt;B와 C의 루트노드를 살펴보니 전부 다 A 인 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 사이클이 생길 수 있는 간선이므로 추가하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h3&gt;

&lt;p&gt;Union-Find 연산은 현실적으로 매우 짧은 시간(상수 시간)으로 봐도 되기 때문에 실제 트리를 만드는 for 문의 시간 복잡도는 O(E) 라고 봐도 좋다.&lt;/p&gt;

&lt;p&gt;간선 리스트의 정렬에 걸리는 시간은 O(ElogE) 이기 때문에 O(ElogE) 가 전체 시간 복잡도가 된다.&lt;/p&gt;

&lt;h3 id=&quot;증명&quot;&gt;증명&lt;/h3&gt;

&lt;p&gt;크루스칼 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 간선을 그래프에 추가할 때, 뒤에 오는 간선들에 대한 고려는 전혀 하지 않으므로&lt;/code&gt; 탐욕적 알고리즘으로 분류할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;탐욕적 선택 속성은 우리가 내리는 탐욕적인 선택으로 인해 손해를 볼 일이 없음을 증명해야한다.&lt;/li&gt;
  &lt;li&gt;항상 최적의 선택만을 내려도 전체 문제의 최적해를 얻을 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 두 가지의 증명을 함으로서 크루스칼 알고리즘의 정당성을 증명할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가장 짧은 간선을 선택해도 손해를 볼 일이 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 증명은 귀류법으로 할 수 있다.&lt;/p&gt;

&lt;p&gt;크루스칼 알고리즘이 선택한 간선 루트가 올바르지 않다고 가정을 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;예시 그래프&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;크루스칼 알고리즘은 A → B → C → D → F → E 를 최선으로 골랐는데, 실제로는 A → B → C → E → F → D 였다고 가정해보자.&lt;/p&gt;

&lt;p&gt;크루스칼은 C - D 간선을 선택했지만 실제로는 C - D 간선이 아니라 C - E 간선을 선택해야 최소 스패닝 트리라는 것이다.&lt;/p&gt;

&lt;p&gt;크루스칼은 항상 가중치의 최솟값부터 선택해나간다. 따라서 C - D 의 가중치가 C - E 보다 작기 때문에 크루스칼 알고리즘이 C - D 를 선택했을 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 만약에 C - E 간선을 제거하고, C - D 간선을 연결하면 어떻게 될까? 이 또한 스패닝 트리가 되는 것을 알 수 있다. 따라서 가중치가 더 작은 간선을 선택해서 스패닝트리를 만들 수 있으므로, 처음의 A → B → C → E → F → D 가 최소 스패닝 트리라는 가정에서 모순 된다.&lt;/p&gt;

&lt;p&gt;일반화를 시키자면, 실제 최소 스패닝트리 T 에 속하지 않으면서 크루스칼 알고리즘이 선택한 간선을 (u, v) 라고 하자. T 또한 스패닝 트리이므로 u 와 v 는 어떤 식으로든 연결이 되어 있을 것이다. 크루스칼 알고리즘은 최솟값부터 선택해나가므로 T에는 존재하지만 크루스칼이 선택하지 않은 간선 (a, b) 는 (u, v) 보다 무조건 가중치가 같거나 높을 수 밖에 없다. (a, b) 가 (u, v) 보다 가중치가 낮았다면 크루스칼은 (u, v) 가 아니라 (a, b) 를 선택했을 것이다.&lt;/p&gt;

&lt;p&gt;이제 T 에서 u 와 v 를 잇는 경로 상의 어떠한 간선 하나를 제거하고, (u, v) 간선을 선택해보자. 이 때 간선 하나를 없앴지만 (u, v) 간선이 생겼으므로 스패닝 트리가 유지됨을 알 수 있고, 같거나 더 짧은 간선을 선택하면서 스패닝트리를 유지할 수 있으므로 T가 최소 스패닝 트리라는 가정에 모순이 생긴다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;항상 최적의 선택(남은 간선 중에, 사이클이 생기지 않는 가장 짧은 간선을 선택)만을 내려도 전체 문제의 최적해를 얻을 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이는, 매 단계마다 선택되는 간선이 항상 최적의 부분 문제 해를 만족한다는 점에서 최적 부분 구조가 성립함을 쉽게 알 수 있다.&lt;/p&gt;

&lt;p&gt;매 단계마다 선택하는 가장 짧은 간선은, 그 간선이 만드는 그래프 자체를 가장 짧은 경로로 갈 수 있게 한다. 따라서 항상 최적의 부분 문제 해를 만족하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;프림-알고리즘&quot;&gt;프림 알고리즘&lt;/h2&gt;

&lt;p&gt;크루스칼 알고리즘은 어느 간선이든 최솟값이면 선택하지만 프림 알고리즘은 현재 만들어진 트리에 이어진 간선만을 선택해나가면서 스패닝 트리를 만들게 된다.&lt;/p&gt;

&lt;p&gt;프림 알고리즘도 트리에 이어진 간선 중에서 최솟값을 선택하기 때문에 크루스칼 알고리즘과 비슷하기도 하다.&lt;/p&gt;

&lt;p&gt;그런데 이런 과정을 어딘가에서 많이 본 것 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점을 추가하면서, 정점에 연결된 간선 중에서 가장 짧은 간선을 선택해나가는 방식&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방식은 다익스트라 알고리즘과 상당히 유사해보인다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-동작-방식-1&quot;&gt;알고리즘 동작 방식&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;프림 알고리즘 예시 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프로 동작 방식을 한 번 살펴보자. 시작점은 A 라고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/13.png&quot; alt=&quot;13&quot; /&gt;&lt;em&gt;A - C 간선, 정점 C 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/14.png&quot; alt=&quot;14&quot; /&gt;&lt;em&gt;C - D 간선, 정점 D 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/15.png&quot; alt=&quot;15&quot; /&gt;&lt;em&gt;A - B 간선, 정점 B 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/16.png&quot; alt=&quot;16&quot; /&gt;&lt;em&gt;D - F 간선, 정점 F 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 왜, 더 짧은 간선인 B - C(5), B - D(6) 을 선택하지 않았냐면 이미 정점 리스트에 들어가있는 C 와 D 를 잇는 간선이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/17.png&quot; alt=&quot;17&quot; /&gt;&lt;em&gt;E - F 간선, 정점 E 추가&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;증명-1&quot;&gt;증명&lt;/h3&gt;

&lt;p&gt;프림 알고리즘은 크루스칼 알고리즘과 동일하게 간선의 최솟값을 사용하므로 증명이 크루스칼 알고리즘과 똑같다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">스패닝 트리</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)</title>
      <link href="https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)" rel="alternate" type="text/html" title="정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)" />
      <published>2025-01-16T02:20:00+00:00</published>
      <updated>2025-01-16T02:20:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)">&lt;p&gt;정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;다익스트라&quot;&gt;다익스트라&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;단일 시작점 최단 경로 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다익스트라 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;너비 우선 탐색과 유사&lt;/code&gt; 한 형태를 가진 알고리즘으로, 시작점에서 가까운 순서대로 정점을 방문한다. 다만 가중치(거리)가 있다보니 BFS 와 완전히 동일한 방식을 사용할 수는 없다.&lt;/p&gt;

&lt;h2 id=&quot;우선순위-큐&quot;&gt;우선순위 큐&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐&lt;/code&gt; 를 활용한다. 우선순위 큐에 대한 자바스크립트의 구현은 &lt;a href=&quot;/우선순위_큐&quot;&gt;여기&lt;/a&gt; 를 참고하면 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(정점의 번호, 정점까지의 거리)&lt;/code&gt; 를 우선순위 큐에 넣어서 정점까지의 거리를 기준으로 우선순위 큐를 사용한다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점에서 다른 정점까지의 거리를 저장하는 배열&lt;/code&gt; 에 저장하면 된다. (간단히 dist 라고 부르자)&lt;/p&gt;

&lt;p&gt;우선순위 큐에서 최단 경로의 정점을 하나씩 꺼내면서 해당 정점과 연결된 정점들을 우선순위 큐에 넣는 것을 반복한다.&lt;/p&gt;

&lt;p&gt;만약 v 에 아직 방문하지 않았고, 간선 (u, v) 를 검사한다고 하면 u 까지의 최단 거리에 간선 (u, v) 의 가중치를 더해서 v 까지의 거리를 구한다.&lt;/p&gt;

&lt;p&gt;만약 이 거리가 최단 거리라면 dist[v] 를 갱신하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(dist[v], v)&lt;/code&gt; 를 우선순위 큐에 다시 넣는다.&lt;/p&gt;

&lt;p&gt;여기서 주의해야할 것은 최단거리는 언제든지 갱신될 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;간선 (u, v) 를 탐색하면서 (dist[v], v) 를 우선순위 큐에 넣었는데 다른 정점을 돌면서 더 짧은 (dist[v], v) 를 우선순위 큐에 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 우선순위 큐에 (dist[v], v) 가 여러 개 생길 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- 8 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 그래프에서 시작점이 A 라고 하자.  시작점을 탐색하면서 (20, D) 가 우선순위 큐에 들어가게 될 것이다.&lt;/p&gt;

&lt;p&gt;그러나 A, B, E 를 탐색하면서 (10 + 2 + 5, D) 도 우선 순위 큐에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;이 경우에 (20, D) 는 우선순위 큐에서 pop 된다고 해도 무시되어야 한다.&lt;/p&gt;

&lt;p&gt;(20, D) 가 pop 되었다는 것은 이미 이전에 (17, D) 가 pop 되었다는 것이고 dist[D] 는 17 일 것이다.&lt;/p&gt;

&lt;p&gt;따라서 dist[D] 와의 비교를 통해서 더 짧은 경로가 이전에 이미 탐색되었는지를 확인하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;증명&quot;&gt;증명&lt;/h2&gt;

&lt;p&gt;다익스트라의 증명은 귀류법(어떤 명제가 참이라고 가정한 후, 모순을 이끌어내 그 가정이 거짓임을, 즉 처음의 명제가 거짓임을 증명하는 방법) 을 통해 가능하다.&lt;/p&gt;

&lt;p&gt;여기서는 다익스트라를 통해 최단거리를 구할 수 없다고 가정하고 모순을 이끌어내려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- ? ---- B
   |             |
   ?             ?
   |             |
   D ---- ? ---- E -- ? -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 위의 그래프를 활용해서 이야기해보자.&lt;/p&gt;

&lt;p&gt;시작점 A 부터 E 까지의 거리를 구하는 것이 목표이고, 실제로는 A - D - E 가 가장 짧다고 하자.&lt;/p&gt;

&lt;p&gt;여기서 다익스트라 알고리즘이 최단 거리를 제대로 구하지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;못한다&lt;/code&gt;고 가정하기 위해, 다익스트라 알고리즘이 A - B - E 가 가장 짧은 최단경로라는 결론을 내렸다고 가정해보자.&lt;/p&gt;

&lt;p&gt;도착점 E 에 도착한 순간, 어떤 정점은 이미 방문을 했을거고 또 어떤 정점은 우선순위 큐에 들어가 있는 상태일 수 있다.&lt;/p&gt;

&lt;p&gt;만약 D 를 방문하지 않은 상태라고 가정해보면, D 까지의 최단 거리는 dist[A] + w(A, D) 가 된다. 그런데 이미 방문한 정점 A 를 탐색하면서 D는 무조건 우선순위 큐에 (D, dist[A] + w(A, D)) 로 들어가게 되었을 것이다.&lt;/p&gt;

&lt;p&gt;A - B - E 로 진행하면서 E 또한 우선순위 큐에 들어가게 될텐데 여기서 이미 들어가있던 D 가 아닌 E 가 pop 되었다는것은 dist[E] 가 dist[D] 보다 작았기 때문이다.&lt;/p&gt;

&lt;p&gt;즉 dist[D] ≥ dist[E] 라는 소린데, 이는 D 를 거쳐서 A 에서 E 로 가는 것이 가장 짧은 경로라면 성립할 수가 없다.&lt;/p&gt;

&lt;h2 id=&quot;음수-가중치를-계산할-수-있는가&quot;&gt;음수 가중치를 계산할 수 있는가?&lt;/h2&gt;

&lt;p&gt;일반적으로 다익스트라 알고리즘은 음수 가중치가 있다면 정확한 최단 거리를 계산하지 못한다.&lt;/p&gt;

&lt;p&gt;음수 가중치가 있다는것은 이미 최단거리로 처리된 노드가 나중에 더 최단거리로 갱신될 가능성이 있다는 것이기 때문이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- -100 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다익스트라를 돌면서 E 의 최단 거리는 (10 + 2) 가 되겠지만 실제로는 10 + 2 - 100 이다.&lt;/p&gt;

&lt;p&gt;다시 말해서 이미 처리된 정점이 최단 거리라는 가정을 깨뜨릴 수 있다.&lt;/p&gt;

&lt;p&gt;만약 이미 처리된 정점이 최단 거리라는 가정을 버리고 (방문한 정점에 대한 기록을 하지 않고) 다익스트라를 작성한다면 음수 가중치를 계산할 수도 있다. 하지만, 이 경우에는 시간 복잡도가 정점의 갯수에 대해 지수함수로 증가할 수 있기 때문에 굳이 이런 식으로 다익스트라 알고리즘을 쓸 이유가 없다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;다익스트라의 시간 복잡도는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 정점마다 인접한 간선들은 모두 검사&lt;/code&gt; 하는 작업과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/code&gt; 하는 작업으로 나눌 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;각-정점마다-인접한-간선들을-모두-검사&quot;&gt;각 정점마다 인접한 간선들을 모두 검사&lt;/h3&gt;

&lt;p&gt;정점의 갯수를 E, 간선의 갯수를 V 라고 할 때,&lt;/p&gt;

&lt;p&gt;각 정점마다 인접한 간선들을 모두 검사하는 작업은 정확히 모든 간선을 1번씩 검사하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(E)&lt;/code&gt; 의 시간이 걸리게 된다.&lt;/p&gt;

&lt;h3 id=&quot;우선순위-큐에-원소를-넣고-삭제&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/h3&gt;

&lt;p&gt;우선순위 큐에 원소를 넣고 삭제하는 작업에서 최악의 경우에는 그래프의 모든 간선이 검사될 때마다 dist 배열이 갱신되면서 동시에 우선순위 큐에 정점의 번호가 추가되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/0.png&quot; alt=&quot;0&quot; /&gt;_다익스트라 최악의 경우 _&lt;/p&gt;

&lt;p&gt;위의 그래프에서 왼쪽의 핑크색 1번이 시작점이라고 하자.&lt;/p&gt;

&lt;p&gt;1번에서 2, 3, 4 까지의 dist 배열은 각각 6, 10, 15로 갱신되면서 우선순위 큐에 (2, 6), (10, 3), (15, 4) 로 들어갈 것이다.&lt;/p&gt;

&lt;p&gt;그러고 나서 2번 정점을 탐색하면서 dist[3] 은 6 + 3 으로 갱신되고, 우선순위 큐에 (9, 3) 이 추가 된다.&lt;/p&gt;

&lt;p&gt;이제 3번 정점을 탐색하면서 dist[4] 도 10 + 3 으로 갱신되고, 우선순위 큐에 (13, 4) 로 갱신 된다.&lt;/p&gt;

&lt;p&gt;이처럼 최악의 시나리오에서는 각 간선마다 한 번씩 추가가 되고, 우선순위 큐에 원소를 추가하거나 삭제하는데 O(logE)의 시간이 걸리고 이를 O(E) 개의 원소에 대해 작업을 해야하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(ElogE)&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;h3 id=&quot;일반적인-시간-복잡도&quot;&gt;일반적인 시간 복잡도&lt;/h3&gt;

&lt;p&gt;위의 두 과정을 더하게 되면 O(E + ElogE) = O(ElogE) 가 되는데, 보통 그래프에서 간선의 개수 E 는 V^2 보다 작기 때문에 O(logE) = O(logV) 라고 볼 수 있다. 따라서 O(ElogV) 라고 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘을 통해 최단 거리뿐만 아니라 최단 경로를 구하려면 정점에 도착하기 직전의 정점을 기록해서 역추적을 하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;벨만-포드&quot;&gt;벨만 포드&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘과 똑같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일&lt;/code&gt; 시작점 최단 경로 알고리즘이지만, 음수 가중치가 있는 그래프에서도 최단 경로를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;또한 음수 사이클이 있어서 최단 거리를 제대로 구하지 못하는 경우도 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;벨만포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;알고리즘-동작&quot;&gt;알고리즘 동작&lt;/h2&gt;

&lt;p&gt;시작점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;, 도착점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; , dist[k] = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점부터 k 까지의 최단 거리&lt;/code&gt; , w(u, v) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;= u와 v 사이의 간선 가중치&lt;/code&gt; 라고 하자. upper[k] 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재까지 계산된&lt;/code&gt;시작점부터 k 까지의 최단 거리이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 맨 처음에는 시작점부터 시작점사이의 거리가 0이라는 것을 제외하면, 아무것도 알고 있는 것이 없다. 따라서 upper[s] = 0 으로 초기화하고 나머지는 양의 무한대 혹은 매우 큰 수로 초기화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;완화&quot;&gt;완화&lt;/h3&gt;

&lt;p&gt;이제부터 우리는 upper 배열의 값을 점차 실제 최단 거리에 가깝도록 줄여나갈 것이다. 그러려면 최단 거리의 특성을 이용해야 하는데, 아래의 특성을 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;dist[v] ≤ dist[u] + w(u, v)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;dist[v] 는 v 까지 최단 거리인데, 만약 u를 거쳐서 v 로 오는 거리가 더 짧다면, u를 거쳐오는 거리가 최단 거리여야한다. 그렇기때문에 dist[v] 가 최단 거리라는 가정에 위배된다.&lt;/p&gt;

&lt;p&gt;이번에는 upper[u] + w(u, v) &amp;lt; upper[v] 인 상황을 생각해보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;upper[v] 를 upper[u] + w(u, v) 로 줄이려고 하는 것이 이번 과정의 목표이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;u 까지의 최단 거리는 항상 upper[u] 보다 작거나 같을 것이다.&lt;/p&gt;

&lt;p&gt;여기서 upper[u] + w(u, v) 는 u를 거쳐 v 로 가는 경로 이므로 만약 upper[u] + w(u, v) 가 upper[v] 보다 작다는 것은, u를 거쳐서 v 로 가는 것이 현재까지 계산된 v로 가는 최단 거리보다 짧다는 것이다.&lt;/p&gt;

&lt;p&gt;즉 upper[v] 를 upper[u] + w(u, v) 로 갱신할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완화&lt;/code&gt; 라고 하고 이를 계속 수행하면서 최단거리가 되도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;완화를-얼마나-해야하는가&quot;&gt;완화를 얼마나 해야하는가?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;최단거리는 결국, 어느 한 지점까지의 최단거리에서 간선을 더한 값으로 완화되어야 한다.&lt;/p&gt;

&lt;p&gt;무슨 이야기냐 하면 시작점 s 에서 연결된 정점 a 가 있다고 하자.&lt;/p&gt;

&lt;p&gt;모든 간선을 순회하면서 한 번씩 완화를 시도했다고 하자.&lt;/p&gt;

&lt;p&gt;이때 upper[a] 는 upper[s] + w(s, a) 로 완화될 수 있다. 그런데 upper[s] 는 시작점 s 부터 s 까지의 거리이므로 당연히 0이 된다.&lt;/p&gt;

&lt;p&gt;즉, upper[a] 는 w(s, a) 로 완화될 수 있다. w(s, a) 로 완화하고 나면, 시작점 s 부터 a 까지의 가는 경로중에 w(s, a) 보다 짧은 거리가 있을 수 있을까?&lt;/p&gt;

&lt;p&gt;없다. 위의 그래프에서 s 에서 b 로 가는 최단 거리가 s → b 말고 더 있을 수는 없다.&lt;/p&gt;

&lt;p&gt;여기서 만약 s → b → c → b 가 더 짧을 수도 있지 않을까 라는 생각이 들었다면 이는 음수 사이클이다. 이 경우에는 s→ b → c → b 보다 s → b → c → b → c → b 가 더 짧고 이를 무한반복하면 당연히 더 짧아진다.&lt;/p&gt;

&lt;p&gt;음수 사이클은 기본적으로 존재하는 순간 모든 그래프에서 최단 경로라는 말을 사용할 수가 없다.&lt;/p&gt;

&lt;p&gt;이는 조금 뒤에서 더 자세히 살펴보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 전체 간선에 대한 완화를 몇 번이나 수행해야 하는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그래프를 보면 전체 간선에 대한 완화를 1회 수행하면, a와 b 까지의 최단 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;2번 수행하면 c, 3번 수행하면 d 까지의 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 s → a → b → c → d 의 모양을 가진 그래프라면 어떨까?&lt;/p&gt;

&lt;p&gt;총 4회에 거쳐 a, b, c, d 까지의 최단 거리가 완화될 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서 정점의 갯수가 V 개 일때, 아무리 많이 해도 V - 1 번이면 모든 정점들까지의 거리가 최단 거리로 완화된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;음수-사이클&quot;&gt;음수 사이클&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프를 한 번 살펴보자. A → B → C 경로를 살펴보면 A → B 는 1 이 필요한데 B → C → A 는 가중치의 합이 -3 이다. A → B → C → A 는 결국 -2 의 가중치를 갖는다.&lt;/p&gt;

&lt;p&gt;어떠한 사이클이 합이 음의 가중치를 가지는 순간, 이 사이클을 무한 반복 함으로써 가중치의 합도 음의 무한대를 가지게 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서, 정점의 개수를 V 라고 할 때, 완화가 V - 1 번 이후에도 계속 이루어진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 보면 음수 사이클을 판별하는 방법은 쉽다.&lt;/p&gt;

&lt;p&gt;V - 1 번까지 완화를 진행하고 V 번째 완화를 시도해보면 된다. 만약 완화가 이루어졌다면 음수 사이클이 존재하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적-1&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;벨만 포드의 경로 추적은 다익스트라의 경로 추적과 유사하다. 다익스트라처럼 역추적을 하면 되는데,&lt;/p&gt;

&lt;p&gt;각 정점을 마지막으로 완화시킨 간선들을 토대로 역추적하면 된다. (이 간선들은 항상 최단경로의 위에 있기 때문)&lt;/p&gt;

&lt;h2 id=&quot;경로-존재-유무-판별하기&quot;&gt;경로 존재 유무 판별하기&lt;/h2&gt;

&lt;p&gt;시작점 s 에서 u 까지의 경로가 있는지 판별하는 방법은 쉽게 생각하면 upper[u] 가 Infinity 가 아니면 경로가 있다라고 착각할 수 있다.&lt;/p&gt;

&lt;p&gt;경로가 있으면 무조건 완화가 이루어질 것이라고 생각할 수 있기 때문이다. 하지만 음수 사이클이 있다면 이야기가 조금 달라진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위처럼 시작점 s 가 다른 정점들과 간선이 없다고 해도, a ↔ b 사이의 음수 사이클을 통한 완화가 이루어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 경로의 존재 유무를 판별하려면 upper[u] 가 Infinity 인지 아닌지로 판별하는 것이 아닌, 적당히 큰 값 M 에 대해서 upper[u] &amp;lt; Infinity - M 인지를 확인해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;적당히-큰-값-m&quot;&gt;적당히 큰 값 M..?&lt;/h3&gt;

&lt;p&gt;M 은 그러면 어떻게 결정할 수 있을까?&lt;/p&gt;

&lt;p&gt;우리는 위에서 완화를 최대 V - 1 번 진행한다고 했다. 그렇기 때문에 음수 사이클을 돌면서 완화된다고 했을 때, 한 번의 완화에 가장 많이 완화되는 값은 가장 작은 가중치값의 2배를 넘지 않을 것이다.&lt;/p&gt;

&lt;p&gt;위의 그래프에서는 한 번의 완화당 -1 씩 (-2 + 1) 작아진다.&lt;/p&gt;

&lt;p&gt;따라서 (가장 작은 가중치 * 2) * (V - 1) 로 M 을 설정하면 될 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도-1&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;벨만 포드 알고리즘은 모든 간선을 순회하는 작업을 정점의 갯수 - 1 번 만큼 진행한다. 음수 사이클을 판별하려면정점의 갯수만큼 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 O(E * V) 가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정점의 갯수 : V, 간선의 갯수 : E&lt;/p&gt;

&lt;h1 id=&quot;플로이드&quot;&gt;플로이드&lt;/h1&gt;

&lt;p&gt;다익스트라와 벨만 포드 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 시작점에서 다른 모든 정점까지의 거리&lt;/code&gt; 를 구하는 알고리즘이었다. 플로이드는 한 시작점이 아닌, 모든 정점에서 모든 정점까지의 거리를 구할 수 있는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;사실 플로이드를 굳이 안쓰고 모든 정점에서 한 번씩 다익스트라 알고리즘을 수행해도 구할 수 있다. 음수 가중치가 있다면 모든 정점에서 벨만 포드 알고리즘을 쓸 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 이런 방법보다는 더 빠르게 수행할 수 있는 알고리즘이 플로이드 와샬 알고리즘이다.&lt;/p&gt;

&lt;p&gt;플로이드 알고리즘은 생각보다 간단하다.&lt;/p&gt;

&lt;p&gt;정점 u 에서 v 까지의 거리를 dist[u][v] 라고 정했을 때 3중 for 문을 돌면서 u → ? → v 로 갔을 때, 거리가 갱신되는지 살펴보는 것이다.&lt;/p&gt;

&lt;p&gt;그런데 플로이드 알고리즘의 프로토타입을 글로 읽고 이해하려니 꽤나 많은 생각을 거쳐야 했다.&lt;/p&gt;

&lt;h2 id=&quot;프로토타입&quot;&gt;프로토타입&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 표현식은 a 에서 출발하여 c, d 를 거쳐 b 로 가는 경로이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 그래프에서 정점들의 집합을 S 라고 하고, 임의의 점을 x 라고 하자.&lt;/p&gt;

&lt;p&gt;a 에서 f 로 가는 경로에서 x 를 경유하는 것과, 경유하지 않은 것을 나누어 나타내면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기호가 너무 많아서 햇갈릴 수 있는데 a → f 의 경로는 x 를 경유해서 가는 것과 경유해서 가지 않는 것의 최소값이라는 의미일 뿐이다.&lt;/p&gt;

&lt;p&gt;여기서 이 점화식을 살짝 수정해서 더 보기 좋게 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 가지의 식을 활용해서 위의 식을 바꾸면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 된다.&lt;/p&gt;

&lt;p&gt;이제서야 우리가 자주 보던 점화식같이 생겼다.&lt;/p&gt;

&lt;p&gt;여기서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 식의 차이점에 대해서 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 식은 k 를 거치지 않고 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;반대로 위의 식은 k 까지 거쳐서 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;그런데 k 까지 가는데 k 를 거치든 안거치든 그게 다를 수 있나?&lt;/p&gt;

&lt;p&gt;도착점이 k 이므로 k를 거치는것과 안거치는것은 당연히 같다.&lt;/p&gt;

&lt;p&gt;따라서 위의 식이 같다라고 생각하게 되면 식은 더욱 간단해진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 우리가 알던 플로이드 알고리즘인, 경유점 하나를 거쳐서 가는것과 안거쳐서 가는 것 중에서 더 짧은 것을 선택하는 식이 된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">네트워크 CS 지식</title>
      <link href="https://hoeeeeeh.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_CS_%EC%A7%80%EC%8B%9D" rel="alternate" type="text/html" title="네트워크 CS 지식" />
      <published>2025-01-15T12:26:00+00:00</published>
      <updated>2025-01-15T12:26:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_CS_%EC%A7%80%EC%8B%9D</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC_CS_%EC%A7%80%EC%8B%9D">&lt;p&gt;네트워크 CS 지식 정리&lt;/p&gt;

&lt;h1 id=&quot;전이중화-통신&quot;&gt;전이중화 통신&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Full Duplex : 양쪽 장치가 동시에 송수신할 수 있는 방식&lt;/li&gt;
  &lt;li&gt;회선이 두 개(송신로, 수신로)가 있어서 같은 시간에 데이터를 주고 받을 수 있는 것이 전이중화 통신&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;반 이중화 통신은 회선 하나로 보내기 때문에 양방향으로 보내기 전에 먼저 상대방이 보냈는지 확인하는 기술 CSMA-CD&lt;/p&gt;

&lt;p&gt;충돌이 발생하면 잠깐 기다렸다가 다시 보내기&lt;/p&gt;

&lt;h1 id=&quot;무선랜&quot;&gt;무선랜&lt;/h1&gt;

&lt;p&gt;무선랜은 반이중화 통신을 사용&lt;/p&gt;

&lt;p&gt;half duplex (반이중화 통신)은 양쪽 장치가 서로 통신은 할 수 있지만 동시에는 못한다. 즉 한 번에 한 방향만 가능&lt;/p&gt;

&lt;p&gt;CSMA/CA&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용하지 않는 채널 발견&lt;/li&gt;
  &lt;li&gt;IFS 시간만큼 기다림&lt;/li&gt;
  &lt;li&gt;프레임 보내고, 다음 프레임 보내기 전까지 IFS 만큼 기다림&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대표적인 예시) 와이파이, 블루투스, 지그비&lt;/p&gt;

&lt;p&gt;2.4Ghz : 장애물에 강함, 속도가 느리다, 호환성이 좋다&lt;/p&gt;

&lt;p&gt;5Ghz : 장애물에 약함, 속도가 빠르다, 호환성이 비교적 나쁘다&lt;/p&gt;

&lt;h1 id=&quot;대규모-트래픽으로-인한-서버-과부하-해결-방법&quot;&gt;대규모 트래픽으로 인한 서버 과부하 해결 방법&lt;/h1&gt;

&lt;p&gt;서버 과부하 : 서버가 리소스를 소진하여 들어오는 요청을 처리하지 못할 때. (응답없음)&lt;/p&gt;

&lt;p&gt;자원의 한계점 도달&lt;/p&gt;

&lt;p&gt;→ 자원을 빠르게 증가시켜주기 (오토 스케일링) 클라우드 와치가 모니터링한다.&lt;/p&gt;

&lt;p&gt;→ 무료 모니터링 (netData) 도 있다.&lt;/p&gt;

&lt;p&gt;→ 쓰레스 홀드(임계치)를 정해놓고 이상으로 넘어가면 알림을 준다.&lt;/p&gt;

&lt;h2 id=&quot;모니터링을-하는-이유&quot;&gt;모니터링을 하는 이유&lt;/h2&gt;

&lt;p&gt;모니터링을 통해 어떤 서비스에 트래픽이 몰리는지, 어떤 이유로 몰리는지 분석이 가능하다.&lt;/p&gt;

&lt;p&gt;또한 페이지를 나누어 트래픽을 나눌 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;로드밸런서&quot;&gt;로드밸런서&lt;/h2&gt;

&lt;p&gt;로드밸런서를 통해서 트래픽을 분산&lt;/p&gt;

&lt;p&gt;오토 스케일링을 하는 동안 시간이 조금 걸리기 때문에, 로드 밸런스를 앞 단에 두고 트래픽을 분산 시킨다.&lt;/p&gt;

&lt;p&gt;로드 밸런서에다가도 오토 스케일링을 걸기도 한다. (트래픽이 많은 기업)&lt;/p&gt;

&lt;h2 id=&quot;블랙스완-프로토콜&quot;&gt;블랙스완 프로토콜&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;예측할 수 없는 사고가 일어난 것&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;엄청나게 많은 대비를 해도 서버가 죽을 수도 있다. 서버가 예기치 못한 사태로 죽고나서 분석은 가능하지만 미리 예측하기는 쉽지 않다.&lt;/p&gt;

&lt;p&gt;블랙스완을 대비한 규칙이 있으면 좋다.&lt;/p&gt;

&lt;p&gt;구글의 경우에는,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;영향을 받은 시스템과 각 시스템의 상대적 위험 수준을 확인&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ 체계적으로 데이터를 수집하고 원인에 대한 가설을 수립한 후 이를 테스팅&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;잠재적으로 영향을 받을 수 있는 내부의 모든 팀에 연락&lt;/li&gt;
  &lt;li&gt;최대한 빨리 취약점에 영향을 받는 모든 시스템을 업데이트&lt;/li&gt;
  &lt;li&gt;복원계획을 포함한 우리의 대응 과정을 파트너와 고객 등 외부에 전달&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;서킷-브레이커&quot;&gt;서킷 브레이커&lt;/h2&gt;

&lt;p&gt;서비스 장애를 감지하고 연쇄적으로 생기는 에러를 방지하는 기법&lt;/p&gt;

&lt;p&gt;서비스와 서비스 사이에 서킷브레이커 계층을 두고, 미리 설정해놓은 타임아웃 임계값을 넘어가면 서킷브레이커가 그 이후의 추가 호출에 무조건 에러를 반환하게 한다.&lt;/p&gt;

&lt;p&gt;다운된 서비스에 무한정 대기하면서 스레드 혹은 리소스를 잡아먹게 되면서 다른 스레드가 차단되는 현상이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기다린다&lt;/code&gt;는 것은 사용자 입장에서 썩 좋은 경험은 아니다.&lt;/p&gt;

&lt;p&gt;기다리는것보다 차라리 오류가 생겼다고 말해주는 것이 더 좋은 경험이다.&lt;/p&gt;

&lt;p&gt;따라서 빠르게 알려줄 수 있는 서킷 브레이커가 더 좋을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;서킷-브레이커의-상태&quot;&gt;서킷 브레이커의 상태&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;closed (정상) : 네트워크 요청의 실패율이 임계치보다 낮음
    &lt;ul&gt;
      &lt;li&gt;어느정도는 실패할 수 있다. 100퍼센트가 아니라 90퍼이상 성공하면 괜찮다같이 정할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;open (에러) : 에러가 임계치 이상의 상태일 때.
    &lt;ul&gt;
      &lt;li&gt;요청을 서비스로 전송하지 않고 에러를 반환. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fail test&lt;/code&gt; 라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;half open (확인 중) : 오픈 상태에서 일정 타임 아웃으로 설정된 시간이 지나면 장애가 해결되었는지 확인하기 위한 상태. 장애가 풀리면 closed 상태로, 실패하면 다시 open 상태로 전환&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;서킷-브레이커의-장점&quot;&gt;서킷 브레이커의 장점&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;연쇄적인 에러 발생을 막아준다&lt;/li&gt;
  &lt;li&gt;일부 서비스가 다운되더라도 다른 서비스를 정상적으로 돌아가게 도와준다.&lt;/li&gt;
  &lt;li&gt;사용자 경험을 높여준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Netfilix 의 Hystrix&lt;/p&gt;

&lt;h2 id=&quot;컨텐츠-관리&quot;&gt;컨텐츠 관리&lt;/h2&gt;

&lt;p&gt;어떻게 하면 서버의 부하를 덜 수 있을까&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;불필요한 컨텐츠 제거
    &lt;ul&gt;
      &lt;li&gt;인프런에서 할인 이벤트를 열었는데 장애가 발생.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://tech.inflab.com/202201-event-postmortem/&quot;&gt;https://tech.inflab.com/202201-event-postmortem/&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;강의 본문을 조회하는 쿼리가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select *&lt;/code&gt; 로 되어 있어서 사용 여부와 관계 없이 모든 컬럼을 조회&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CDN 을 통한 컨텐츠 제공
    &lt;ul&gt;
      &lt;li&gt;정적 자원들은 메인 서버가 주는게 아니라, CDN 을 통해서 주면 부하가 분산된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨텐츠 캐싱
    &lt;ul&gt;
      &lt;li&gt;요청 자체를 줄일 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨텐츠 압축
    &lt;ul&gt;
      &lt;li&gt;텍스트 기반 리소스는 gzip / brotli 등을 통해 압축 (70퍼정도로 압축됨)&lt;/li&gt;
      &lt;li&gt;압축 푸는 서버의 자원도 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨텐츠의 우아한 저하 (미리 준비된 응답)
    &lt;ul&gt;
      &lt;li&gt;시스템의 과도한 부하를 줄이기 위해 제공하는 컨텐츠 및 기능을 일시적으로 줄이는 전략
  예를 들어 정적 텍스트 페이지를 제공하거나, 검색을 비활성화하거나 더 적은 수의 검색 결과를 반환하거나, 필수적이지 않은 기능을 비활성화&lt;/li&gt;
      &lt;li&gt;이미지나 썸네일 등을 빼버리고 텍스트 기반으로 축소 서빙 (중요한 텍스트만 남기고 제거)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;https://youtu.be/xEu1bZqudE8?t=1070&quot;&gt;video&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;rest-api-란-무엇인가요&quot;&gt;REST API 란 무엇인가요?&lt;/h1&gt;

&lt;p&gt;→ Restful 한 API&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Uniform-Interface
    &lt;ol&gt;
      &lt;li&gt;API에서 자원들은 각각의 독립적인 인터페이스를 가지며, 각각의 자원들이 url 자원식별, 표현을 통한 자원조작, Self-descriptive message, HATEOAS 구조를 가지는 것을 말합니다.&lt;/li&gt;
      &lt;li&gt;독립적인 인터페이스라는 것은 서로 종속적이지 않은 인터페이스를 말합니다.
 예를 들어, 웹페이지를 변경했다고 웹 브라우저를 업데이트 하는 일은 없어야 하고, HTTP 명세나 HTML 명세가 변경되어도 웹페이지는 잘 작동해야 합니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;url-자원-식별&quot;&gt;URL 자원 식별&lt;/h3&gt;

&lt;p&gt;→ identification of resources, 자원은 url 로 식별되어야 합니다.&lt;/p&gt;

&lt;p&gt;/product/${id} 로 요청을 하면, 여기에 해당하는 product 를 줘야한다.&lt;/p&gt;

&lt;h3 id=&quot;표현을-통한-자원-조작&quot;&gt;표현을 통한 자원 조작&lt;/h3&gt;

&lt;p&gt;Manipulation of resources through representations, URL 과 GET, DELETE 등 HTTP 표준 메서드 등을 통해 자원을 조회, 삭제 등 작업을 설명할 수 있는 정보가 담겨야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getProduct 가 아니라, GET 메소드를 쓰고 /product
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;self-descriptive-messages&quot;&gt;Self-descriptive Messages&lt;/h3&gt;

&lt;p&gt;HTTP Header 에 타입을 명시하고 각 메세지들은 MIME types 에 맞춰 표현되어야 합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 .json 을 반환한다면 application/json 으로 명시하기&lt;/p&gt;

&lt;h3 id=&quot;hateoas-hypermedia-as-the-engine-of-application-state&quot;&gt;HATEOAS (Hypermedia As The Engine Of Application State)&lt;/h3&gt;

&lt;p&gt;강의 내용에서 설명이 좀 부족한 것 같다.&lt;/p&gt;

&lt;p&gt;하이퍼링크에 따라 다른 페이지를 보여줘야 하며, 데이터마다 어떤 URL에서 왔는지 명시해주어야 한다.&lt;/p&gt;

&lt;p&gt;보통은 href, links, link, url 속성 중 하나에 해당 데이터의 URL 을 담아서 표기해야 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동적 상호작용 제공 : 클라이언트는 고정된 URL 경로를 하드코딩하지 않고, 서버가 제공하는 하이퍼링크를 따라가며 필요한 리소스나 작업을 탐색&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자체 설명적 메시지&lt;/strong&gt;: 서버가 응답 메시지에 포함된 링크를 통해 클라이언트가 다음 작업을 수행할 수 있는 정보를 제공합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 상태 전환&lt;/strong&gt;: 링크를 통해 리소스 상태를 바꾸거나, 새로운 리소스를 요청하거나, 작업을 수행할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HATEOAS 미적용&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
  &quot;id&quot;: 123,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;email&quot;: &quot;johndoe@example.com&quot;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;HATEOAS 를 적용한 응답&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;json
{
  &quot;id&quot;: 123,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;email&quot;: &quot;johndoe@example.com&quot;,
  &quot;_links&quot;: {
    &quot;self&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123&quot;
    },
    &quot;update&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123&quot;,
      &quot;method&quot;: &quot;PUT&quot;
    },
    &quot;delete&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123&quot;,
      &quot;method&quot;: &quot;DELETE&quot;
    },
    &quot;orders&quot;: {
      &quot;href&quot;: &quot;https://api.example.com/users/123/orders&quot;
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 응답에서는 클라이언트가 self, update, delete, orders와 같은 작업을 수행할 수 있도록 하이퍼링크를 제공합니다.
•	클라이언트는 이 링크를 활용해 데이터를 업데이트하거나 삭제하며,
•	해당 사용자가 주문한 orders 데이터를 조회할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS의 장점&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;API 유연성 증가&lt;/strong&gt;: 클라이언트는 URL을 하드코딩할 필요 없이 동적으로 링크를 탐색하며 API와 상호작용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;버전 관리 간소화&lt;/strong&gt;: API 구조가 변경되더라도 클라이언트는 링크를 따라가기만 하면 되므로 API 변경의 영향을 덜 받습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;문서 의존성 감소&lt;/strong&gt;: API 응답 자체가 필요한 작업에 대한 정보를 포함하므로, 별도의 문서 없이도 클라이언트가 API를 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS의 단점&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구현 복잡성&lt;/strong&gt;: 서버는 각 리소스에 적절한 하이퍼링크와 메타데이터를 제공해야 하므로 구현 난이도가 증가합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;성능 부담&lt;/strong&gt;: 추가적인 링크 정보를 포함하기 때문에 응답 크기가 커질 수 있고, 처리 시간이 늘어날 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;지원 부족&lt;/strong&gt;: 일부 클라이언트 라이브러리나 개발 환경에서 HATEOAS를 직접 활용하기 어려울 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS를 사용해야 할 때&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;•	API 사용자가 특정 리소스에서 어떤 작업을 수행할 수 있을지 동적으로 안내가 필요한 경우.&lt;/p&gt;

&lt;p&gt;•	대규모 애플리케이션에서 URL 구조가 자주 변경될 가능성이 높은 경우.&lt;/p&gt;

&lt;p&gt;•	클라이언트와 서버 간의 긴밀한 결합을 줄이고 독립성을 높이고자 할 때.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HATEOAS와 RESTful API의 관계&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HATEOAS는 REST의 핵심 원칙 중 하나이지만, 모든 RESTful API가 반드시 HATEOAS를 구현해야 하는 것은 아닙니다. RESTful API 설계에서 HATEOAS의 채택 여부는 시스템의 요구 사항과 복잡성에 따라 달라질 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;stateless&quot;&gt;Stateless&lt;/h2&gt;

&lt;p&gt;REST API 를 제공하는 서버는 세션을 해당 서버 쪽에 유지하지 않는다는 의미&lt;/p&gt;

&lt;p&gt;유저의 상태가 서버에 저장되기 때문에, 세션 방식은 RESTFUL 하지 않다.&lt;/p&gt;

&lt;h2 id=&quot;cacheable&quot;&gt;Cacheable&lt;/h2&gt;

&lt;p&gt;HTTP 에선 기본값으로 캐싱이 된다.&lt;/p&gt;

&lt;h2 id=&quot;client---server-구조&quot;&gt;Client - Server 구조&lt;/h2&gt;

&lt;p&gt;클라이언트와 서버가 서로 독립적인 구조를 가져야 합니다. 물론 이는 HTTP 를 통해 가능한 구조입니다.&lt;/p&gt;

&lt;h2 id=&quot;layered-system&quot;&gt;Layered System&lt;/h2&gt;

&lt;p&gt;계층 구조로 나누어져 있는 아키텍처.&lt;/p&gt;

&lt;h2 id=&quot;rest-api-의-uri-규칙&quot;&gt;REST API 의 URI 규칙&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;동작은 HTTP 메소드로만 해야하고, url 에 해당 내용이 들어가면 안된다.
수정은 PUT, 삭제는 DELETE, 추가는 POST, 조회는 GET&lt;/li&gt;
  &lt;li&gt;확장자는 표시하면 안된다.&lt;/li&gt;
  &lt;li&gt;동사가 아닌 명사로만 표기&lt;/li&gt;
  &lt;li&gt;계층적인 내용을 담고 있어야 한다. /집/아파트/전세 처럼 내려가는 구조&lt;/li&gt;
  &lt;li&gt;대문자가 아닌 소문자만 쓰고, 너무 길 경우에는 언더바가 아닌 대시(-) 를 사용&lt;/li&gt;
  &lt;li&gt;HTTP 응답 상태코드를 활용. 성공 200, 생성 201, 리다이렉트 301 …&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그 외, api 업그레이드를 위해 Version 을 표기 (/wp/v2/posts?page=2)&lt;/p&gt;

&lt;h1 id=&quot;브라우저-렌더링-과정&quot;&gt;브라우저 렌더링 과정&lt;/h1&gt;

&lt;p&gt;아래의 과정이 동시에 일어난다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;DOM, CSSOM Tree 생성&lt;/p&gt;

    &lt;p&gt;DOM Tree : 각각의 태그 노드&lt;/p&gt;

    &lt;p&gt;CSSOM Tree : CSS 파서에 의해 정해진 스타일 규칙 적용&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DOM 트리와 CSSOM 트리가 합쳐져 렌더 객체가 생성된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;display: none&lt;/code&gt; 이 포함된 노드는 지워지고, font-size 등 상속적인 스타일은 부모노드에만 위치하도록 설계하는 등의 최적화를 거쳐 렌더 레이어가 완성 된다.&lt;/p&gt;

&lt;p&gt;display: none 은 렌더트리에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt; 되지만, visibility: hidden 은 요소를 보이지 않게 할 뿐 여전히 레이아웃에서 공간을 차지한다.&lt;/p&gt;

&lt;p&gt;또한 렌더 레이어가 완성될 때, GPU 에서 처리되는 부분이 있으면 이 요소들은 강제적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그래픽 레이어&lt;/code&gt;로 분리된다.&lt;/p&gt;

&lt;p&gt;그래픽 레이어는 리플로우와 리페인트를 유발하지 않는다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;레이아웃 잡기 (Layout)&lt;/li&gt;
  &lt;li&gt;렌더레이어를 대상으로 칠하기 (Paint)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레이어 합치기 (Composite Layer) 및 표기&lt;/p&gt;

    &lt;p&gt;각각의 레이어로부터 비트맵이 생성되고, GPU에 텍스쳐로 업로드 됩니다. 그 다음 텍스쳐들은 서로 합쳐져 하나의 이미지로 렌더링되며 화면으로 출력됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 렌더트리와 DOM 트리는 1:1 대응일까요?&lt;br /&gt;
아닙니다. DOM 트리 &amp;gt; 렌더 객체 &amp;gt; 렌더 트리가 되는 과정에서 display: none 으로 사라지는 렌더 객체들이 있을 수 있기 때문.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;아닙니다. DOM 트리 &amp;gt; 렌더 객체 &amp;gt; 렌더 트리가 되는 과정에서 display: none 으로 사라지는 렌더 객체들이 있을 수 있기 때문.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;wwwnavercom-을-주소창에-입력했을-때-생기는-과정-그리고-dns-까지-설명해주세요&quot;&gt;&lt;a href=&quot;http://www.naver.com/&quot;&gt;www.naver.com&lt;/a&gt; 을 주소창에 입력했을 때 생기는 과정, 그리고 DNS 까지 설명해주세요&lt;/h1&gt;

&lt;details&gt;
&lt;summary&gt;강의 답변&lt;/summary&gt;

리다이렉트, 캐싱, DNS, IP 라우팅, TCP 연결 구축을 거쳐


요청, 응답이 일어나는 TTFB(TIme TO First Byte) 가 시작되고


이후 컨텐츠를 다운받게 되고,


브라우저 렌더링 과정을 거쳐 네이버라는 화면이 나타나게 됩니다.


&lt;/details&gt;

&lt;h2 id=&quot;리다이렉트&quot;&gt;리다이렉트&lt;/h2&gt;

&lt;p&gt;리다이렉트가 있다면 리다이렉트를 진행하고, 없다면 그대로 해당 요청에 대한 과정이 진행&lt;/p&gt;

&lt;h2 id=&quot;캐싱&quot;&gt;캐싱&lt;/h2&gt;

&lt;p&gt;해당 요청이 캐싱이 가능한지, 가능하지 않은지를 파악합니다. 캐싱이 이미 된 요청이라면 캐싱된 값을 반환하며, 캐싱이 되지 않은 새로운 요청이라면 그 다음 단계로 넘어갑니다.&lt;/p&gt;

&lt;p&gt;캐싱은 요청된 값의 결과값을 저장하고 그 값을 다시 요청하면 다시 제공하는 기술입니다.&lt;/p&gt;

&lt;p&gt;브라우저 캐시와, 공유 캐시로 나뉘어집니다.&lt;/p&gt;

&lt;h3 id=&quot;브라우저-캐시&quot;&gt;브라우저 캐시&lt;/h3&gt;

&lt;p&gt;쿠키, 로컬스토리지 등을 포함한 캐시 (개인, private 캐시)&lt;/p&gt;

&lt;h3 id=&quot;공유-캐시&quot;&gt;공유 캐시&lt;/h3&gt;

&lt;p&gt;클라이언트와 서버 사이에 있으며, 사용자간에 공유할 수 있는 응답을 저장할 수 있다. 예를 들어, 요청한 서버 앞 단에 프록시 서버가 캐싱을 하고 있는 것. 이를 리버스 프록시를 둬서 내부 서버로 포워드한다고도 말합니다.&lt;/p&gt;

&lt;h2 id=&quot;dns&quot;&gt;DNS&lt;/h2&gt;

&lt;p&gt;Domain Name System 은 계층적인 도메인 구조와 분산된 데이터베이스를 이용한 시스템으로,&lt;/p&gt;

&lt;p&gt;FQDN 을 인터넷 프로토콜인 IP 로 바꿔주는 시스템입니다.&lt;/p&gt;

&lt;p&gt;이는 DNS 관련 요청을 네임서버로 전달하고, 해당 응답값을 클라이언트에게 전달하는 Resolver,&lt;/p&gt;

&lt;p&gt;도메인을 IP 로 변환하는 네임서버 등으로 이루어져있습니다.&lt;/p&gt;

&lt;h3 id=&quot;fqdn&quot;&gt;FQDN&lt;/h3&gt;

&lt;p&gt;FQDN (Fully Qualified Domain Name) 은 호스트와 도메인이 합쳐진 완전한 도메인 이름을 말합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.naver.com/&quot;&gt;www.naver.com&lt;/a&gt; 에서 www 등은 호스트 부분 혹은 서브 도메인, naver.com 은 도메인이라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;dns-캐싱&quot;&gt;DNS 캐싱&lt;/h3&gt;

&lt;p&gt;미리 해당 도메인 이름을 요청한 적이 있다면, 로컬 PC 에 자동적으로 저장됩니다.&lt;/p&gt;

&lt;p&gt;브라우저 캐싱과, OS 캐싱이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;ip-라우팅&quot;&gt;IP 라우팅&lt;/h2&gt;

&lt;p&gt;해당 IP 를 기반으로 라우팅, ARP 과정을 거쳐 실제 서버를 찾습니다.&lt;/p&gt;

&lt;h2 id=&quot;tcp-연결-구축-http--20&quot;&gt;TCP 연결 구축 (HTTP  ~2.0)&lt;/h2&gt;

&lt;p&gt;브라우저가 TCP 3Way handshake 및 SSL 연결 등을 통해 연결을 설정합니다.&lt;/p&gt;

&lt;p&gt;이후에 요청을 보냄으로써 서버로부터 응답을 받습니다.&lt;/p&gt;

&lt;h2 id=&quot;quic-연결-http-30&quot;&gt;QUIC 연결 (HTTP 3.0)&lt;/h2&gt;

&lt;h2 id=&quot;컨텐츠-다운로드&quot;&gt;컨텐츠 다운로드&lt;/h2&gt;

&lt;p&gt;요청한 컨텐츠를 서버로부터 다운 받습니다.&lt;/p&gt;

&lt;p&gt;처음 다운로드를 시작할 때, TTFB (Time To First Byte) 라고 합니다.&lt;/p&gt;

&lt;h2 id=&quot;브라우저-렌더링&quot;&gt;브라우저 렌더링&lt;/h2&gt;

&lt;p&gt;받은 데이터를 바탕으로 브라우저 엔진이 브라우저 렌더링 과정을 거쳐 화면을 만듭니다.&lt;/p&gt;

&lt;h1 id=&quot;이더넷-프레임은-무엇이며-구조가-어떻게-되나요&quot;&gt;이더넷 프레임은 무엇이며, 구조가 어떻게 되나요?&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이더넷프레임이란 데이터 링크계층의 데이터 단위이며 이더넷 프레임을 기반으로 데이터가 전달 되며 다음과 같은 필드로 구성되어있습니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**Preamble**&lt;/u&gt; : [7바이트]
이더넷 프레임이 시작임을 알려준다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**SFD**&lt;/u&gt; : [1바이트]
Start frame delimiter, 다음 필드부터 주소필드가 시작됨을 알려줍니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**Address**&lt;/u&gt; : [6, 6바이트]
목적지 주소, 시작지 주소입니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**EtherType**&lt;/u&gt; : [2바이트]
데이터링크계층 위의 IP 프로토콜을 정의합니다. (IPv4, Ipv6)&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**Payload**&lt;/u&gt; : [가변바이트]
데이터 또는 페이로드라고 합니다. 가변길이 필드입니다. 해당 필드는 이진데이터(0과1로 이루어진 데이터)로 구성됩니다. IEEE 표준은 최대 페이로드를 1500 바이 트로 지정하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;**FCS**&lt;/u&gt; : [4바이트]
frame check sequence이며 수신측의 에러검출을 위해 삽입하는 필드입니 다. CRC 에러검출 기법에 의해 생성된 비트배열이 여기에 담깁니다. 비트배열을 기반으로 수신된 데이터가 손상되었는지를 확인하고, 에러 확인 시에는 해당 프레임을 폐기하고 송신측에 재전송을 요구하기 위한 필드입니다.
CRC 알고리즘에 의해 만들어진 비트 배열이 담기는 필드&lt;/p&gt;

&lt;h1 id=&quot;cors란-무엇인가요&quot;&gt;CORS란 무엇인가요?&lt;/h1&gt;

&lt;h2 id=&quot;origin&quot;&gt;Origin&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오리진&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로토콜 + 호스트네임 + 포트&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, &lt;a href=&quot;https://shopping.naver.com/home&quot;&gt;https://shopping.naver.com/home&lt;/a&gt; 에서&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https&lt;/code&gt; , &lt;a href=&quot;http://shopping.naver.com/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shopping.naver.com&lt;/code&gt;&lt;/a&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8080&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;sop-same-origin-policy&quot;&gt;SOP (Same Origin Policy)&lt;/h2&gt;

&lt;p&gt;브라우저 상에서 오로지 같은 오리진끼리만 요청을 허가하는 보안 정책.&lt;/p&gt;

&lt;p&gt;브라우저 상에서 다른 오리진끼리는 통신이 불가능하다.&lt;/p&gt;

&lt;p&gt;다른 오리진에서 요청을 하는 공격에 방지하기 위함&lt;/p&gt;

&lt;h2 id=&quot;cors-cross-origin-resource-sharing&quot;&gt;CORS (Cross Origin Resource Sharing)&lt;/h2&gt;

&lt;p&gt;다른 오리진과 통신을 해야하는 일이 있을 수 있기 때문에, SOP 보다 조금 느슨한 규칙&lt;/p&gt;

&lt;p&gt;포트번호만 달라도 오리진이 다르기 때문에 개발 과정에서 백/프 끼리도 보통 오리진이 다르다&lt;/p&gt;

&lt;p&gt;HTTP 헤더를 기반으로 브라우저가 다른 오리진에 대한 리소스(image, css, js, video 등) 로드를 허용할지 말지에 대한 규칙&lt;/p&gt;

&lt;h2 id=&quot;preflight-request-simple-request&quot;&gt;Preflight Request, Simple Request&lt;/h2&gt;

&lt;p&gt;CORS는 브라우저가 다른 출처(origin)의 리소스에 접근할 때 안전을 보장하기 위해 사용하는 메커니즘입니다. 요청은 크게 두 가지로 나뉩니다&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1-simple-request-단순-요청&quot;&gt;1. &lt;strong&gt;Simple Request (단순 요청)&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;정의&quot;&gt;정의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저가 사전 확인(preflight)을 생략하고 &lt;strong&gt;직접 요청&lt;/strong&gt;을 서버에 보내는 요청입니다.&lt;/li&gt;
  &lt;li&gt;CORS 규칙에서 &lt;strong&gt;Simple Request&lt;/strong&gt;는 특정 조건을 만족해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;simple-request의-조건&quot;&gt;Simple Request의 조건&lt;/h3&gt;

&lt;p&gt;Simple Request가 되기 위해서는 아래 조건을 모두 충족해야 합니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;HTTP 메서드&lt;/strong&gt;가 다음 중 하나여야 합니다:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;헤더(Header)&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;요청에 사용된 헤더가 CORS에서 허용된 &lt;strong&gt;간단한 헤더(Simple Headers)&lt;/strong&gt;만 포함해야 합니다.&lt;/li&gt;
      &lt;li&gt;허용된 간단한 헤더:
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accept&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Accept-Language&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Language&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt; (단, 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;, 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/plain&lt;/code&gt;일 경우만 허용)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Content-Type&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;요청 본문(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Body&lt;/code&gt;)의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt; 값이 아래 중 하나여야 합니다:
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/plain&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Credentials&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;요청에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Authorization&lt;/code&gt; 헤더나 쿠키와 같은 자격 증명(크리덴셜)이 포함되지 않아야 함 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;withCredentials&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;동작-방식&quot;&gt;동작 방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;브라우저는 요청을 바로 서버에 보냅니다.&lt;/li&gt;
  &lt;li&gt;서버는 요청의 출처(origin)와 헤더를 보고 허용 여부를 판단합니다.&lt;/li&gt;
  &lt;li&gt;서버가 허용하면 브라우저는 응답을 처리합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-preflight-request-사전-요청&quot;&gt;2. &lt;strong&gt;Preflight Request (사전 요청)&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;요청이 Simple Request 조건을 충족하지 않으면 브라우저는 &lt;strong&gt;Preflight Request&lt;/strong&gt;를 먼저 보냅니다.&lt;/li&gt;
  &lt;li&gt;Preflight Request는 실제 요청 전에 서버가 해당 요청을 허용할지 여부를 확인하는 &lt;strong&gt;안전성 검사&lt;/strong&gt;입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;preflight-request의-동작&quot;&gt;Preflight Request의 동작&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;브라우저는 &lt;strong&gt;HTTP OPTIONS&lt;/strong&gt; 메서드로 사전 요청을 보냅니다.&lt;/li&gt;
  &lt;li&gt;Preflight Request에는 아래와 같은 정보를 포함합니다:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Origin&lt;/code&gt;: 요청의 출처.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Request-Method&lt;/code&gt;: 실제 요청에 사용될 HTTP 메서드.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Request-Headers&lt;/code&gt;: 실제 요청에서 사용될 커스텀 헤더(있을 경우).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 Preflight Request에 대해 응답합니다:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Allow-Origin&lt;/code&gt;: 허용된 출처.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Allow-Methods&lt;/code&gt;: 허용된 HTTP 메서드.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Access-Control-Allow-Headers&lt;/code&gt;: 허용된 커스텀 헤더.&lt;/li&gt;
      &lt;li&gt;응답 상태 코드가 200이면 브라우저는 실제 요청을 보냅니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;preflight가-필요한-조건&quot;&gt;Preflight가 필요한 조건&lt;/h3&gt;

&lt;p&gt;Preflight Request는 다음 중 하나 이상에 해당할 때 발생합니다:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;요청 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;가 아닌 경우 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PATCH&lt;/code&gt; 등).&lt;/li&gt;
  &lt;li&gt;요청 헤더가 &lt;strong&gt;간단한 헤더&lt;/strong&gt; 외의 커스텀 헤더를 포함하는 경우.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Content-Type&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text/plain&lt;/code&gt;이 아닌 경우 (예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/json&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;요청에 자격 증명(크리덴셜, 예: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Authorization&lt;/code&gt; 헤더나 쿠키)이 포함된 경우.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;네이글-알고리즘이란-무엇인가요&quot;&gt;네이글 알고리즘이란 무엇인가요?&lt;/h1&gt;

&lt;p&gt;네이글 알고리즘은 네트워크의 효율성을 높이기 위해 네트워크를 통해 전송되어야 하는 패킷의 수를 줄이고 적은 양의 데이터를 자주 보내면 발생되는 대역폭 낭비를 막아주는 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기존 방법과 다르게 패킷을 보낼 때 고정 크기의 버퍼에 모아두고 버퍼에 어느정도 차면 그 때 보내고, 다시 ACK 가 오면 버퍼에 찬 데이터를 보내는 방법&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;네이글-알고리즘의-장점&quot;&gt;네이글 알고리즘의 장점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;전송하는 패킷의 수가 줄어들기 때문에 네트워크의 혼잡도를 줄이고 패킷 손실률을 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;작은 패킷들을 많이 전송할 때, 각 패킷에 포함된 헤더의 크기가 커져서 대역폭 소모가 많이 발생할 수 있다. 패킷의 수를 줄임으로써 이러한 오버헤드를 줄일 수 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;네이글-알고리즘의-단점&quot;&gt;네이글 알고리즘의 단점&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;작은 패킷의 수를 줄이기 위해 데이터를 버퍼링하고, 충분한 양의 데이터가 모일 때 까지 패킷 전송을 지연시킨다.&lt;/li&gt;
  &lt;li&gt;ACK를 받기 전까지 데이터를 전송하지 않기 때문에 지연시간이 발생할 수 있다.
(실시간이 중요하다면 사용하기 힘들다)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-15-네트워크_CS_지식.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;http-의-멱등성에-대해-설명해주세요&quot;&gt;HTTP 의 멱등성에 대해 설명해주세요&lt;/h1&gt;

&lt;p&gt;HTTP 멱등성(idempotent)이란 하나의 요청이 아닌 여러번 동일한 요청을 보냈을 때 서버가 같은 상태를 가지는 것을 멱등성이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.tosspayments.com/blog/what-is-idempotency&quot;&gt;https://docs.tosspayments.com/blog/what-is-idempotency&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;멱등성을-가지는-메소드&quot;&gt;멱등성을 가지는 메소드&lt;/h2&gt;

&lt;h3 id=&quot;get-안전한-메소드&quot;&gt;GET (안전한 메소드)&lt;/h3&gt;

&lt;p&gt;서버에서 정보를 가져오는 것을 여러 번 해도, 동일한 정보를 가져온다.&lt;/p&gt;

&lt;h3 id=&quot;head-안전한-메소드&quot;&gt;HEAD (안전한 메소드)&lt;/h3&gt;

&lt;p&gt;헤드는 GET 요청이 생성하는 응답의 헤더를 검색하는데 사용됩니다.&lt;/p&gt;

&lt;p&gt;따라서 서버의 상태를 변경하지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;options-안전한-메소드&quot;&gt;OPTIONS (안전한 메소드)&lt;/h3&gt;

&lt;p&gt;대상 리소스의 통신 옵션 ( 서버에서 지원하는 HTTP 메서드 등)을 가져올 때 사용&lt;/p&gt;

&lt;h3 id=&quot;put-안전한-메소드는-아님&quot;&gt;PUT (안전한 메소드는 아님)&lt;/h3&gt;

&lt;p&gt;서버에 있는 데이터를 아예 교체하기 때문에 여러 번 보내도 똑같은 데이터로 교체될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;delete-안전한-메소드는-아님&quot;&gt;DELETE (안전한 메소드는 아님)&lt;/h3&gt;

&lt;p&gt;삭제 작업을 반복해도 시스템 상태가 더 이상 변경되지 않습니다.&lt;/p&gt;

&lt;p&gt;그런데 흠..&lt;/p&gt;

&lt;p&gt;예를 들어 DELETE /post/lastest 라고 해보자. 가장 최신 포스트를 지우게 된다고 하면 서버의 상태가 바뀌지 않나?&lt;/p&gt;

&lt;p&gt;또한 만약 DELETE /post/abc 인 상황에서 abc 라는 리소스가 여러 개라면? DELETE 는 abc 리소스를 하나만 지우는 상황이라면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;이러면 또 멱등성을 보장할 수 없는게 아닌가?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;는 멱등성&lt;/strong&gt;을 보장하는 메서드이지만, &lt;strong&gt;대상 리소스를 정확히 지정해야&lt;/strong&gt; 합니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE /posts/123&lt;/code&gt;와 같이 &lt;strong&gt;구체적인 리소스&lt;/strong&gt;를 명시해야 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE /posts/last&lt;/code&gt;와 같이 마지막 게시글을 삭제하는 요청은 &lt;strong&gt;상태 변화가 계속 일어나므로 멱등성을 가지지 않&lt;/strong&gt;습니다.&lt;/li&gt;
  &lt;li&gt;이런 경우에는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;를 사용하는 것이 더 적절&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;요약&lt;/strong&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;는 멱등성을 보장하므로 &lt;strong&gt;상태 변화가 없을 때&lt;/strong&gt; 사용해야 합니다. 상태가 계속 바뀌는 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;를 사용하는 것이 HTTP 스펙상 더 맞습니다.&lt;/p&gt;

&lt;h3 id=&quot;post&quot;&gt;POST&lt;/h3&gt;

&lt;p&gt;서버에 동일한 요청을 여러 번 보내면, 보낸 만큼 생성 될 것이기 때문에 서버의 상태가 바뀌게 된다.&lt;/p&gt;

&lt;h3 id=&quot;patch&quot;&gt;PATCH&lt;/h3&gt;

&lt;p&gt;리소스를 부분적으로 업데이트 하게 되는데, 멱등성의 여부는 PATCH 를 실행하는 방법에 따라 달라진다.&lt;/p&gt;

&lt;p&gt;예를 들어 특정 부분을 새롭게 교체하는거라면 멱등성을 가지지만, 하나씩 증가하거나 빼기, 배열에 요소 추가 등의 방식은 멱등성을 가지지 않는다.&lt;/p&gt;

&lt;p&gt;함수형 프로그래밍이 생각나네&lt;/p&gt;

&lt;h2 id=&quot;http-멱등성을-고려한-api-설계&quot;&gt;HTTP 멱등성을 고려한 API 설계&lt;/h2&gt;

&lt;p&gt;POST 메서드의 경우 idempotency Key를 보내서 동일한 요청인지를 식별하게 합니다.
이를 통해 동일한 작업의 재시도를 인식하고 한 번만 처리되도록 합니다. 이는 중복 트랜잭션을 피해야 하는 결제 처리 API에서 자주 사용됩니다.&lt;/p&gt;

&lt;h2 id=&quot;멱등성이-중요한-이유&quot;&gt;멱등성이 중요한 이유&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;일관성 : 보통 반복되는 요청이 단일 요청과 동일한 효과를 갖도록 보장하는 것은 시스템 전반에 걸쳐 일관된 상태를 유지하는 데 도움이 됩니다.&lt;/li&gt;
  &lt;li&gt;유지보수성 : 멱등성을 가진 HTTP메서드로 AP로 통신하는 부분에 있어서는 재시도를 처리할 때의 사이드이펙트를 고려한 복잡한 로직을 구현할 필요가 없기 때문에 이 부분을 잘 고려해서 설계한다면 유지보수성이 증가 됩니다.&lt;/li&gt;
&lt;/ol&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Network" />
      
        <category term="개념 정리" />
      

      
        <summary type="html">네트워크 CS 지식 정리</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Effective TypeScript - 2</title>
      <link href="https://hoeeeeeh.github.io/Effective_TypeScript_-_2" rel="alternate" type="text/html" title="Effective TypeScript - 2" />
      <published>2025-01-14T03:54:00+00:00</published>
      <updated>2025-01-14T03:54:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/Effective_TypeScript_-_2</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/Effective_TypeScript_-_2">&lt;blockquote&gt;
  &lt;p&gt;이펙티브 타입스크립트 책과&lt;br /&gt;
이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;타입스크립트-컴파일러-역할&quot;&gt;타입스크립트 컴파일러 역할&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;구 버전 브라우저를 위한 트랜스파일 -&amp;gt; Babel 의 역할이었던거 같은데?&lt;/li&gt;
  &lt;li&gt;코드의 타입 오류 체크&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 역할은 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적&lt;/code&gt;이다. 서로의 작업에 영향을 주지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;타입-오류가-있어도-컴파일이-가능&quot;&gt;타입 오류가 있어도 컴파일이 가능&lt;/h2&gt;

&lt;p&gt;컴파일은 타입 체크와 독립적으로 동작하므로 오류 있어도 컴파일은 가능&lt;/p&gt;

&lt;p&gt;만약 오류가 있을 때 컴파일 하고 싶지 않으면 tsconfig.json 에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;noEmitError&lt;/code&gt; 옵션을 true 로 주면 된다.&lt;/p&gt;

&lt;h2 id=&quot;런타임에는-타입-체크-불가능&quot;&gt;런타임에는 타입 체크 불가능&lt;/h2&gt;

&lt;p&gt;타입스크립트에서 자바스크립트로 컴파일되면서 타입이나 인터페이스 같은 경우 전부 제거된다.
즉, 런타임 시점에서 타입과 인터페이스는 아무런 역할을 하지 못한다.&lt;/p&gt;

&lt;h2 id=&quot;함수-오버로딩-불가능&quot;&gt;함수 오버로딩 불가능&lt;/h2&gt;

&lt;p&gt;선언문은 타입 별로 여러개 선언은 가능하다. 하지만 구현체는 오직 하나다.&lt;/p&gt;

&lt;h2 id=&quot;덕타이핑&quot;&gt;덕타이핑&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://hoeeeeeh.github.io/javascript/2024/07/29/day1112.html#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-interface-duck-typing&quot;&gt;interface 와 duck-typing&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;any-타입-꼭-써야겠어&quot;&gt;Any 타입, 꼭 써야겠어?&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;any 타입 쓰면 타입에 안전성이 없다. 쓰면 number 타입에 string 이 할당될 수도 있어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 함수의 시그니처(약속/의도 정도로 해석?)가 무시된다.&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 자동완성 기능, 코드 리팩토링 도구 쓰기 힘들어져 -&amp;gt; 생산성 떨어진다!&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 코드 리팩토링할 때 버그를 찾기 힘들어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 타입 설계의 의도, 상태 등이 감춰져서 설계를 해석하기 힘들어&lt;/li&gt;
  &lt;li&gt;any 타입 쓰면 실수가 빈번해져&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이래도 any 타입, 꼭 사용하셔야겠습니까?&lt;/p&gt;

&lt;p&gt;근데 불가피하게 any 타입을 꼭 써야할 때가 있다. 이는 5장에서 다룬다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="TypeScript" />
      

      
        <summary type="html">이펙티브 타입스크립트 책과 이펙티브 타입스크립트 스터디 영상을 공부하며 정리한 내용입니다.</summary>
      

      
      
    </entry>
  
</feed>
