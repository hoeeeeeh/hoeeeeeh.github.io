<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <!-- 필요한 언어 모듈(typescript 등) 추가 로드 -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/typescript.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>

    <!-- Highlight.js 초기화 -->
    <script>
        (function () {
            function normalizeFenceLanguage(block) {
                var text = block.textContent || '';
                if (!text) return;
                var lines = text.split('\n');
                if (!lines.length) return;
                // 첫 줄이 비어있는 경우를 대비해 앞쪽 공백 줄 스킵
                var langLineIndex = -1;
                for (var i = 0; i < Math.min(lines.length, 5); i++) {
                    var maybe = (lines[i] || '').trim();
                    if (maybe) { langLineIndex = i; break; }
                }
                if (langLineIndex === -1) return;
                var firstLine = (lines[langLineIndex] || '').trim().toLowerCase();
                if (!firstLine) return;

                var aliasMap = {
                    ts: 'typescript',
                    typescript: 'typescript',
                    tsx: 'typescript',
                    js: 'javascript',
                    javascript: 'javascript',
                    jsx: 'javascript',
                    sh: 'bash',
                    zsh: 'bash',
                    bash: 'bash',
                    yml: 'yaml',
                    yaml: 'yaml',
                    py: 'python',
                    python: 'python',
                    rb: 'ruby',
                    ruby: 'ruby',
                    c: 'c',
                    cpp: 'cpp',
                    cplusplus: 'cpp',
                    cs: 'csharp',
                    csharp: 'csharp',
                    go: 'go',
                    golang: 'go',
                    rs: 'rust',
                    rust: 'rust',
                    java: 'java',
                    kotlin: 'kotlin',
                    swift: 'swift',
                    php: 'php',
                    html: 'xml',
                    xml: 'xml',
                    json: 'json',
                    css: 'css',
                    scss: 'scss',
                    less: 'less',
                    sql: 'sql',
                    dockerfile: 'dockerfile',
                    makefile: 'makefile',
                    diff: 'diff',
                    bashrc: 'bash',
                    zshrc: 'bash'
                };

                var known = new Set(Object.keys(aliasMap));
                var lang = aliasMap[firstLine] || (known.has(firstLine) ? firstLine : null);
                if (!lang) return null;

                // 언어명이 첫 줄에 있으면 제거하고 language- 클래스 부여
                lines.splice(langLineIndex, 1);
                block.textContent = lines.join('\n');
                // 기존 language-* / highlighter-rouge 제거
                var classes = Array.prototype.slice.call(block.classList);
                classes.forEach(function (cls) {
                    if (/^language-/.test(cls) || cls === 'highlighter-rouge') {
                        block.classList.remove(cls);
                    }
                });
                block.classList.add('language-' + lang);
                // 상위 래퍼(.highlighter-rouge)에 붙은 language-plaintext도 교체
                try {
                    if (block.closest) {
                        var wrapper = block.closest('.highlighter-rouge');
                        if (wrapper) {
                            var wrapperClasses = Array.prototype.slice.call(wrapper.classList);
                            wrapperClasses.forEach(function (wcls) {
                                if (/^language-/.test(wcls)) {
                                    wrapper.classList.remove(wcls);
                                }
                            });
                            wrapper.classList.add('language-' + lang);
                        }
                    }
                } catch (e) {}
                return lang;
            }

            window.__applyLanguageHeader = function () {
                var blocks = document.querySelectorAll('pre code');
                Array.prototype.forEach.call(blocks, function (block) {
                    var hasLanguage = /\blanguage-/.test(block.className);
                    var isPlaintext = /\blanguage-(plain|plaintext|text)\b/.test(block.className);
                    var lang = null;
                    if (hasLanguage && !isPlaintext) {
                        var m = block.className.match(/\blanguage-([a-z0-9+-]+)/i);
                        lang = m && m[1] ? m[1].toLowerCase() : null;
                    } else {
                        // plaintext이거나 언어 미지정이면 첫 줄 언어 감지 시도
                        lang = normalizeFenceLanguage(block);
                    }
                    if (window.hljs) {
                        try {
                            if (lang && typeof hljs.highlight === 'function') {
                                var source = block.textContent || '';
                                var result = hljs.highlight(lang, source, true);
                                block.innerHTML = result.value;
                                block.classList.add('hljs');
                            } else if (typeof hljs.highlightAuto === 'function') {
                                var src = block.textContent || '';
                                var auto = hljs.highlightAuto(src, ['javascript','typescript','python','java']);
                                block.innerHTML = auto.value;
                                block.classList.add('hljs');
                                // lang 추론 결과를 wrapper/pre에도 반영
                                var detected = auto.language || '';
                                if (detected) {
                                    block.className = block.className.replace(/\blanguage-[^\s]+/g, '').trim();
                                    block.classList.add('language-' + detected);
                                }
                            }
                        } catch (e) {
                            // 실패 시 블록 하이라이트로 폴백
                            if (typeof hljs.highlightBlock === 'function') hljs.highlightBlock(block);
                        }
                    }
                    // post-process: unwrap <code> to avoid theme rule ".post-full-content pre code * { color: inherit }"
                    try {
                        var parentPre = block.parentElement && block.parentElement.tagName === 'PRE' ? block.parentElement : null;
                        if (parentPre) {
                            // 기존 언어/루즈/커피스크립트 및 축약 토큰(cs, http) 클래스 제거
                            Array.prototype.slice.call(parentPre.classList).forEach(function (cls) {
                                if (cls === 'highlighter-rouge' || cls === 'coffeescript' || cls === 'cs' || cls === 'http' || /^language-/.test(cls)) {
                                    parentPre.classList.remove(cls);
                                }
                            });
                            parentPre.classList.add('hljs');
                            parentPre.innerHTML = block.innerHTML;
                        }
                    } catch (e) {}
                });
            };
        })();
    </script>
    <!-- 기본 테마 배경과 색상은 CDN CSS에 맡깁니다 (이전 무력화 스타일 제거) -->

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!--    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>-->

    <!-- Prism.js 제거: highlight.js만 사용 -->
    <script>$(document).ready(function() {
        function runHighlight() {
            // pre만 있고 code가 없는 경우까지 포함해서 처리
            function collectBlocks() {
                var result = [];
                var pres = document.querySelectorAll('pre');
                Array.prototype.forEach.call(pres, function (pre) {
                    var code = pre.querySelector('code');
                    result.push(code || pre);
                });
                return result;
            }
            if (window.__applyLanguageHeader) {
                window.__applyLanguageHeader();
            }
            var blocks = collectBlocks();
            Array.prototype.forEach.call(blocks, function (block) {
                if (window.hljs && typeof hljs.highlightBlock === 'function') {
                    hljs.highlightBlock(block);
                }
            });
        }
        runHighlight();
        // 일부 환경에서 ready 이후 주입되는 콘텐츠를 커버하기 위해 load에도 한 번 더
        window.addEventListener('load', runHighlight);
    });</script>


    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>운영체제(페이징, 캐시, 자원 경쟁)</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js theme CSS를 사이트 CSS 이후에 로드하여 색상 우선순위 확보 -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai-sublime.min.css">

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="HOEH 개발 블로그" />
<link rel="shortcut icon" href="https://hoeeeeeh.github.io//assets/images/favicon.png" type="image/png" />
<link rel="canonical" href="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="hoeeeeeh" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="운영체제(페이징, 캐시, 자원 경쟁)" />
    <meta property="og:description" content="PCB 와 컨텍스트 스위칭 PCB(Process Control Block) 은 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터 블록이며, 커널 스택에 저장된다. 각 프로세스가 생성될 때 마다 고유의 PCB가 생성 되고, 프로세스가 종료되면 PCB 는 제거된다. 유저 메모리, 커널 메모리 가상메모리는 유저메모리와 커널 메모리로 나뉜다. 유저 메모리와 커널 메모리는 전부 스택 영역을 사용하기" />
    <meta property="og:url" content="https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)" />
    <meta property="og:image" content="https://hoeeeeeh.github.io/assets/images/cover/cs.png" />
    <meta property="article:publisher" content="https://www.facebook.com/ghost" />
    <meta property="article:author" content="https://www.facebook.com/ghost" />
    <meta property="article:published_time" content="2025-02-04T04:41:00+00:00" />
    <meta property="article:modified_time" content="2025-02-04T04:41:00+00:00" />
    <meta property="article:tag" content="운영체제" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="운영체제(페이징, 캐시, 자원 경쟁)" />
    <meta name="twitter:description" content="PCB 와 컨텍스트 스위칭 PCB(Process Control Block) 은 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터 블록이며, 커널 스택에 저장된다. 각 프로세스가 생성될 때 마다 고유의 PCB가 생성 되고, 프로세스가 종료되면 PCB 는 제거된다. 유저 메모리, 커널 메모리 가상메모리는 유저메모리와 커널 메모리로 나뉜다. 유저 메모리와 커널 메모리는 전부 스택 영역을 사용하기" />
    <meta name="twitter:url" content="https://hoeeeeeh.github.io/" />
    <meta name="twitter:image" content="https://hoeeeeeh.github.io/assets/images/cover/cs.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="hoeeeeeh" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="운영체제" />
    <meta name="twitter:site" content="@tryghost" />
    <meta name="twitter:creator" content="@tryghost" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "hoeeeeeh",
        "logo": "https://hoeeeeeh.github.io/assets/images/blog-icon.png"
    },
    "url": "https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)",
    "image": {
        "@type": "ImageObject",
        "url": "https://hoeeeeeh.github.io/assets/images/cover/cs.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://hoeeeeeh.github.io/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C(%ED%8E%98%EC%9D%B4%EC%A7%95,_%EC%BA%90%EC%8B%9C,_%EC%9E%90%EC%9B%90_%EA%B2%BD%EC%9F%81)"
    },
    "description": "PCB 와 컨텍스트 스위칭 PCB(Process Control Block) 은 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터 블록이며, 커널 스택에 저장된다. 각 프로세스가 생성될 때 마다 고유의 PCB가 생성 되고, 프로세스가 종료되면 PCB 는 제거된다. 유저 메모리, 커널 메모리 가상메모리는 유저메모리와 커널 메모리로 나뉜다. 유저 메모리와 커널 메모리는 전부 스택 영역을 사용하기"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="운영체제(페이징, 캐시, 자원 경쟁)" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<script>
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('toc-toggle').addEventListener('click', function() {
            document.getElementById('toc-sidebar').classList.toggle('active');
        });

        document.querySelectorAll('.toc ul li a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                const targetPosition = target.getBoundingClientRect().top + window.scrollY; // 정확한 절대 위치
                window.scrollTo({
                    top: targetPosition - 60, // 네비게이션 바 고려
                    behavior: 'smooth'
                });
            });
        });

        const tocContainer = document.querySelector('.toc'); // 목차 컨테이너
        const links = document.querySelectorAll('.toc a'); // 목차의 링크
        const sections = Array.from(links).map(link =>
            document.querySelector(link.getAttribute('href'))
        );

        // 쓰로틀링 함수 정의
        const throttle = (callback, limit) => {
            let waiting = false;
            return (...args) => {
                if (!waiting) {
                    callback(...args);
                    waiting = true;
                    setTimeout(() => (waiting = false), limit);
                }
            };
        };

        // 디바운싱 함수 정의
        const debounce = (callback, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => callback(...args), delay);
            };
        };

        // 목차 업데이트 함수
        const updateToc = () => {
            const scrollPosition = window.scrollY + 60; // 상단 바 높이 고려

            sections.forEach((section, index) => {
                const sectionTop = section.getBoundingClientRect().top + window.scrollY;
                const sectionBottom = sectionTop + section.offsetHeight;

                if (scrollPosition >= sectionTop && scrollPosition < sectionBottom) {
                    // 기존 active 제거
                    links.forEach(link => link.classList.remove('active'));

                    // 현재 active 추가
                    const activeLink = links[index];
                    activeLink.classList.add('active');

                    // 목차 컨테이너 스크롤
                    tocContainer.scrollTo({
                        top: activeLink.offsetTop - tocContainer.offsetHeight / 2,
                        behavior: 'smooth',
                    });
                }
            });
        };

        // 쓰로틀링 및 디바운싱 적용
        const optimizedScrollHandler = throttle(updateToc, 100); // 100ms마다 실행 제한
        const debouncedResizeHandler = debounce(updateToc, 50); // 리사이즈 후 200ms 후 실행

        // 스크롤 및 리사이즈 이벤트
        window.addEventListener('scroll', optimizedScrollHandler);
        window.addEventListener('resize', debouncedResizeHandler); // 창 크기 변경 시 위치 보정

    });


</script>


<style>
    /* 기본적으로 사이드바 숨기기 */

    html {
        scroll-padding-top: 60px;
    }

    .toc {
        position: fixed;
        top: 0;
        right: -240px; /* 사이드바 기본 위치 */
        width: 240px;
        height: 70vh;
        background-color: transparent;
        overflow-y: auto;
        padding: 2rem;
        transition: right 0.3s ease-in-out;
        margin-top: 60px;
    }

    .toc-toggle {
        border-radius: 25px;
    }

    .toc a.active {
        color: #e6369b; /* 활성화된 목차 색깔 */
        font-weight: bold;
    }

    /* 사이드바가 활성화되면 보이도록 */
    .toc.active {
        right: 0;
    }

    /* 목차 목록 스타일 */
    .toc ul {
        list-style-type: none;
        padding: 0;
    }

    .toc ul li {
        margin-bottom: 0.5rem;
        padding-left: 1.5rem;
        font-size: 98%;
    }

    .toc ul li a {
        text-decoration: none;
        color: #858181;
        font-weight: bold;
        display: inline-block;
    }

    .toc ul li a:hover {
        color: #007bff;
    }

    /* 버튼 스타일 */
    .toc-toggle {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: #007bff;
        color: white;
        border: none;
        padding: 10px;
        font-size: 16px;
        cursor: pointer;
        z-index: 1000;
    }

    .toc-toggle:hover {
        background-color: #0056b3;
    }

</style>

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://hoeeeeeh.github.io/"><img src="/assets/images/blog-icon.png" alt="hoeeeeeh" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="https://github.com/hoeeeeeh">GitHub</a></li>
    <li class="nav-portfolio" role="menuitem"><a href="https://hoeeeeeh.github.io/portfolio/index.html">Portfolio</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <li>
            <script src="https://hoeeeeeh.github.io/assets/js/lunr.js" charset="utf-8"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="포스트 검색"/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="https://hoeeeeeh.github.io/assets/js/lunrsearchengine.js" charset="utf-8"></script>

        </li>
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag- post ">
        <header class="post-full-header">
            <section class="post-full-meta">
                <time class="post-full-meta-date" datetime=" 4 February 2025"> 4 February 2025</time>
                
                <span class="date-divider">/</span>
                
                
                <a href='/tag//'>운영체제</a>
                
                
                
            </section>
            <h1 class="post-full-title">운영체제(페이징, 캐시, 자원 경쟁)</h1>
        </header>

        
        <figure class="post-full-image" style="background-image: url(/assets/images/cover/cs.png)">
        </figure>
        

        <section class="post-full-content">
            <div class="kg-card-markdown">
                <h1 id="pcb-와-컨텍스트-스위칭">PCB 와 컨텍스트 스위칭</h1>

<p>PCB(Process Control Block) 은 운영체제에서 관리하는 프로세스에 대한 메타데이터를 저장한 데이터 블록이며, 커널 스택에 저장된다.</p>

<p>각 프로세스가 생성될 때 마다 고유의 PCB가 생성 되고, 프로세스가 종료되면 PCB 는 제거된다.</p>

<h2 id="유저-메모리-커널-메모리">유저 메모리, 커널 메모리</h2>

<p>가상메모리는 유저메모리와 커널 메모리로 나뉜다.</p>

<p>유저 메모리와 커널 메모리는 전부 스택 영역을 사용하기 때문에 유저 스택, 커널 스택이라고 부르기도 한다.</p>

<p>여기서 커널 모드일때만 사용할 수 있는 메모리를 커널 메모리(스택)이라고 한다.</p>

<p>반대로 유저 모드일때만 사용할 수 있는 메모리는 유저 메모리(스택) 이라고 한다.</p>

<h1 id="pcb의-구조">PCB의 구조</h1>

<p>Process State : 대기중, 실행 중 등의 프로세스 상태를 나타낸다.</p>

<p>Process Number : 각 프로세스의 고유 식별 번호</p>

<p>Program Counter : 이 프로세스에 대해 실행될 다음 명령의 주소에 대한 포인터</p>

<p>Registers : 레지스터 관련 정보</p>

<p>Memory Limits : 프로세스의 메모리 관련 정보</p>

<p>List of Open Files : 프로세스를 위해 열린 파일 목록들</p>

<h1 id="컨텍스트-스위칭">컨텍스트 스위칭</h1>

<p>앞서 설명한 PCB를 기반으로 프로세스의 상태를 저장하고 다시 복원시키는 과정</p>

<p>이는 프로세스가 종료되거나 인터럽트에 의해 발생된다.</p>

<h2 id="컨텍스트-스위칭의-비용">컨텍스트 스위칭의 비용</h2>

<ul>
  <li>유휴시간의 발생 : 컨텍스트 스위칭을 할 때 마다 유휴시간이 생겨서 CPU의 가용성이 떨어진다.</li>
  <li>캐시 미스 : 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시 클리어 과정이 무조건 일어나게되고, 이 때문에 캐시 미스가 발생
페이지 테이블에 가상 주소가 실제 주소와 매칭 되어 있음. 그 위에 TLB 캐싱 계층이 있는데, 계속 컨텍스트 스위칭을 하면 캐시 미스가 발생하게 된다. 따라서 캐시를 계속 바꿔야한다.</li>
</ul>

<h1 id="프로세스의-상태">프로세스의 상태</h1>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/0.png" alt="0" /><em>프로세스의 상태변화</em></p>

<h2 id="create">CREATE</h2>

<p>프로세스가 생성된 상태</p>

<p>fork, exec 시스템 콜 등을 통해 프로세스가 생성된 상태이며 PCB 가 할당된다.</p>

<ul>
  <li>fork : 부모 프로세스를 복제해서 자식 프로세스를 생성한다.</li>
  <li>exec: 현재 프로세스의 메모리 공간에 새로운 실행 파일을 로드하여 기존 프로그램을 대체한다.</li>
</ul>

<p>보통은 fork 로 자식 프로세스를 생성한 후에, exec 로 해당 프로그램을 대체하는 방식을 주로 쓴다.</p>

<p>생성되고 나서는 대기(Ready) 상태로 간다.</p>

<h2 id="ready">Ready</h2>

<p>처음 프로세스가 생성된 이후, 메모리 공간이 충분하면 메모리를 할당받고 아니면 준비큐에 들어가서 대기중인 상태</p>

<p>이는 CPU 스케쥴러로부터 CPU 소유권이 넘어오기를 기다리는 상태</p>

<h2 id="ready-suspend">Ready Suspend</h2>

<p>Ready 큐가 꽉찬 상태라서, 메모리가 부족하기 때문에 Ready 상태가 아닌 Ready Suspend 가 된 상태</p>

<h2 id="running">Running</h2>

<p>실행 상태는 CPU 소유권과 메모리를 할당받고 명령어를 수행 중인 상태.</p>

<p>CPU Burst 가 일어났다고도 표현한다.</p>

<h2 id="blocked">Blocked</h2>

<p>어떤 이벤트가 발생한 이후, 잠시 중단되어 프로세스가 차단된 상태</p>

<p>예를 들어 프린트 인쇄 버튼을 눌렀을 때 프린트 인쇄 I/O 인터럽트에 의해, 현재 실행중이던 프로세스가 잠시 Blocked 상태로 들어갈 수 있다.</p>

<h2 id="blocked-suspend">Blocked Suspend</h2>

<p>Blocked 된 상태에서 프로세스가 실행되려고 했지만, 레디 큐로 들어가지 못하고 메모리 부족으로 또 다시 중단된 상태</p>

<h2 id="terminated--exit">Terminated / Exit</h2>

<p>프로세스 실행이 완료되어 해당 프로세스에 대한 자원을 반납하고, PCB 가 삭제된 상태.</p>

<p>부모 프로세스가 자식 프로세스를 강제로 종료시킨 경우도 있다.</p>

<h1 id="브라우저">브라우저</h1>

<p>멀티 프로세싱 + 멀티 스레딩</p>

<p><a href="https://d2.naver.com/helloworld/5237120">https://d2.naver.com/helloworld/5237120</a></p>

<h2 id="멀티-프로세싱">멀티 프로세싱</h2>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/1.png" alt="1" /><em>브라우저의 멀티 프로세싱</em></p>

<h2 id="멀티-스레딩">멀티 스레딩</h2>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/2.png" alt="2" /><em>image.png</em></p>

<h1 id="ipc">IPC</h1>

<p>Inter Process Communication 이란 프로세스끼리 데이터를 주고 받고 공유 데이터를 관리하는 매커니즘이다.</p>

<p>IPC 의 종류로는 공유 메모리, 파일, 소켓, 파이프, 메시지 큐가 있다.</p>

<h2 id="공유-메모리">공유 메모리</h2>

<p>프로세스와 프로세스가 메모리를 공유해서 데이터를 주고 받는 방식</p>

<p>메모리 자체를 공유하기 때문에 불필요한 데이터 복사의 오버헤드가 발생하지 않아 가장 빠르지만, 같은 메모리 영역을 여러 프로세스가 공유하기 때문에 동기화가 필요</p>

<p>IPC 중에서 가장 빠른 통신 방법.</p>

<h2 id="파일">파일</h2>

<p>디스크에 저장된 데이터를 기반으로 통신한다.</p>

<p>요즘엔 잘 쓰이지 않는다.</p>

<h2 id="파이프">파이프</h2>

<p>파이프는 통신을 위한 메모리 공간(버퍼)를 생성해서 프로세스 간 통신을 하는 방식이다.</p>

<h3 id="unnamed-pipe-익명-파이프">(Unnamed Pipe) 익명 파이프</h3>

<p>익명 파이프는 프로세스 사이에 FIFO 기반의 통신 채널을 만들어 통신하는 방식</p>

<p>이름이 정해지지 않은, 즉 부를 수 없는 파이프라서 외부에서 사용할 수 없다.</p>

<p>단방향 통신이므로 양방향 통신을 하려면 2개의 익명 파이프가 필요</p>

<p>부모, 자식 프로세스 간에서는 파일 디스크립션을 상속 받아서 사용할 수 있으며 다른 네트워크상에서는 사용이 불가능</p>

<p>파이프의 데이터 용량은 제한되어 있으며 쓰기 프로세스가 읽기 프로세스보다 더 빠르게 데이터를 쓸 수는 없다</p>

<h3 id="named-pipe-명명-파이프">Named Pipe (명명 파이프)</h3>

<p>익명 파이프의 확장된 개념이며 부모, 자식 뿐만 아니라 다른 네트워크 상에서도 통신할 수 있는 파이프</p>

<p>보통 서버, 클라이언트용 파이프를 구분해서 동작한다</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/3.png" alt="3" /><em>파이프 시나리오</em></p>

<h2 id="메세지-큐">메세지 큐</h2>

<p>메세지 큐는 자료구조 형태로 관리하는 버퍼를 만들어 통신하는 방식이다.</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/4.png" alt="4" /><em>매세지 큐의 동작 방식</em></p>

<ol>
  <li>프로세스가 메세지를 보내거나 받기 전에 메세지 큐를 초기화</li>
  <li>Sender 의 메세지는 큐에 <code class="language-plaintext highlighter-rouge">복사</code>되어 Receiver 에 전달된다.</li>
</ol>

<h1 id="자원-경쟁">자원 경쟁</h1>

<h2 id="공유자원">공유자원</h2>

<p>공유자원이란 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수를 의미한다.</p>

<h2 id="경쟁-상태">경쟁 상태</h2>

<p>경쟁 상태(Race Condition)은 이 공유 자원을 둘 이상의 프로세스 또는 스레드가 동시에 읽거나 쓰는 상황을 말하며, 동시에 접근을 시도할 때 예상되는 결과값에 영향을 줄 수 있는 상태를 의미한다.</p>

<h2 id="임계-영역">임계 영역</h2>

<p>임계 영역(Critical Section) 은 둘 이상의 프로세스 또는 스레드가 공유 자원에 접근할 때, 순서 등의 이유로 결과가 달라지는 코드 영역을 의미한다.</p>

<p>즉 경쟁 상태에 있는 영역</p>

<p>이 영역은 한 번에 둘 이상의 프로세스나 스레드가 접근할 수 없도록 설계된다.</p>

<h2 id="경쟁-상태-관리의-중요성">경쟁 상태 관리의 중요성</h2>

<h3 id="데이터-정합성">데이터 정합성</h3>

<p>데이터 정합성(data consistency) 는 예상되는 데이터와 값이 같아야함을 의미한다.</p>

<h3 id="데이터-무결성">데이터 무결성</h3>

<p>데이터 무결성(data integrity) 는 데이터의 어떠한 규칙을 위반하지 않아야 함을 의미한다.</p>

<p>예를 들어, 잔고가 음수가 될 수는 없다.</p>

<p>또한 데이터가 전송, 저장되고 처리되는 모든 과정에서 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성을 말한다.</p>

<h1 id="경쟁-상태의-해결-조건">경쟁 상태의 해결 조건</h1>

<p>아래의 세 조건을 만족해야 경쟁 상태를 해결할 수 있다.</p>

<h2 id="상호-배제">상호 배제</h2>

<p>상호 배제(mutual exclusion) 은 한 프로세스가 임계 영역에 들어갔을 때, 다른 프로세스는 들어갈 수 없음을 의미한다.</p>

<h2 id="한정-대기">한정 대기</h2>

<p>한정 대기(bounded waiting) 은 특정 프로세스가 임계영역 진입을 요청한 후, 해당 요청이 승인되기 전까지 다른 프로세스가 임계영역에 진입하는 횟수를 제한하는 것을 말하며, 이를 통해 특정 프로세스가 영원히 임계 영역에 들어가지 못하게 되는 것을 방지한다.</p>

<p>(자원이 독점되지 않도록)</p>

<h2 id="진행의-융통성">진행의 융통성</h2>

<p>진행의 융통성(progress) 는 만약 어떠한 프로세스도 임계 영역을 사용하지 않는다면, 임계영역 외부의 어떠한 프로세스도 들어갈 수 있으며 이 때 프로세스끼리 서로 방해하지 않는 것을 의미한다.</p>

<h1 id="경쟁-상태의-해결-방법">경쟁 상태의 해결 방법</h1>

<h2 id="뮤텍스">뮤텍스</h2>

<p>뮤텍스(mutex) 는 공유 자원을 lock() 을 통해 잠금 설정하고 사용한 후에, unlock() 을 통해 잠금해제한다.</p>

<p>이러한 객체 Lock 을 기반으로 경쟁 상태를 해결하는데, 잠금 상태가 되면 다른 프로세스나 스레드는 해당 코드 영역에 접근할 수 없고, 해제되면 가능하다.</p>

<p>한 번에 하나의 프로세스만 임계 영역에 있을 수 있다.</p>

<h2 id="세마포어">세마포어</h2>

<p>세마포어(semaphore) 는 일반화된 뮤텍스를 의미한다.</p>

<p>정수 S, Wait(), Signal() 을 통해서 공유 자원에 대한 접근을 처리한다. 이를 통해 여러 프로세스가 동시에 임계 영역에 접근할 수 있다.</p>

<ul>
  <li>S : 현재 쓸 수 있는 공유 자원의 수</li>
  <li>Wait() : S 를 1씩 감소 시킨다. 만약 S가 음수라면 공유 자원에 대한 접근은 못하고 블락된 채, 대기열로 들어간다.</li>
  <li>Signal() : S 를 1씩 증가 시킨다. 프로세스가 공유 자원 사용을 마친 상태이고, S 가 0 이하라면 대기열에 있던 프로세스가 동작하게 된다.</li>
</ul>

<h3 id="바이너리-세마포어">바이너리 세마포어</h3>

<p>바이너리 세마포어는 0과 1 두 가지 값만 가질 수 있는 세마포어이다.</p>

<p>구현의 유사성으로 인해 뮤텍스는 바이너리 세마포어와 유사하다고 할 수 있으나, 뮤텍스는 잠금을 기반으로 상호 배제가 일어나는 잠금 매커니즘이고, 세마포어는 신호를 기반으로 상호 배제가 일어나는 신호 매커니즘이다.</p>

<h3 id="카운팅-세마포어">카운팅 세마포어</h3>

<p>카운팅 세마포어는 S의 숫자가 1보다 큰, 세마포어를 의미한다.</p>

<h2 id="모니터">모니터</h2>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/5.png" alt="5" /><em>모니터</em></p>

<p>모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공하는 객체이다.</p>

<p>이를 통해 공유 자원에 대한 작업들을 순차적으로 처리한다.</p>

<h1 id="교착-상태">교착 상태</h1>

<p>교착상태(deadlock) 은 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말한다.</p>

<p>각각의 프로세스는 서로가 원하는 자원을 유지한 채, 다른 프로세스의 자원을 얻기를 기다린다.</p>

<p>교착상태가 발생하기 위한 4가지 필요조건은 다음과 같다.</p>

<ul>
  <li>상호 배제: 주어진 시간 내에 하나의 프로세스만 자원을 독점할 수 있다. 즉 다른 프로세스들은 접근이 불가능</li>
  <li>점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하며 대기하는 상태</li>
  <li>비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없다.</li>
  <li>환형 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황</li>
</ul>

<h2 id="해결-방법-1-bankers-algorithm">해결 방법 1. Banker’s Algorithm</h2>

<p>교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당가능 여부를 파악하는 ‘은행원 알고리즘(banker’s algorithm)’</p>

<p>은행원 알고리즘은 교착 상태를 회피하는 알고리즘으로, 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정, 불안정 상태로 나누고 안정 상태로 가도록 자원을 할당하는 알고리즘</p>

<p>안정 상태 : 교착 상태를 일으키지 않은 상태이며, 프로세스의 최대 자원 요구량을 운영체제가 충족시킬 수 있는 상태</p>

<p>불안정 상태 : 안전 상태로 가는 순서열이 존재하지 않는 상태</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/6.png" alt="6" /><em>은행원 알고리즘 예시1</em></p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/7.png" alt="7" /><em>은행원 알고리즘 예시1</em></p>

<h2 id="해결방법-2-3">해결방법 2, 3</h2>

<ul>
  <li>교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지우기</li>
  <li>해결 방법은 아니지만, 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 오히려 더 클 수도 있다. 따라서 교착 상태가 발생하면 사용자의 작업을 종료시켜버린다.</li>
</ul>

<h1 id="cpu-스케줄링-알고리즘">CPU 스케줄링 알고리즘</h1>

<p>스케줄링 알고리즘에는 선점형(preemptive) 알고리즘과, 비선점(non-preemtive)형 알고리즘이 있다.</p>

<p>중간에 인터럽트를 발생시켜서 강제적으로 컨텍스트 스위칭을 일으키는 것이 선점형알고리즘,</p>

<p>하나의 프로세스가 종료될 때 까지 대기하고 컨텍스트 스위칭을 일으키는 것이 비선점형 알고리즘이다.</p>

<h2 id="비선점형-알고리즘">비선점형 알고리즘</h2>

<h3 id="fcfsfirst-come-first-saved">FCFS(First Come, First Saved)</h3>

<p>가장 먼저 온 것을 가장 먼저 처리하는 알고리즘</p>

<p>길게 수행되는 프로세스 때문에 준비 큐에서 오래 기다리는 현상(convoy effect) 가 발생할 수 있다.</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/8.png" alt="8" /><em>FCFS 알고리즘 예시</em></p>

<p>p1 → p2 → p3 → p4</p>

<p>p1 이 버스트 타임이 길기 때문에 나머지가 오래 기다려야 한다.</p>

<h3 id="sjf-shortest-job-first">SJF (Shortest Job First)</h3>

<p>실행 시간이 가장 짧은 프로세스를 가장 먼저 실행하는 알고리즘.</p>

<p>긴 시간을 가진 프로세스가 실행되지 않는 현상(starvation) 이 일어날 수 있지만, <code class="language-plaintext highlighter-rouge">평균 대기 시간이 가장 짧다</code></p>

<p>하지만 실제로는 실행 시간을 알 수 없기 때문에 과거의 실행 정보를 토대로 추측해야한다.</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/9.png" alt="9" /><em>image.png</em></p>

<p>실행시간이 매우 긴 프로세스가 있으면 레디큐에서 계속 대기할 확률이 매우 높다.</p>

<h3 id="우선-순위-알고리즘">우선 순위 알고리즘</h3>

<p>오래된 작업일수록 우선순위를 높이는 방법(aging) 을 통해 SJF 의 단점을 보완한 알고리즘</p>

<p>우선순위는 작업의 시간, 프로세스의 메모리 요구사항, 열린 파일 수, 평균 CPU 사용량 등을 고려해서 설정</p>

<h2 id="선점형-알고리즘">선점형 알고리즘</h2>

<p>현대 운영체제가 쓰고 있는 방식으로, 지금 사용하고 있는 프로세스를 알고리즘에 의해 중단시키고 강제로 다른 프로세스에 CPU 소유권을 할당할 수 있는 방식</p>

<h3 id="라운드-로빈-rr-round-robin">라운드 로빈 (RR, Round Robin)</h3>

<p>현재 컴퓨터가 쓰는 스케쥴링 방법이자 단순한 선점형 알고리즘</p>

<p>각 프로세스에게 동일한 할당 시간을 주고, 그 시간 안에 끝나지 않으면 다시 준비 큐의 마지막으로 들어가는 알고리즘.</p>

<p>그런데 동일한 할당 시간을 q 라고 할 때, q 를 너무 크게 주면 사실 상 들어온 순서대로 프로세스를 진행하는 FCFS 가 되어버린다. 따라서 q 를 적절히 조절할 수 있어야 한다.</p>

<p>너무 작게 하면 컨텍스트 스위칭이 너무 많이 일어나면서 오버헤드가 과하게 생길 수 있다.</p>

<p>일반적으로 전체 작업 시간은 길어지지만, 평균 응답 시간은 짧아진다는 특징이 있다.</p>

<h3 id="srfshortest-remaining-time-first">SRF(Shortest Remaining Time First)</h3>

<p>SRF 는 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 즉시 중지하고 더 짧은 프로세스를 수행한다.</p>

<p>SJF 는 비선점형이기 때문에 해당 프로세스가 끝나야 그 다음 제일 짧은 프로세스를 수행하는 것과의 차이가 있다.</p>

<h3 id="다단계-큐">다단계 큐</h3>

<p>우선순위에 따른 준비 큐를 여러 개 사용하고, 큐 마다 라운드 로빈이나 FCFS 등 다른 스케쥴링 알고리즘을 적용한 것을 말한다.</p>

<p>큐 간의 프로세스 이동이 안되므로 스케줄링 부담이 적지만 유연성이 떨어지는 특징이 있다.</p>

<p>우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리 되지 않는 기아 현상(starvation) 이 발생할 수도 있다.</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/10.png" alt="10" /><em>image.png</em></p>

<h1 id="캐시">캐시</h1>

<p>데이터를 미리 복사해 놓는 임시 저장소이자, 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말한다. 이를 통해 데이터 접근 시간의 단축, 데이터를 다시 계산하는 등의 시간을 절약할 수 있다.</p>

<p>캐시의 예로 CPU 레지스터를 들 수 있다.</p>

<h2 id="캐시-설정-원리">캐시 설정 원리</h2>

<p>캐시를 설정할 때는 <code class="language-plaintext highlighter-rouge">자주 사용하는 데이터</code> 를 기반으로 설정해야 한다.</p>

<p>이 때 지역성을 기반으로 설정하게 되는데 지역성은 <code class="language-plaintext highlighter-rouge">시간 지역성</code> 과 <code class="language-plaintext highlighter-rouge">공간 지역성</code> 으로 나뉜다.</p>

<h3 id="시간-지역성">시간 지역성</h3>

<p>시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성</p>

<h3 id="공간-지역성">공간 지역성</h3>

<p>공간 지역성은 최근 접근한 데이터를 이루고 이쓴ㄴ 공간이나 그 가까운 공간에 접근하는 특성</p>

<h2 id="캐시-매핑">캐시 매핑</h2>

<p>캐시의 크기는 메모리보다 항상 작기 때문에 효율적으로 매핑하는 것이 중요하며 매핑 방식에는 직접 매핑, 연관 매핑, 집합 - 연관 매핑이 있다.</p>

<h3 id="직접-매핑direct-mapping">직접 매핑(direct mapping)</h3>

<p>직접 블록별로 매핑을 한다.</p>

<p>캐시가 다섯 블록이라면, 메모리를 5개의 영역으로 나누어서 각각의 영역당 하나의 캐시에 매핑 할 수 있도록 만든다.</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/11.png" alt="11" /><em>image.png</em></p>

<p>특정 라인과 특정 블록이 매핑되어 있는 것</p>

<p>메모리 블록의 사이즈는 메모리의 크기 / 캐시의 블록 개수</p>

<p>운영체제는 보통 메모리를 똑같은 크기의 페이지(보통 4kb)</p>

<p>4kb 인 이유? : <a href="https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80">https://velog.io/@dosadola/pintos-%EC%A4%91%EA%B0%84-%EB%B0%9C%ED%91%9C-%EC%99%9C-memory-block-%EC%9D%80-4kb%EC%9D%B8%EA%B0%80</a></p>

<ul>
  <li>
    <p>블록 당 영역이 정해져있기 때문에, 같은 블록에서 여러 개를 캐싱할 수 없다.</p>

    <p>따라서 같은 블록의 참조가 빈번하다면 계속 캐시를 스와핑해주어야 한다.</p>
  </li>
  <li>
    <p>대신 특정 정보의 캐시를 찾을 때 특정 블록만 찾으면 된다는 장점이 있다.</p>
  </li>
</ul>

<h3 id="연관-매핑associative-mapping">연관 매핑(associative mapping)</h3>

<p>순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑하며 메모리의 컨텐츠가 캐시의 어느 위치에도 올라갈 수 있는 방법(자유롭게 캐싱)</p>

<ul>
  <li>특정 정보의 캐시를 찾을 때, 모든 캐시를 탐색해야한다.</li>
  <li>그러나 스와핑이 빈번하게 일어나지는 않는다.</li>
</ul>

<h2 id="집합-연관-매핑set-associate-mapping">집합 연관 매핑(set associate mapping)</h2>

<p>집합을 나누고(집합 매핑과 유사) 해당 집합에는 block descriptor 만 같으면 들어올 수 있게 하는데, 이 때 어떤 블럭에도 들어갈 수 있게 한다.(연관 매핑과 유사)</p>

<p>즉 캐시의 집합을 나누었는데, 집합에 1개의 블록만 있다면 직접 매핑이고, 캐시 집합이 1개라면 연관 매핑인 것이다.</p>

<p>이를 통해 모든 블럭을 찾을 필요 없이, 특정 블럭을 찾게 해 탐색 비용을 낮춘 직접매핑의 장점과 스와핑을 완화시키는 연관매핑의 장점을 모두 지니게 된다.</p>

<h1 id="메모리-할당">메모리 할당</h1>

<p>프로그램에 필요한 메모리를 할당할 때 시작 메모리 위치, 메모리 할당 크기를 기반으로 할당하는데 이는 연속할당과 불연속 할당으로 나뉜다.</p>

<h2 id="연속-할당">연속 할당</h2>

<p>메모리에 연속적으로 공간을 할당하는 것. 사용 가능한 모든 메모리 공간이 같은 위치에 있다.</p>

<p>즉 메모리 파티션이 전체 메모리 공간에 분산되어 있지 않다.</p>

<p>이는 고정분할방식과 가변분할방식이 있다.</p>

<h3 id="고정-분할-방식">고정 분할 방식</h3>

<p>고정분할방식은 메모리를 미리 같은 크기로 분할해서 할당하는 방법.</p>

<p>고정 크기를 프로그램에 할당하므로, 프로그램의 크기보다 더 큰 메모리를 할당하게 된다.</p>

<p>따라서 내부 단편화(internal framentation)가 발생할 수 있다.</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/12.png" alt="12" /><em>image.png</em></p>

<h3 id="가변-분할-방식">가변 분할 방식</h3>

<p>가변분할방식은 프로그램에 필요한 만큼 동적으로 할당하는 방법.</p>

<p>내부 단편화가 아닌 외부 단편화가 발생할 수 있다.</p>

<p><img src="/upload/2025-02-04-운영체제(페이징,_캐시,_자원_경쟁).md/13.png" alt="13" /><em>image.png</em></p>

<p>가변 분할 방식에는 최초 적합, 최적 적합, 최악 적합이 있다.</p>

<p>홀(hole) : 할당할 수 있는, 비어 있는 메모리 공간</p>

<ul>
  <li>최초 적합(frist fit) : 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당</li>
  <li>최적 적합(best fit) : 필요한 메모리 크기 이상인 공간 중에서 가장 작은 홀에 할당</li>
  <li>최악 적합(worst fit) : 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당</li>
</ul>

<h2 id="불연속-할당">불연속 할당</h2>

<p>메모리를 연속적으로 할당하지 않는 방법으로, 현대 운영체제가 쓰는 방법.</p>

<p>프로그램에 필요한 메모리를 쪼개어 서로 다른 위치에 있는 메모리 공간에 할당</p>

<p>페이징, 세그멘테이션, 페이지드 세그멘테이션 기법이 있다.</p>

<h3 id="페이징">페이징</h3>

<p>페이징은 동일한 크기의 페이지 단위(보통 4kb)로 나누어 메모리의 서로 다른 위치에 프로세스를 할당</p>

<p>홀의 크기가 균일하지 않은 문제는 없어지지만 주소 변환을 페이지별로 해야 하기 때문에 주소 변환이 복잡해지는 단점이 있다.</p>

<p>외부 단편화가 생겨도 분할해서 할당할 수 있기 때문에, 외부 단편화를 해결할 수 있다.</p>

<p>그렇지만 결국 동일한 크기의 페이지 단위로 나눈다는 것은 언제나 내부 단편화를 유발할 수 있다.</p>

<h3 id="세그멘테이션">세그멘테이션</h3>

<p>페이지 단위가 아닌, 의미 단위인 세그먼트로 나누는 방식(즉, 동일한 크기가 아닐 수 있다.)</p>

<p>프로세스는 코드, 데이터, 스택, 힙으로 나누어져서 메모리가 할당되는데 코드와 데이터, 또는 코드와 스택 등으로 나눌 수도 있으며 함수 단위로도 나눌 수 있다.</p>

<p>공유와 보안 측면에서 좋지만 홀 크기가 균일하지 않게 된다.</p>

<p>내부 단편화는 해결될 수 있지만, 다시 외부 단편화가 일어날 수 있다.</p>

<h3 id="페이지드-세그멘테이션">페이지드 세그멘테이션</h3>

<p>세그멘테이션으로 나누되, 해당 세그멘테이션을 동일한 크기의 페이지로 나누는 방법</p>

<p>세그먼트에 의해 1kb, 5kb 로 나뉘었다면 이를 2kb 기준으로 나누어 2kb, (2kb, 2kb, 2kb) 로 나누는 방식</p>

<h1 id="busy-wait">busy wait</h1>

<p>busy wait 는 프로세스, 스레드가 어떠한 일을 실행하기 전에 만족하는 조건을 지속적으로 확인하는 동기화 기술이다.</p>

<p>프로세스1이 점유하고 있는 자원을, 프로세스 2가 사용하고 싶을 때 blocking 되고 대기하는 과정이다.</p>

<h1 id="운영체제와-펌웨어의-차이">운영체제와 펌웨어의 차이</h1>

<ul>
  <li>펌웨어는 ROM 이라고 불리는 비휘발성 메모리 하나를 쓰는 반면, 운영체제는 휘발성 비휘발성 메모리를 계층화해서 사용한다.</li>
  <li>펌웨어는 자유롭게 프로그램을 설치할 수 없으며, 미리 설치해놓은 프로그램을 기반으로 업데이트가 일어난다.
ROM 에 해당 소프트웨어를 지우고 덮어쓰면서 업데이트가 발생. → 멱등성처럼 변화를 최소화 하는 느낌인거 같다
반면, 운영체제는 정기적으로 업데이트 되며 프로그램을 자유롭게 설치할 수 있다.</li>
</ul>

            </div>
        </section>

        <!-- Email subscribe form at the bottom of the page -->
        
        <section class="subscribe-form">
            <h3 class="subscribe-form-title">Subscribe to hoeeeeeh</h3>
            <p>Get the latest posts delivered right to your inbox</p>
            <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

        </section>
        

        <footer class="post-full-footer">
            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
            
            
            <!-- /author  -->
        </footer>

        <!-- If you use Disqus comments, just uncomment this block.
        The only thing you need to change is "test-apkdzgmqhj" - which
        should be replaced with your own Disqus site-id. -->
        

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            
            
            
            
            
        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://hoeeeeeh.github.io/">
            
                <img src="/assets/images/favicon.png" alt="hoeeeeeh icon" />
            
            <span>hoeeeeeh</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">운영체제(페이징, 캐시, 자원 경쟁)</div>
    <div class="floating-header-share">
        <!-- Sidebar Toggle Button -->
        <button class="toc-toggle" id="toc-toggle">☰ 목차</button>

        <!-- Table of Contents Sidebar -->
        <aside class="toc" id="toc-sidebar">
            <nav>
                <ul><li><a href="#pcb-와-컨텍스트-스위칭">PCB 와 컨텍스트 스위칭</a><ul><li><a href="#유저-메모리-커널-메모리">유저 메모리, 커널 메모리</a></li></ul></li><li><a href="#pcb의-구조">PCB의 구조</a></li><li><a href="#컨텍스트-스위칭">컨텍스트 스위칭</a><ul><li><a href="#컨텍스트-스위칭의-비용">컨텍스트 스위칭의 비용</a></li></ul></li><li><a href="#프로세스의-상태">프로세스의 상태</a><ul><li><a href="#create">CREATE</a></li><li><a href="#ready">Ready</a></li><li><a href="#ready-suspend">Ready Suspend</a></li><li><a href="#running">Running</a></li><li><a href="#blocked">Blocked</a></li><li><a href="#blocked-suspend">Blocked Suspend</a></li><li><a href="#terminated--exit">Terminated / Exit</a></li></ul></li><li><a href="#브라우저">브라우저</a><ul><li><a href="#멀티-프로세싱">멀티 프로세싱</a></li><li><a href="#멀티-스레딩">멀티 스레딩</a></li></ul></li><li><a href="#ipc">IPC</a><ul><li><a href="#공유-메모리">공유 메모리</a></li><li><a href="#파일">파일</a></li><li><a href="#파이프">파이프</a><ul><li><a href="#unnamed-pipe-익명-파이프">(Unnamed Pipe) 익명 파이프</a></li><li><a href="#named-pipe-명명-파이프">Named Pipe (명명 파이프)</a></li></ul></li><li><a href="#메세지-큐">메세지 큐</a></li></ul></li><li><a href="#자원-경쟁">자원 경쟁</a><ul><li><a href="#공유자원">공유자원</a></li><li><a href="#경쟁-상태">경쟁 상태</a></li><li><a href="#임계-영역">임계 영역</a></li><li><a href="#경쟁-상태-관리의-중요성">경쟁 상태 관리의 중요성</a><ul><li><a href="#데이터-정합성">데이터 정합성</a></li><li><a href="#데이터-무결성">데이터 무결성</a></li></ul></li></ul></li><li><a href="#경쟁-상태의-해결-조건">경쟁 상태의 해결 조건</a><ul><li><a href="#상호-배제">상호 배제</a></li><li><a href="#한정-대기">한정 대기</a></li><li><a href="#진행의-융통성">진행의 융통성</a></li></ul></li><li><a href="#경쟁-상태의-해결-방법">경쟁 상태의 해결 방법</a><ul><li><a href="#뮤텍스">뮤텍스</a></li><li><a href="#세마포어">세마포어</a><ul><li><a href="#바이너리-세마포어">바이너리 세마포어</a></li><li><a href="#카운팅-세마포어">카운팅 세마포어</a></li></ul></li><li><a href="#모니터">모니터</a></li></ul></li><li><a href="#교착-상태">교착 상태</a><ul><li><a href="#해결-방법-1-bankers-algorithm">해결 방법 1. Banker’s Algorithm</a></li><li><a href="#해결방법-2-3">해결방법 2, 3</a></li></ul></li><li><a href="#cpu-스케줄링-알고리즘">CPU 스케줄링 알고리즘</a><ul><li><a href="#비선점형-알고리즘">비선점형 알고리즘</a><ul><li><a href="#fcfsfirst-come-first-saved">FCFS(First Come, First Saved)</a></li><li><a href="#sjf-shortest-job-first">SJF (Shortest Job First)</a></li><li><a href="#우선-순위-알고리즘">우선 순위 알고리즘</a></li></ul></li><li><a href="#선점형-알고리즘">선점형 알고리즘</a><ul><li><a href="#라운드-로빈-rr-round-robin">라운드 로빈 (RR, Round Robin)</a></li><li><a href="#srfshortest-remaining-time-first">SRF(Shortest Remaining Time First)</a></li><li><a href="#다단계-큐">다단계 큐</a></li></ul></li></ul></li><li><a href="#캐시">캐시</a><ul><li><a href="#캐시-설정-원리">캐시 설정 원리</a><ul><li><a href="#시간-지역성">시간 지역성</a></li><li><a href="#공간-지역성">공간 지역성</a></li></ul></li><li><a href="#캐시-매핑">캐시 매핑</a><ul><li><a href="#직접-매핑direct-mapping">직접 매핑(direct mapping)</a></li><li><a href="#연관-매핑associative-mapping">연관 매핑(associative mapping)</a></li></ul></li><li><a href="#집합-연관-매핑set-associate-mapping">집합 연관 매핑(set associate mapping)</a></li></ul></li><li><a href="#메모리-할당">메모리 할당</a><ul><li><a href="#연속-할당">연속 할당</a><ul><li><a href="#고정-분할-방식">고정 분할 방식</a></li><li><a href="#가변-분할-방식">가변 분할 방식</a></li></ul></li><li><a href="#불연속-할당">불연속 할당</a><ul><li><a href="#페이징">페이징</a></li><li><a href="#세그멘테이션">세그멘테이션</a></li><li><a href="#페이지드-세그멘테이션">페이지드 세그멘테이션</a></li></ul></li></ul></li><li><a href="#busy-wait">busy wait</a></li><li><a href="#운영체제와-펌웨어의-차이">운영체제와 펌웨어의 차이</a></li></ul>

            </nav>
        </aside>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://hoeeeeeh.github.io/">hoeeeeeh</a> &copy; 2025</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/ghost" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/tryghost" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                    <img class="subscribe-overlay-logo" src="/assets/images/blog-icon.png" alt="hoeeeeeh" />
                
                <h1 class="subscribe-overlay-title">Subscribe to hoeeeeeh</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

            </div>
        </div>
    


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G9Z64HV3NB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-G9Z64HV3NB');
</script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
