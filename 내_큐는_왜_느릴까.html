<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <!-- 필요한 언어 모듈(typescript 등) 추가 로드 -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/typescript.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/java.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>

    <!-- Highlight.js 초기화 -->
    <script>
        (function () {
            function normalizeFenceLanguage(block) {
                var text = block.textContent || '';
                if (!text) return;
                var lines = text.split('\n');
                if (!lines.length) return;
                var firstLine = (lines[0] || '').trim().toLowerCase();
                if (!firstLine) return;

                var aliasMap = {
                    ts: 'typescript',
                    typescript: 'typescript',
                    tsx: 'typescript',
                    js: 'javascript',
                    javascript: 'javascript',
                    jsx: 'javascript',
                    sh: 'bash',
                    zsh: 'bash',
                    bash: 'bash',
                    yml: 'yaml',
                    yaml: 'yaml',
                    py: 'python',
                    python: 'python',
                    rb: 'ruby',
                    ruby: 'ruby',
                    c: 'c',
                    cpp: 'cpp',
                    cplusplus: 'cpp',
                    cs: 'csharp',
                    csharp: 'csharp',
                    go: 'go',
                    golang: 'go',
                    rs: 'rust',
                    rust: 'rust',
                    java: 'java',
                    kotlin: 'kotlin',
                    swift: 'swift',
                    php: 'php',
                    html: 'xml',
                    xml: 'xml',
                    json: 'json',
                    css: 'css',
                    scss: 'scss',
                    less: 'less',
                    sql: 'sql',
                    dockerfile: 'dockerfile',
                    makefile: 'makefile',
                    diff: 'diff',
                    bashrc: 'bash',
                    zshrc: 'bash'
                };

                var known = new Set(Object.keys(aliasMap));
                var lang = aliasMap[firstLine] || (known.has(firstLine) ? firstLine : null);
                if (!lang) return;

                // 언어명이 첫 줄에 있으면 제거하고 language- 클래스 부여
                block.textContent = lines.slice(1).join('\n');
                // 기존 language-* / highlighter-rouge 제거
                var classes = Array.prototype.slice.call(block.classList);
                classes.forEach(function (cls) {
                    if (/^language-/.test(cls) || cls === 'highlighter-rouge') {
                        block.classList.remove(cls);
                    }
                });
                block.classList.add('language-' + lang);
            }

            window.__applyLanguageHeader = function () {
                var blocks = document.querySelectorAll('pre code');
                Array.prototype.forEach.call(blocks, function (block) {
                    var hasLanguage = /\blanguage-/.test(block.className);
                    var isPlaintext = /\blanguage-(plain|plaintext|text)\b/.test(block.className);
                    // plaintext이거나 언어 미지정이면 첫 줄 언어 감지 시도
                    if (!hasLanguage || isPlaintext) {
                        normalizeFenceLanguage(block);
                    }
                    if (window.hljs && typeof hljs.highlightBlock === 'function') {
                        hljs.highlightBlock(block);
                    }
                });
            };
        })();
    </script>
    <style>.hljs { background: none; }</style>
    <style>
        /* Rouge 기본 테마가 배경을 어둡게 만드는 문제를 무력화 */
        .highlighter-rouge .highlight pre { background: none !important; }
        .highlighter-rouge .highlight pre,
        .highlighter-rouge .highlight code { color: inherit !important; }
    </style>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
            src="https://code.jquery.com/jquery-3.2.1.min.js"
            integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
            crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <!--    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>-->

    <!-- Prism.js 기본 라이브러리 먼저 로드 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
        (function () {
            // pre만 있고 code가 없는 경우까지 포함해서 처리
            function collectBlocks() {
                var result = [];
                var pres = document.querySelectorAll('pre');
                Array.prototype.forEach.call(pres, function (pre) {
                    var code = pre.querySelector('code');
                    result.push(code || pre);
                });
                return result;
            }
            if (window.__applyLanguageHeader) {
                window.__applyLanguageHeader();
            }
            // 하이라이트 누락 케이스를 한 번 더 커버
            var blocks = collectBlocks();
            Array.prototype.forEach.call(blocks, function (block) {
                if (window.hljs && typeof hljs.highlightBlock === 'function') {
                    hljs.highlightBlock(block);
                }
            });
        })();
    });</script>


    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>내 큐는 왜 느릴까</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="HOEH 개발 블로그" />
<link rel="shortcut icon" href="https://hoeeeeeh.github.io//assets/images/favicon.png" type="image/png" />
<link rel="canonical" href="https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="hoeeeeeh" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="내 큐는 왜 느릴까" />
    <meta property="og:description" content="자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다. 일반적인 배열의 shift 메서드는 배열의 맨 앞 원소를 반환하지만 결국 마지막 원소까지 전부 shift 시켜야하기 때문에 O(1) 가 아닌 O(N) 이 소모된다. 그래서 아주 간단하게 큐를 작성해보면, 아래와 같이 생각해볼 수 있을 것 같다. 객체로 간단하게 큐 구현해보기" />
    <meta property="og:url" content="https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C" />
    <meta property="og:image" content="https://hoeeeeeh.github.io/assets/images/cover/javascript.png" />
    <meta property="article:publisher" content="https://www.facebook.com/ghost" />
    <meta property="article:author" content="https://www.facebook.com/ghost" />
    <meta property="article:published_time" content="2025-09-05T07:50:00+00:00" />
    <meta property="article:modified_time" content="2025-09-05T07:50:00+00:00" />
    <meta property="article:tag" content="Javascript" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="내 큐는 왜 느릴까" />
    <meta name="twitter:description" content="자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다. 일반적인 배열의 shift 메서드는 배열의 맨 앞 원소를 반환하지만 결국 마지막 원소까지 전부 shift 시켜야하기 때문에 O(1) 가 아닌 O(N) 이 소모된다. 그래서 아주 간단하게 큐를 작성해보면, 아래와 같이 생각해볼 수 있을 것 같다. 객체로 간단하게 큐 구현해보기" />
    <meta name="twitter:url" content="https://hoeeeeeh.github.io/" />
    <meta name="twitter:image" content="https://hoeeeeeh.github.io/assets/images/cover/javascript.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="hoeeeeeh" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Javascript" />
    <meta name="twitter:site" content="@tryghost" />
    <meta name="twitter:creator" content="@tryghost" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "hoeeeeeh",
        "logo": "https://hoeeeeeh.github.io/assets/images/blog-icon.png"
    },
    "url": "https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C",
    "image": {
        "@type": "ImageObject",
        "url": "https://hoeeeeeh.github.io/assets/images/cover/javascript.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://hoeeeeeh.github.io/%EB%82%B4_%ED%81%90%EB%8A%94_%EC%99%9C_%EB%8A%90%EB%A6%B4%EA%B9%8C"
    },
    "description": "자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다. 일반적인 배열의 shift 메서드는 배열의 맨 앞 원소를 반환하지만 결국 마지막 원소까지 전부 shift 시켜야하기 때문에 O(1) 가 아닌 O(N) 이 소모된다. 그래서 아주 간단하게 큐를 작성해보면, 아래와 같이 생각해볼 수 있을 것 같다. 객체로 간단하게 큐 구현해보기"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="내 큐는 왜 느릴까" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<script>
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('toc-toggle').addEventListener('click', function() {
            document.getElementById('toc-sidebar').classList.toggle('active');
        });

        document.querySelectorAll('.toc ul li a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                const targetPosition = target.getBoundingClientRect().top + window.scrollY; // 정확한 절대 위치
                window.scrollTo({
                    top: targetPosition - 60, // 네비게이션 바 고려
                    behavior: 'smooth'
                });
            });
        });

        const tocContainer = document.querySelector('.toc'); // 목차 컨테이너
        const links = document.querySelectorAll('.toc a'); // 목차의 링크
        const sections = Array.from(links).map(link =>
            document.querySelector(link.getAttribute('href'))
        );

        // 쓰로틀링 함수 정의
        const throttle = (callback, limit) => {
            let waiting = false;
            return (...args) => {
                if (!waiting) {
                    callback(...args);
                    waiting = true;
                    setTimeout(() => (waiting = false), limit);
                }
            };
        };

        // 디바운싱 함수 정의
        const debounce = (callback, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => callback(...args), delay);
            };
        };

        // 목차 업데이트 함수
        const updateToc = () => {
            const scrollPosition = window.scrollY + 60; // 상단 바 높이 고려

            sections.forEach((section, index) => {
                const sectionTop = section.getBoundingClientRect().top + window.scrollY;
                const sectionBottom = sectionTop + section.offsetHeight;

                if (scrollPosition >= sectionTop && scrollPosition < sectionBottom) {
                    // 기존 active 제거
                    links.forEach(link => link.classList.remove('active'));

                    // 현재 active 추가
                    const activeLink = links[index];
                    activeLink.classList.add('active');

                    // 목차 컨테이너 스크롤
                    tocContainer.scrollTo({
                        top: activeLink.offsetTop - tocContainer.offsetHeight / 2,
                        behavior: 'smooth',
                    });
                }
            });
        };

        // 쓰로틀링 및 디바운싱 적용
        const optimizedScrollHandler = throttle(updateToc, 100); // 100ms마다 실행 제한
        const debouncedResizeHandler = debounce(updateToc, 50); // 리사이즈 후 200ms 후 실행

        // 스크롤 및 리사이즈 이벤트
        window.addEventListener('scroll', optimizedScrollHandler);
        window.addEventListener('resize', debouncedResizeHandler); // 창 크기 변경 시 위치 보정

    });


</script>


<style>
    /* 기본적으로 사이드바 숨기기 */

    html {
        scroll-padding-top: 60px;
    }

    .toc {
        position: fixed;
        top: 0;
        right: -240px; /* 사이드바 기본 위치 */
        width: 240px;
        height: 70vh;
        background-color: transparent;
        overflow-y: auto;
        padding: 2rem;
        transition: right 0.3s ease-in-out;
        margin-top: 60px;
    }

    .toc-toggle {
        border-radius: 25px;
    }

    .toc a.active {
        color: #e6369b; /* 활성화된 목차 색깔 */
        font-weight: bold;
    }

    /* 사이드바가 활성화되면 보이도록 */
    .toc.active {
        right: 0;
    }

    /* 목차 목록 스타일 */
    .toc ul {
        list-style-type: none;
        padding: 0;
    }

    .toc ul li {
        margin-bottom: 0.5rem;
        padding-left: 1.5rem;
        font-size: 98%;
    }

    .toc ul li a {
        text-decoration: none;
        color: #858181;
        font-weight: bold;
        display: inline-block;
    }

    .toc ul li a:hover {
        color: #007bff;
    }

    /* 버튼 스타일 */
    .toc-toggle {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: #007bff;
        color: white;
        border: none;
        padding: 10px;
        font-size: 16px;
        cursor: pointer;
        z-index: 1000;
    }

    .toc-toggle:hover {
        background-color: #0056b3;
    }

</style>

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://hoeeeeeh.github.io/"><img src="/assets/images/blog-icon.png" alt="hoeeeeeh" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="https://github.com/hoeeeeeh">GitHub</a></li>
    <li class="nav-portfolio" role="menuitem"><a href="https://hoeeeeeh.github.io/portfolio/index.html">Portfolio</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <li>
            <script src="https://hoeeeeeh.github.io/assets/js/lunr.js" charset="utf-8"></script>


<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form class="bd-search" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <input type="text" class="form-control text-small launch-modal-search" id="lunrsearch" name="q" maxlength="255" value="" placeholder="포스트 검색"/>
</form>

<div id="lunrsearchresults">
    <ul></ul>
</div>

<script src="https://hoeeeeeh.github.io/assets/js/lunrsearchengine.js" charset="utf-8"></script>

        </li>
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-javascript post ">
        <header class="post-full-header">
            <section class="post-full-meta">
                <time class="post-full-meta-date" datetime=" 5 September 2025"> 5 September 2025</time>
                
                <span class="date-divider">/</span>
                
                
                <a href='/tag/javascript/'>JAVASCRIPT</a>
                
                
                
            </section>
            <h1 class="post-full-title">내 큐는 왜 느릴까</h1>
        </header>

        
        <figure class="post-full-image" style="background-image: url(/assets/images/cover/javascript.png)">
        </figure>
        

        <section class="post-full-content">
            <div class="kg-card-markdown">
                <p>자바스크립트는 내장되어있는 큐가 없다보니 코딩테스트에서 시간 복잡도를 빠르게 하려면 큐를 직접 구현해야한다.</p>

<p>일반적인 배열의 shift 메서드는 배열의 맨 앞 원소를 반환하지만 결국 마지막 원소까지 전부 shift 시켜야하기 때문에 O(1) 가 아닌 O(N) 이 소모된다.</p>

<p>그래서 아주 간단하게 큐를 작성해보면, 아래와 같이 생각해볼 수 있을 것 같다.</p>

<h1 id="객체로-간단하게-큐-구현해보기">객체로 간단하게 큐 구현해보기</h1>

<p>정확히는 앞이나 뒤에서 모두 원소를 O(1) 로 꺼낼 수 있는 deque 인데,</p>

<p>간단하게 items 라는 객체에서 left, right 인덱스를 통해 바로 접근할 수 있도록 하는 것이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
class Queue {
    left = 0;
    right = 0;
    items = {};
    
    dequeue() {
        if(this.isEmpty()) {
            return null;
        }
        
        const result = this.items[this.left];
        delete this.items[this.left];
        this.left += 1;
        
        this.clean();
        
        return result;
    }
    
    isEmpty() {
        return this.left === this.right;
    }
    
    peek() {
        if(this.isEmpty()) {
            return null;
        }
        return this.items[this.left];
    }
    
    last() {
        if(this.isEmpty()) {
            return null;
        }
        return this.items[this.right - 1];
    }
    
    enqueue(value) {
        this.items[this.right] = value;
        this.right += 1;
    }
    
    
    pop() {
        if(this.isEmpty()) {
            return null;
        }
        
        this.right -= 1;
        
        const result = this.items[this.right];
        delete this.items[this.right];
        
        this.clean();
        
        return result;
    }
    
    clean() {
        if(this.left === this.right) {
            this.left = 0;
            this.right = 0;
        }
    }
}

</code></pre></div></div>

<h2 id="dequeue-delete">Dequeue, delete</h2>

<p>여기서 <code class="language-plaintext highlighter-rouge">dequeue</code>  메서드를 살펴보면, <code class="language-plaintext highlighter-rouge">delete this.items[this.left]</code> 를 통해서 items 객체에서 제거하고 있다.</p>

<p>delete 하는 이유는 당연하게도 메모리를 아끼기 위해서였다. 그리고 delete 하는데 O(1) 밖에 걸리지 않기 때문에 그렇게 큰 문제가 생기지 않을 것이라고 생각했었는데, 뒤에서 이야기하겠지만 굉장히 큰 실수였다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
dequeue() {
    if(this.isEmpty()) {
        return null;
    }
        
    const result = this.items[this.left];
    delete this.items[this.left];
    this.left += 1;
        
    this.clean();
        
    return result;
}

</code></pre></div></div>

<p>이러한 점이 왜 잘못되었는지 알려면 우리가 쓰고 있는 node.js 의 엔진에 대해서 알아봐야한다.</p>

<h1 id="v8">V8</h1>

<h2 id="turbofan-ignition">TurboFan, Ignition</h2>

<p>node.js 의 내부 엔진인 V8 은 우리가 작성한 코드를 내부적으로 최적화하는, 2단계의 실행 파이프라인을 사용한다.</p>

<ul>
  <li>Ignition (바이트코드 인터프리터) : 코드를 빠르게 실행하면서 객체가 어떤 모양과 타입을 가지는지(타입 피드백) 등을 수집</li>
  <li>TurboFan (최적화 JIT 컴파일러) : Hot(자주 실행되는) 한 함수들을 최적화한 기계어 코드를 생성. 여기서 TurboFan 은 Ignition 에서 얻은 피드백 등을 사용하여 코드를 최적화한다.</li>
</ul>

<p><img src="/upload/2025-09-05-내_큐는_왜_느릴까.md/0.png" alt="0" /><em>89549.png</em></p>

<p>이렇게 <code class="language-plaintext highlighter-rouge">피드백</code> 을 통해 코드를 최적화하기 때문에 V8 은 자바스크립트 코드를 훨씬 더 빠르게 실행할 수 있다. 반면, 함수가 너무 복잡하게 <code class="language-plaintext highlighter-rouge">폴리모픽</code>(Polymorphic, 다양한 형태를 가진, 즉 예측 하기 힘든) 한 경우에는 코드를 최적화하기 어렵다. 따라서 아예 최적화된 코드가 없거나 최적화된 코드에서 실행이 불가능해서 최적화되지 않은 코드로 실행되는(’탈출’ 혹은 deoptimize 라고 부르는듯 하다) 경우가 많다.</p>

<p>폴리모픽의 예시를 보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
    1 function getX(obj) {
    2   return obj.x; // 이 부분이 폴리모픽 상태가 됨
    3 }
    4 
    5 const obj1 = { x: 1, y: 2 }; // Shape A
    6 const obj2 = { x: 3, z: 4 }; // Shape B (y 대신 z)
    7 
    8 // getX는 Shape A와 Shape B, 두 가지 형태의 객체를 받음
    9 getX(obj1);
   10 getX(obj2);

</code></pre></div></div>

<p>obj1 은 x, y 프로퍼티를 가지고 있고, obj2 는 x, z 프로퍼티를 가지고 있다.</p>

<p>따라서 Shape A (x, y 프로퍼티), Shape B (x, z 프로퍼티) 2가지가 존재하고, getX 는 2가지의 형태를 받을 수 있다.</p>

<p>obj.x 부분은 Shape A 가 들어올지, Shape B 가 들어올지에 따라 각각 최적화된 코드로 넘어갈 수 있다.</p>

<p>위의 경우에는 어느정도 최적화를 하는데 큰 문제가 없지만 조금 더 복잡한 상황이면 (보통 4개 이상?) 최적화 하기가 힘들어진다.</p>

<p>이런 경우를 <code class="language-plaintext highlighter-rouge">메가모픽</code>이라고 부르는 듯 하다.</p>

<p>반대로 하나의 Shape 으로 고정되면 <code class="language-plaintext highlighter-rouge">모노모픽</code> 이라고 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
    1 function getX(obj) {
    2   return obj.x; // 이 부분이 메가모픽 상태가 됨
    3 }
    4 
    5 // 매번 다른 Shape의 객체를 생성하여 함수 호출
    6 for (let i = 0; i &lt; 10; i++) {
    7   let obj = { x: i };
    8   if (i % 2 === 0) obj.a = 1;
    9   if (i % 3 === 0) obj.b = 1;
   10   if (i % 4 === 0) obj.c = 1;
   11   // ... 이런 식으로 계속 다른 Shape가 만들어짐
   12   getX(obj);
   13 }

</code></pre></div></div>

<p>이렇게 모노모픽, 혹은 적당한 수준의 폴리모픽은 V8 의 인라인 캐시를 통해 최적화된 코드를 만들고 빠른 경로를 미리 만들어둔다.</p>

<p>최적화된 코드에서는 런타임에 객체의 히든 클래스를 검사하는 가드가 포함되고, 일치하지 않는다면 디옵트(탈출, 인터프리터로 실행) 된다.</p>

<h2 id="hidden-class-shape">Hidden Class (Shape)</h2>

<p>자바스크립트는 동적 언어이지만, V8 은 내부적으로 객체에 구조를 부여하기 위해 히든 클래스라는 것을 사용한다. 히든 클래스는 어떤 프로퍼티가 있고, 메모리 어디에 저장되는지 등을 나타내는 내부 디스크립터다.</p>

<p>코드로 간단하게 살펴보면,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
let o = {};
o.a = "foo";
o.b = "bar";
o.c = "baz";

</code></pre></div></div>

<p><img src="/upload/2025-09-05-내_큐는_왜_느릴까.md/1.png" alt="1" /><em>31421.png</em></p>

<p>이렇게 o.a → o.b → o.c 순으로 프로퍼티를 추가했으면 위의 이미지처럼 a → b → c 순으로 디스크립터가 추가되면서 히든 클래스가 만들어진다.</p>

<h3 id="히든-클래스는-offset-을-저장한다">히든 클래스는 Offset 을 저장한다.</h3>

<p>여기서 주의할 점은 “순서” 이다.</p>

<p>a → b → c 순으로 프로퍼티를 추가한 객체와, c → b → a 순서로 프로퍼티를 추가한 객체는 서로 다른 히든 클래스를 갖는다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
let o = {};
o.a = "foo";
o.b = "bar";
o.c = "baz";

let x = {};
x.c = "baz";
x.b = "bar";
x.a = "foo";

</code></pre></div></div>

<p>o 와 x 는 결국 a,b,c 의 프로퍼티를 갖겠지만 서로 다른 히든 클래스를 갖는다. 프로퍼티가 추가될 때마다 새로운 히든 클래스를 만들게 되는데, 그 이유는 <code class="language-plaintext highlighter-rouge">프로퍼티가 메모리 어디에 저장되어 있는지를 저장하는 오프셋</code> 을 저장하기 때문이다.</p>

<p>프로퍼티를 추가할 때를 기준으로 offset 이 정해지는데, a → b → c 순으로 정하는 offset 은 당연히 c → b → a 순으로 정하는 offset 과 다르다.</p>

<p>이렇게 offset 을 가지고 특정 프로퍼티에 빠르게 접근이 가능하기 때문에 히든 클래스가 중요한 것이고, 히든 클래스에 순서가 영향을 미치는 이유이다.</p>

<p>히든클래스를 통해 V8 은 매번 딕셔너리에서 프로퍼티를 찾는 대신, 고정 오프셋을 사용해서 프로퍼티에 접근할 수 있다.</p>

<p>o.a, o.b, o.c 처럼 a b c 의 해시값을 딕셔너리에서 검색할 필요가 없이 오프셋을 통해 바로 접근할 수 있게 되는 것이다. (C++ 의 구조체처럼)</p>

<p>따라서 프로퍼티의 생성 순서와 일관성이 중요하다. 일관된 shape 는 성능에 영향을 줄 수 있다.</p>

<h3 id="딕셔너리-모드">딕셔너리 모드</h3>

<p>히든클래스로 프로퍼티의 오프셋을 저장하고 프로퍼티가 추가될 때마다 새로운 히든 클래스로 “전이” 되다가 너무 비효율적이게 되면 해당 객체를 딕셔너리 모드로 전환한다고 한다. 이렇게 딕셔너리 모드로 전환되면 해시 테이블(딕셔너리)에 프로퍼티를 저장하게 되기 때문에 프로퍼티의 추가, 삭제는 유연해진다. 대신 당연히 모든 프로퍼티로의 접근이 느려진다. (인라인 캐시와 고정 오프셋을 사용하지 못하기 때문)</p>

<p>여기서 딕셔너리 모드로 전환되는 일반적인 방법이 바로 <code class="language-plaintext highlighter-rouge">delete</code> 이다. delete 를 사용하는 경우 V8 은 이 객체가 고정된 구조(모노모픽처럼) 라고 생각하기 보단 동적으로 사용된다고 판단하여 딕셔너리 모드로 들어가게 된다. 결국 여기서 고려해볼수 있는 점은, 속도와 메모리효율의 트레이드오프이다. delete 를 사용하는 대신 null 이나 undefined 로 바꿈으로써 딕셔너리 모드로 전환되는 것을 막을 수 있지만 그만큼 메모리는 지속적으로 사용될 것이다.</p>

<h2 id="elements-kind">Elements Kind</h2>

<p>자바스크립트에서 배열도 사실 그냥 객체이다. arr[0] 은 키가 0 인 프로퍼티일 뿐이다. 하지만 V8 은 배열에 대해서 조금 더 특별하게 최적화 한다. 정확히는 배열이라고 전부 다 동일하게 최적화하는건 아니고, 규칙성에 맞게 최적화를 한다.</p>

<p>아래에서 볼, 객체가 가지는 원소의 타입에 맞게 최적화된다. (= Elements Kind 에 맞게 최적화)</p>

<p><a href="https://source.chromium.org/chromium/v8/v8.git/+/ec37390b2ba2b4051f46f153a8cc179ed4656f5d:src/elements-kind.h;l=14">전체 Elements Kind</a></p>

<h3 id="타입이-달라지면">타입이 달라지면</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
const array = [1, 2, 3];
// elements kind: PACKED_SMI_ELEMENTS
array.push(4.56);
// elements kind: PACKED_DOUBLE_ELEMENTS

</code></pre></div></div>

<p>엔진의 레벨에서 바라보면, array = [1, 2, 3] 의 경우는 PACKED_SMI_ELEMENTS 로 판별한다. 여기서 SMI 는 Small Integer 이다.</p>

<p>그런데 array.push(4.56) 을 하고 나면 PACKED_DOUBLE_ELEMENTS 로 바뀐다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
array.push('x');
// elements kind: PACKED_ELEMENTS

</code></pre></div></div>

<p>마지막으로 문자열을 넣으면, PACKED_ELEMENTS 로 바뀐다.</p>

<h2 id="holey">Holey</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
const array = [1, 2, 3, 4.56, 'x'];
// elements kind: PACKED_ELEMENTS
array.length; // 5
array[9] = 1; // array[5] until array[8] are now holes
// elements kind: HOLEY_ELEMENTS

</code></pre></div></div>

<p>length 가 5인 배열에, 갑자기 9번째 인덱스에 1을 넣고 있다. 이 경우에는 array[5] ~ array[8] 까지 구멍이 생긴다.</p>

<p>이러면 PACKED_ELEMENTS 에서 HOLEY_ELEMENTS 로 바뀌게 된다.</p>

<p><img src="/upload/2025-09-05-내_큐는_왜_느릴까.md/2.png" alt="2" /><em>73913.png</em></p>

<blockquote>
  <p>이 그림은 2025.02.28 이전의 그림인데 자세히보면 화살표의 방향이 위에서 아래로만 되어있다. 즉, 한 번 HOLEY 가 되면 되돌아갈 수 없다는 의미였는데 2025.02.28 이후에는 예외가 하나 생겼다고 한다.</p>

  <p>Array.prototype.fill 를 통해서 모든 홀을 채우면, PACKED 로 돌아갈 수 있다고 한다.</p>
</blockquote>

<p>hole 이 생기게 되면, V8 은 매번 hole 이 있는지 여부를 체크해야하는 로직이 최적화에 포함되고, hole 인지 구분하기 위해 상위 프로토타입까지 거슬러 올라가기때문에 PACKED 보다 최적화가 비효율적이다.</p>

<h1 id="더-나은-큐를-만들기">더 나은 큐를 만들기</h1>

<p>기존의 큐 방식을 살펴보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
// 기존 방식(최적화가 잘 되지 않음)
let queue = {};
let head = 0, tail = 0;
function enqueue(x) {
  queue[tail++] = x;
}
function dequeue() {
  if (tail &gt; head) {
    let x = queue[head];
    delete queue[head++];
    return x;
  }
}

</code></pre></div></div>

<p>처음에는 queue 안에서 0, 1, 2… 같은 순서로 인덱스가 증가하기 때문에 객체가 배열처럼 동작한다.</p>

<p>따라서 SMI(Small Integer) elements kind 로 최적화 된다.</p>

<p>그러나 <code class="language-plaintext highlighter-rouge">delete</code> 를 하게 되면 0부터 hole 이 생기게 된다. 따라서 PACKED → HOLEY 로 최적화 효율이 다소 안좋아지게 된다.</p>

<p>그러다가 delete 를 많이 하다보면 head 와 tail 의 숫자는 매우 큰 반면 실제로 객체에 저장된 값은 몇 개 없을 수도 있다. 다시 말해, offset 을 통해서 접근하려고 보니까 앞에 hole 이 너무 많아서 매우 큰 offset 을 통해서 접근해야 하는 것이다.</p>

<p>이럴 때는 V8 이 배열처럼 최적화하는 것은 비효율적이라고 판단해 딕셔너리 모드로 전환해버릴 수 있다. 이렇게 되면 히든 클래스와 offset 을 사용할 수도 없게 되고, 인라인 캐시 입장에서는 매번 offset 을 통해서 접근했는데, 딕셔너리 모드로 전환되다보니 캐싱된 값이 달라지므로 인라인 캐시도 유지할 수 없다.</p>

<p>이제부터는 최적화 로직은 거의 사용하지 못하게 되므로 속도가 느려진다.</p>

<h3 id="delete-를-안쓰는-방법">Delete 를 안쓰는 방법</h3>

<p>delete 를 안쓰면서 메모리 효율도 높일 수 있는 방법은 뭐가 있을까?</p>

<ul>
  <li>원형 큐(고정 크기)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
// 원형 큐
const capacity = 1024;
let queueArr = new Array(capacity);
let head = 0, tail = 0;

function enqueue(x) {
  if ((tail + 1) % capacity === head) throw Error("queue full");
  queueArr[tail] = x;
  tail = (tail + 1) % capacity;
}

function dequeue() {
  if (head === tail) return undefined; 
  const x = queueArr[head];
  queueArr[head] = undefined;
  head = (head + 1) % capacity;
  return x;
}

</code></pre></div></div>

<p>위의 코드와 같은 원형 큐를 한 번 살펴보자.</p>

<p>고정된 크기의 원형 큐를 한 번 보면, hole 이 생기지 않고 index 도 0부터 쌓이기 때문에 PACKED_SMI 를 유지할 수 있다.</p>

<p>지금처럼 고정된 큐의 경우에는 리사이징을 할 수 없기 때문에, 리사이징까지 고려하면 아래와 같이 생각해볼 수 있을 것 같다.</p>

<p>대신 아무래도 동적인 크기가 가능해지기 때문에 완전히 모노모픽을 유지하기는 힘들고, 미리 capacity 를 크게 잡아둔다거나 하는 방식으로 너무 빈번한 리사이징이 일어나지 않도록 크기를 잘 잡는게 중요할 것 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>javascript
class Queue {
  constructor(initialCapacity = 16) {
    this.capacity = initialCapacity;
    this.queue = new Array(this.capacity);
    this.head = 0;
    this.tail = 0;
    this.size = 0;
  }

  enqueue(x) {
    if (this.size === this.capacity) {
      this._grow();
    }
    this.queue[this.tail] = x;
    this.tail = (this.tail + 1) % this.capacity;
    this.size++;
  }

  dequeue() {
    if (this.size === 0) return undefined;
    const x = this.queue[this.head];
    this.queue[this.head] = undefined; // 슬롯 정리 (GC-friendly)
    this.head = (this.head + 1) % this.capacity;
    this.size--;

    if (this.capacity &gt; 16 &amp;&amp; this.size &lt;= this.capacity / 4) {
      this._shrink();
    }
    return x;
  }

  peek() {
    return this.size === 0 ? undefined : this.queue[this.head];
  }

  isEmpty() {
    return this.size === 0;
  }

  _grow() {
    const newCapacity = this.capacity * 2;
    this._resize(newCapacity);
  }

  _shrink() {
    const newCapacity = Math.floor(this.capacity / 2);
    this._resize(newCapacity);
  }

  _resize(newCapacity) {
    const newQueue = new Array(newCapacity);
    for (let i = 0; i &lt; this.size; i++) {
      newQueue[i] = this.queue[(this.head + i) % this.capacity];
    }
    this.queue = newQueue;
    this.capacity = newCapacity;
    this.head = 0;
    this.tail = this.size;
  }
}

</code></pre></div></div>


            </div>
        </section>

        <!-- Email subscribe form at the bottom of the page -->
        
        <section class="subscribe-form">
            <h3 class="subscribe-form-title">Subscribe to hoeeeeeh</h3>
            <p>Get the latest posts delivered right to your inbox</p>
            <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

        </section>
        

        <footer class="post-full-footer">
            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
            
            
            <!-- /author  -->
        </footer>

        <!-- If you use Disqus comments, just uncomment this block.
        The only thing you need to change is "test-apkdzgmqhj" - which
        should be replaced with your own Disqus site-id. -->
        

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            
            
            
            
            <article class="read-next-card"
                     
                     style="background-image: url(/assets/images/blog-cover.jpg)"
                     
            >
                <header class="read-next-card-header">
                    <small class="read-next-card-header-sitetitle">&mdash; hoeeeeeh &mdash;</small>
                    
                    <h3 class="read-next-card-header-title"><a href="/tag/javascript/">Javascript</a></h3>
                    
                </header>
                <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                <div class="read-next-card-content">
                    <ul>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li><a href="/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1">백준 21939 문제 추천 시스템 Version 1</a></li>
                        
                        
                        
                        
                        
                        
                        
                        
                        <li><a href="/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84">JS TS 로 Queue 구현</a></li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li><a href="/%EB%84%A4%EB%B6%80%EC%BA%A0_%EC%B1%8C%EB%A6%B0%EC%A7%80-_Day_01_~_19_%EC%A0%95%EB%A6%AC_">[네부캠 챌린지] Day 01 ~ 19 정리 </a></li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                </div>
                <footer class="read-next-card-footer">
                    <a href="/tag/javascript/">
                    
                    See all 8 posts  →
                    
                    </a>
                </footer>
            </article>
            
            
        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://hoeeeeeh.github.io/">
            
                <img src="/assets/images/favicon.png" alt="hoeeeeeh icon" />
            
            <span>hoeeeeeh</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">내 큐는 왜 느릴까</div>
    <div class="floating-header-share">
        <!-- Sidebar Toggle Button -->
        <button class="toc-toggle" id="toc-toggle">☰ 목차</button>

        <!-- Table of Contents Sidebar -->
        <aside class="toc" id="toc-sidebar">
            <nav>
                <ul><li><a href="#객체로-간단하게-큐-구현해보기">객체로 간단하게 큐 구현해보기</a><ul><li><a href="#dequeue-delete">Dequeue, delete</a></li></ul></li><li><a href="#v8">V8</a><ul><li><a href="#turbofan-ignition">TurboFan, Ignition</a></li><li><a href="#hidden-class-shape">Hidden Class (Shape)</a><ul><li><a href="#히든-클래스는-offset-을-저장한다">히든 클래스는 Offset 을 저장한다.</a></li><li><a href="#딕셔너리-모드">딕셔너리 모드</a></li></ul></li><li><a href="#elements-kind">Elements Kind</a><ul><li><a href="#타입이-달라지면">타입이 달라지면</a></li></ul></li><li><a href="#holey">Holey</a></li></ul></li><li><a href="#더-나은-큐를-만들기">더 나은 큐를 만들기</a><ul><li><a href="#delete-를-안쓰는-방법">Delete 를 안쓰는 방법</a></li></ul></li></ul></li></ul>

            </nav>
        </aside>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://hoeeeeeh.github.io/">hoeeeeeh</a> &copy; 2025</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/ghost" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/tryghost" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                    <img class="subscribe-overlay-logo" src="/assets/images/blog-icon.png" alt="hoeeeeeh" />
                
                <h1 class="subscribe-overlay-title">Subscribe to hoeeeeeh</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

            </div>
        </div>
    


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G9Z64HV3NB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-G9Z64HV3NB');
</script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
