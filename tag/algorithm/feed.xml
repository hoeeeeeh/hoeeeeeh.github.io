<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://hoeeeeeh.github.io/tag/algorithm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://hoeeeeeh.github.io/" rel="alternate" type="text/html" />
  <updated>2025-12-17T12:06:16+00:00</updated>
  <id>https://hoeeeeeh.github.io/tag/algorithm/feed.xml</id>

  
  
  

  
    <title type="html">hoeeeeeh | </title>
  

  
    <subtitle>HOEH 개발 블로그</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">백준 21939 문제 추천 시스템 Version 1</title>
      <link href="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1" rel="alternate" type="text/html" title="백준 21939 문제 추천 시스템 Version 1" />
      <published>2025-02-03T08:07:00+00:00</published>
      <updated>2025-02-03T08:07:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EB%B0%B1%EC%A4%80_21939_%EB%AC%B8%EC%A0%9C_%EC%B6%94%EC%B2%9C_%EC%8B%9C%EC%8A%A4%ED%85%9C_Version_1">&lt;p&gt;&lt;img src=&quot;/upload/2025-02-03-백준_21939_문제_추천_시스템_Version_1.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;문제 추천 시스템 Version 1&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;recommend(x) : x 가 1이면 난이도 가장 높은 문제를 우선순위 큐에서 출력, x 가 -1 이면 난이도가 가장 쉬운 문제를 출력.&lt;/p&gt;

    &lt;p&gt;→ 우선 순위큐를 minHeap, maxHeap 두 개를 써야겠다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;add(P, L) : 문제 번호가 P, 난이도가 L 인 문제를 추가&lt;/p&gt;

    &lt;p&gt;→ 2개의 우선순위 큐에 전부 넣어야한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;solved(P) : 문제 번호가 P인 문제를 풀었다는 의미이므로, recommend 를 할 때 풀었던 문제는 추천하지 않도록 어딘가에 저장해두어야 함.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 문제는 우선순위 큐와 Map 혹은 Object 를 쓰면 쉽게 풀리는 문제다.&lt;/p&gt;

&lt;p&gt;문제가 Solved 되면 Map 혹은 Object 에 기억해뒀다가, recommend 명령어에 의해서 문제를 추천할 때 Solved 된 문제라면 다음 Min (혹은 Max) Heap 에서 하나를 더 꺼내면 된다.&lt;/p&gt;

&lt;p&gt;그래서 문제 난이도가 그렇게 높게 잡히지는 않았는데 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;javascript 에 우선순위 큐가 없다&lt;/code&gt;는 점이다.&lt;/p&gt;

&lt;p&gt;추가로 PriorityQueue 의 heap 을 일반 배열이 아닌 Queue 를 직접 구현했는데, 문제를 풀면서 heap 에 직접 shift 를 해야하는 경우가 필요하다고 착각했다.  dequeue 를 여러 번 하면 되는 일이었는데.&lt;/p&gt;

&lt;p&gt;자바스크립트는 배열의 shift 가 O(1) 이 아닌 O(n) 이다보니, shift 를 하려면 Queue 를 직접 구현해야해서 사용하면서도 일반 배열처럼 사용할 수 있는 방법을 고민하면서 풀었다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Queue {
    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Queue 에 배열처럼 index 만으로 접근하고 싶었는데 내가 만든 Queue 는 head 와 tail 로 이동하기 때문에 head 로 인덱스의 값을 보정해야했다.&lt;/p&gt;

&lt;p&gt;덕분에 모든 자료구조를 다 직접 짜면서 하다보니 코드가 엄청나게 길어졌다.&lt;/p&gt;

&lt;p&gt;아래는 삽질한 코드이다..&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Problem {
    constructor(num, level) {
        this.num = num;
        this.level = level;
    }
}

class PriorityQueue {
    heap = new Queue();

    constructor(comparator) {
        if(comparator) this.comparator = comparator.bind(this);
        else this.comparator = (a, b) =&amp;gt; this.heap.get(a) - this.heap.get(b);
    }

    enqueue(value){
        const heapLength = this.heap.push(value);
        this.bubbleUp(heapLength - 1);
    }

    peek(){
        return this.heap.get(0);
    }

    dequeue(){
        if(this.isEmpty()) return undefined;

        const root = this.heap.get(0);
        const leap = this.heap.pop();
        if(this.isEmpty()) return root;
        this.heap.set(0, leap);
        this.bubbleDown(0);

        return root;
    }

    bubbleUp(index_){
        let index = index_;
        while(index &amp;gt; 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if(this.comparator(index, parentIndex) &amp;gt;= 0) break;
            this.swap(index, parentIndex);
            index = parentIndex;
        }
        return index;
    }

    bubbleDown(index_){
        let index = index_;
        let smallestIndex = index;
        while(smallestIndex &amp;lt; this.heap.length){

            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;

            if(leftChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(leftChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = leftChildIndex;
            }
            if(rightChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(rightChildIndex, smallestIndex) &amp;lt; 0){
                smallestIndex = rightChildIndex;
            }

            if(smallestIndex === index) break;
            this.swap(index, smallestIndex);
            index = smallestIndex;
        }
        return index;
    }

    isEmpty(){
        return this.heap.length === 0;
    }

    swap(i, j){
        const restore = this.heap.get(i);
        this.heap.set(i, this.heap.get(j));
        this.heap.set(j, restore);
    }
}

class Queue {
    items = {}
    head = 0;
    tail = 0;

    get length(){
        return this.tail - this.head;
    }

    get(index){
        return this.items[index + this.head];
    }

    set(index,  value){
        this.items[index + this.head] = value;
    }

    constructor() {}

    push(value){
        this.items[this.tail] = value;
        this.tail += 1;
        return this.length;
    }

    pop(){
        if(this.isEmpty()) return undefined;
        const leaf = this.items[this.tail - 1];
        delete this.items[this.tail - 1];

        if(!this.isEmpty()) this.tail -= 1;
        return leaf;
    }

    isEmpty(){
        if(this.head !== this.tail) return false

        this.head = this.tail = 0;
        return true

    }
}

class ProblemPriorityQueue extends PriorityQueue {
    solvedProblems = {}
    constructor(comparator) {
        super(comparator);
    }
    solved(index){
        this.solvedProblems[index] = true;
    }

    peek(){
        this.removeSolvedProblem();
        return super.peek();
    }

    removeSolvedProblem(){
        let peek = super.peek();
        while(peek.num in this.solvedProblems){
            super.dequeue();
            delete this.solvedProblems[peek.num];
            peek = super.peek();
        }
    }
}

function minComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(a).level - this.heap.get(b).level;
    return this.heap.get(a).num - this.heap.get(b).num;
}

function maxComparator(a, b){
    if(this.heap.get(a).level !== this.heap.get(b).level) return this.heap.get(b).level - this.heap.get(a).level;
    return this.heap.get(b).num - this.heap.get(a).num;
}

function add(P, L){
    minPPQ.enqueue(new Problem(P, L));
    maxPPQ.enqueue(new Problem(P, L));
}

function solved(P) {
    minPPQ.solved(P);
    maxPPQ.solved(P);
}

function recommend(x){
    if(x === -1) {
        return minPPQ.peek().num;
    } else {
        return maxPPQ.peek().num;
    }
}

const readline = require(&quot;readline&quot;);
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let N = -1;
let M = -1;
let count = -1;
let answer = [];
const minPPQ = new ProblemPriorityQueue(minComparator);
const maxPPQ = new ProblemPriorityQueue(maxComparator);

rl.on(&quot;line&quot;, (line) =&amp;gt; {
    if(N === -1){
        N = parseInt(line);
        count = N;
    } else if (count &amp;gt; 0) {
        const [num, level] = line.split(&apos; &apos;).map((n) =&amp;gt; parseInt(n))
        add(num, level);
        count -= 1;
    } else {
        if(M === -1) M = parseInt(line);
        else {
            const [cmd, num1, num2] = line.split(&apos; &apos;);
            if (cmd === &apos;recommend&apos;) {
                const log = recommend(parseInt(num1));
                answer.push(log);
            } else if (cmd === &apos;solved&apos;) {
                solved(parseInt(num1));
            } else {
                add(parseInt(num1), parseInt(num2))
            }
        }
    }
}).on(&quot;close&quot;, () =&amp;gt; {
    console.log(answer.join(&apos;\n&apos;));
})


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      
        <category term="JavaScript" />
      

      
        <summary type="html">문제 추천 시스템 Version 1</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">JS TS 로 Queue 구현</title>
      <link href="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84" rel="alternate" type="text/html" title="JS TS 로 Queue 구현" />
      <published>2025-01-31T07:42:00+00:00</published>
      <updated>2025-01-31T07:42:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/JS_TS_%EB%A1%9C_Queue_%EA%B5%AC%ED%98%84">&lt;h1 id=&quot;objector-map-을-활용한-queue&quot;&gt;Object(or Map) 을 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class ObjectQueue {
    item = {};
    start = 0;
    end = 0;

    constructor() {}

    enqueue(value){
        this.item[this.end] = value;
        this.end += 1;
        return this.end - 1;
    }
    
     // 큐가 비어 있을 때는 undefined, 그렇지 않은 경우 0 번째 원소를 반환
    dequeue(){
        if(this.isEmpty()) return undefined;
        const value = this.item[this.start];
        delete this.item[this.start];
        this.start += 1;
        return value;
    }

    isEmpty(){
        if(this.start === this.end) {
            this.start = 0;
            this.end = 0;
            return true;
        }
        return false;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Object 나 Map 을 활용해서 key-value 형식으로 저장한다.&lt;/p&gt;

&lt;p&gt;다만 Object, Map 이 사용하는 메모리가 다른 방법에 비해 많아, 메모리 효율은 다소 떨어질 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;linkedlist-를-활용한-queue&quot;&gt;LinkedList 를 활용한 Queue&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class Node {
    value = null;
    next = null
    constructor(value) {
        this.value = value;
    }
}

class LinkedListQueue {
    front = null;
    rear = null;
    length = 0;

    enqueue(value){
        const newNode = new Node(value);
        // rear 가 null 인, 초기 상황일 때
        if(!this.rear) {
            this.front = this.rear = newNode;
        } else {
            // 현재 맨 마지막 노드의 다음 노드를 newNode 로 지정하고, newNode 를 마지막 노드로 지정
            this.rear.next = newNode;
            this.rear = newNode;
        }
        this.length += 1;
    }

    dequeue() {
        if(!this.front) {
            return undefined;
        }
        const value = this.front.value;
        this.front = this.front.next;

        // 하나를 dequeue 하고 Queue 에 아무것도 없을 때
        if(!this.front) {
            this.rear = null;
        }
        this.length -= 1;

        return value;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;원형-큐&quot;&gt;원형 큐&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularQueue&amp;lt;T&amp;gt; {
    private readonly items: (T | null)[];
    private readonly capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueue(value: T) {
        if (this.isFull()) return false;
        this.items[this.rear] = value;

        // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 front 까지 다시 사용
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
        return true;
    }

    dequeue() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        
         // 여기서 만약 capacity 를 넘어가면, 0부터 시작해서 rear 까지 다시 사용
        this.front = (this.front + 1) % this.capacity; 
        this.size--;
        return value;
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐는 고정 사이즈를 정하고, 고정 사이즈만큼의 배열을 순환하면서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;여기서 만약 배열이 꽉 찼는데도 enqueue 가 일어나면 문제가 된다. 배열에 이미 값이 존재하는데 그 위에 덮어쓰게 되기 때문이다.&lt;/p&gt;

&lt;p&gt;따라서 원형큐가 가득 찼으면 배열을 그 순간에 늘리거나 해야한다.&lt;/p&gt;

&lt;p&gt;이 과정에서 기존 배열을 복사해야해서 시간이 많이 소요된다.&lt;/p&gt;

&lt;p&gt;이렇게 보면 원형큐는 dequeue 보다 enqueue 가 월등히 많은 경우, 썩 좋지 못할 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;원형-덱deque-double-ended-queue&quot;&gt;원형 덱(deque, Double Ended Queue)&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
class CircularDeque&amp;lt;T&amp;gt; {
    private items: (T | null)[];
    private capacity: number;
    private front: number;
    private rear: number;
    private size: number;

    constructor(capacity: number = 8) {
        this.capacity = capacity;
        this.items = new Array(capacity).fill(null);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueueFront(value: T) {
        if (this.isFull()) this.resize();
        this.front = (this.front - 1 + this.capacity) % this.capacity;
        this.items[this.front] = value;
        this.size++;
    }

    enqueueBack(value: T) {
        if (this.isFull()) this.resize();
        this.items[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
    }

    dequeueFront() {
        if (this.isEmpty()) return undefined;
        const value = this.items[this.front];
        this.items[this.front] = null;
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        return value as T;
    }

    dequeueBack() {
        if (this.isEmpty()) return undefined;
        this.rear = (this.rear - 1 + this.capacity) % this.capacity;
        const value = this.items[this.rear];
        this.items[this.rear] = null;
        this.size--;
        return value as T;
    }

    peekFront() {
        return this.isEmpty() ? undefined : (this.items[this.front]);
    }


    peekBack() {
        return this.isEmpty() ? undefined : (this.items[(this.rear - 1 + this.capacity) % this.capacity]);
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }

    getSize() {
        return this.size;
    }

    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;원형 큐와 큰 차이는 없다.&lt;/p&gt;

&lt;p&gt;여기서 원형 큐나, 원형 데크나 resize 부분을 알아둬야한다.&lt;/p&gt;

&lt;h2 id=&quot;resize&quot;&gt;Resize&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
    private resize() {
        const newCapacity = this.capacity * 2;
        const newItems = new Array(newCapacity).fill(null);

        for (let i = 0; i &amp;lt; this.size; i++) {
            newItems[i] = this.items[(this.front + i) % this.capacity];
        }

        this.items = newItems;
        this.capacity = newCapacity;
        this.front = 0;
        this.rear = this.size;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;resize 부분을 보면 capacity 를 2배(혹은 원하는 만큼) 늘리고나서&lt;/p&gt;

&lt;p&gt;for 문 내부에서 아이템을 복제 및 정렬을 한다.&lt;/p&gt;

&lt;p&gt;언뜻 생각해보면 capacity 만 2배로 복제해도 되지 않을까 싶지만 기존 배열의 순서를 정렬해서 새로운 배열에 적용해야만 한다.&lt;/p&gt;

&lt;p&gt;예시를 들어서 살펴보면,&lt;/p&gt;

&lt;h3 id=&quot;기존-상태-1234-덱에-삽입&quot;&gt;기존 상태 (1,2,3,4 덱에 삽입)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 1  ] [ 2  ] [ 3  ] [ 4  ]  
Front → index 0
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;1-2-dequeue&quot;&gt;1, 2 dequeue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ X  ] [ X  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 0 (다음 삽입 위치)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-6-enqueue&quot;&gt;5, 6 enqueue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3
Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ]  
Front → index 2
Rear  → index 2 (가득 참)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-enqueue-resize-실행&quot;&gt;7 enqueue (Resize 실행)&lt;/h3&gt;

&lt;p&gt;단순히 Capacity 만 늘리는 경우(잘못된 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
	Index:      0      1      2      3      4      5      6      7
	Items:    [ 5  ] [ 6  ] [ 3  ] [ 4  ] [ X  ] [ X  ] [ X  ] [ X  ]
	Front → index 2
	Rear  → index 4
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3 → 4→ 5→ 6 순서가 아니라, 5 → 6 → 3→ 4 가 되어버린다.&lt;/p&gt;

&lt;p&gt;따라서 3,4,5,6 순서로 정렬시켜주는 과정이 필요&lt;/p&gt;

&lt;p&gt;resize 및 정렬 과정(올바른 경우)&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typescript
Index:      0      1      2      3      4      5      6      7
Items:    [ 3  ] [ 4  ] [ 5  ] [ 6  ] [ X  ] [ X  ] [ X  ] [ X  ]
Front → index 0
Rear  → index 4

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      
        <category term="JavaScript" />
      
        <category term="TypeScript" />
      

      
        <summary type="html">Object(or Map) 을 활용한 Queue</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">상호 배타적 집합 (Union-Find)</title>
      <link href="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)" rel="alternate" type="text/html" title="상호 배타적 집합 (Union-Find)" />
      <published>2025-01-26T07:18:00+00:00</published>
      <updated>2025-01-26T07:18:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%83%81%ED%98%B8_%EB%B0%B0%ED%83%80%EC%A0%81_%EC%A7%91%ED%95%A9_(Union-Find)">&lt;p&gt;상호 배타적이라는 것은, 공통 원소가 없는 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 상호 배타적 집합이라는 것은 공통 원소가 없은 부분 집합으로 이루어진 집합이다.&lt;/p&gt;

&lt;p&gt;상호 배타적 집합을 Union-FInd 라고도 부르는 이유는, 이러한 집합을 만드는데 아래와 같은 Union, Find 과정을 수행하기 때문이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;처음 상태는 각각 자기 자신만을 포함한 집합을 생성한다. (초기화 단계)&lt;/li&gt;
  &lt;li&gt;이제 두 원소 a, b 가 주어질 때 이들이 속한 두 집합을 하나로 합친다. (Union 연산)&lt;/li&gt;
  &lt;li&gt;어떤 원소 a 가 주어질 때, 이 원소가 속한 집합을 찾는다. (Find 연산)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어 1부터 n 까지의 숫자 중에서 2로 나눈 나머지에 대해 상호 배타적 집합을 만든다고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;2로 나눈 나머지에 따른 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 트리 구조로 원소들을 묶으면서 하나의 부분 집합을 표현할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;union&quot;&gt;Union&lt;/h2&gt;

&lt;p&gt;Union 과정은 이처럼 두 개의 트리 구조를 하나로 합치는 과정을 의미한다.&lt;/p&gt;

&lt;p&gt;예를 들어, 왼쪽의 2로 나눈 나머지가 0인 트리가 합쳐지기 전을 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합 2, 6 이 아직 합쳐지지않은 상태&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;아직 2 와 6 이 같은 트리로 합쳐지지 않은 상황이다.&lt;/p&gt;

&lt;p&gt;여기서 우리는 2와 6은 짝수이기 때문에 같은 집합에 속한다는 것을 알고있다.&lt;/p&gt;

&lt;p&gt;따라서 Union 과정을 거쳐야하고 6의 부모 노드를 2로 지정함으로써 맨 처음의 그래프와 같이 하나의 트리 구조로 만들 수 있는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;find&quot;&gt;Find&lt;/h2&gt;

&lt;p&gt;기본적으로 Find 과정은 부모노드를 타고 올라가면서, 최종적으로는 해당 집합의 루트 노드를 찾으면 된다.&lt;/p&gt;

&lt;p&gt;루트 노드가 집합을 대표하는 격이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;2로 나눈 나머지가 0인 집합&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 위의 트리에서 4와 12가 같은 집합에 속해있는지 어떻게 알 수 있을까?&lt;/p&gt;

&lt;p&gt;4와 12 각각 루트노드가 나올때까지 부모노드를 타고 올라가보면 된다.&lt;/p&gt;

&lt;p&gt;그렇게 더이상 올라갈 수 있는 노드가 없을 때, 즉 루트 노드까지 왔을 때 4의 루트노드와 12의 루트노드를 비교해보면 된다.&lt;/p&gt;

&lt;p&gt;여기서는 둘 다 루트노드가 2로 같기 때문에 같은 집합에 속하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;최적화를-하지-않은-구현&quot;&gt;최적화를 하지 않은 구현&lt;/h2&gt;

&lt;p&gt;우선 Find 연산에서 봤듯이, 부모 노드에 대한 정보가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;반대로 부모 노드에서 자식 노드로 내려갈 일은 없다.&lt;/p&gt;

&lt;p&gt;따라서 Union-FInd 자료구조를 구현하기 위해서는 부모 노드에 대한 정보를 저장할 수 있는 자료구조를 선택하면 된다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 고려하지 않은, 굉장히 간단한 UnionFind 를 한 번 구현해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size){
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
    }
    
    union(a, b){
        const root_a = this.find(a);
        const root_b = this.find(b);
        
        // 같은 집합에 속해있지 않을 경우
        // 최적화 없는 버전!
        if(root_a !== root_b) this.parent[root_b] = root_a;
    }
    
    find(node){
        // 경로 압축 최적화가 없는 버전!
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 find 메서드부터 개선점을 찾아보자.&lt;/p&gt;

&lt;h3 id=&quot;find-개선하기-경로-압축&quot;&gt;Find 개선하기 (경로 압축)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;초기화 단계&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우선 2,4,6,8,10,12,14 가 초기화 단계로, 각자 자기 자신을 가지고 있는 집합인 상황에서부터 시작해보자.&lt;/p&gt;

&lt;p&gt;여기서 별 생각 없이 2와 4를 Union 하면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;2와 4를 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 이번에 4와 6을 union 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;4 와 6을 Union&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 보아하니 아마도 최종적으로 이런 트리가 생성될 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;일자로 쭉~&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 되면 루트 노드를 찾아야하는 find 연산의 특성 상, 트리의 레벨에 직접적으로 영향을 받을 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 find 를 최적화하기 위해서 트리의 레벨을 줄여야하니까, 이런 그래프가 가장 좋은게 아닐까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;레벨을 1로 최적화한 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 어느 노드에서 find 메서드를 실행해도 바로 루트 노드가 나오게 된다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 이런 식으로 최적화할 수 있을까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
   	// 경로 압축 최적화가 없는 버전!
    find(node){
        if(this.parent[node] !== node) return this.find(this.parent[node]);
        return node
    }

    // 경로 압축 최적화
    find(node){
        if(this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
            return this.parent[node];
        }
        return node
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;맨 처음부터 완벽하게 최적화된 트리를 얻을 수는 없다. 다만 find 를 한 번 하고나면 최적화되도록 구현할 수는 있다.&lt;/p&gt;

&lt;p&gt;경로 압축을 하지 않는 경우는 루트 노드를 찾으면 그대로 루트 노드를 반환했다.&lt;/p&gt;

&lt;p&gt;반면 경로 압축을 하는 경우에는 루트 노드를 찾았을 때, 루트 노드를 찾기 전까지 거쳐온 노드들의 부모 노드를 루트 노드로 갱신하는 과정이 있다.&lt;/p&gt;

&lt;h3 id=&quot;union-개선하기-union-by-rank&quot;&gt;Union 개선하기 (union by rank)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;레벨이 1, 2 인 트리&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 두 트리를 union 시킨다고 해보자.&lt;/p&gt;

&lt;p&gt;먼저 왼쪽의 레벨2 트리에, 오른쪽 트리의 레벨 1을 합치면 아래와 같은 트리가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;레벨이 1인 트리를, 레벨이 2인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 경우에는 기존의 레벨이 2인 트리와 동일하게 레벨이 2로 유지됨을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이번에는 방향을 거꾸로 해서 합쳐보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-26-상호_배타적_집합_(Union-Find).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;레벨이 2인 트리를, 레벨이 1인 트리의 자식으로 합치기&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기존의 레벨이 1인 트리의 레벨이 2로 늘어나는 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 트리의 레벨이 늘어나는것을 최소화하기 위해서는 레벨이 높은 트리에, 레벨이 낮은 트리를 합치는 것이 좋다.&lt;/p&gt;

&lt;p&gt;이런 방식을 랭크에 의한 합치기(union by rank) 라고 한다.&lt;/p&gt;

&lt;p&gt;그래서 최적화를 해보면,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;최적화를-한-구현union-by-rank-경로-압축&quot;&gt;최적화를 한 구현(union by rank, 경로 압축)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class UnionFind {
    constructor(size) {
        this.parent = Array.from({ length: size }, (_, idx) =&amp;gt; idx);
        this.rank = Array(size).fill(0); // 초기 랭크는 모두 0
    }

    union(a, b) {
        const root_a = this.find(a);
        const root_b = this.find(b);

        if (root_a !== root_b) {
            // 랭크를 비교하여 더 낮은 랭크를 높은 랭크의 자식으로 연결
            if (this.rank[root_a] &amp;gt; this.rank[root_b]) {
                this.parent[root_b] = root_a;
            } else if (this.rank[root_a] &amp;lt; this.rank[root_b]) {
                this.parent[root_a] = root_b;
            } else {
                // 랭크가 같다면 root_b를 root_a의 자식으로 연결하고 root_a의 랭크를 증가
                this.parent[root_b] = root_a;
                this.rank[root_a]++;
            }
        }
    }

    find(node) {
        if (this.parent[node] !== node) {
            this.parent[node] = this.find(this.parent[node]);
        }
        return this.parent[node];
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">상호 배타적이라는 것은, 공통 원소가 없는 것이다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">스패닝 트리</title>
      <link href="https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC" rel="alternate" type="text/html" title="스패닝 트리" />
      <published>2025-01-20T02:16:00+00:00</published>
      <updated>2025-01-20T02:16:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%8A%A4%ED%8C%A8%EB%8B%9D_%ED%8A%B8%EB%A6%AC">&lt;h1 id=&quot;스패닝-트리&quot;&gt;스패닝 트리&lt;/h1&gt;

&lt;p&gt;어떤 무향 그래프의 스패닝 트리는 원래 그래프의 정점 전부와 간선의 부분 집합으로 구성된 부분 그래프이다.&lt;/p&gt;

&lt;p&gt;스패닝 트리에 포함된 간선들은 정점들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 형태로 전부 연결해야하는데, 이는 사이클이 없고 정점들이 꼭 부모-자식 관계로 연결될 필요는 없다는걸 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/0.png&quot; alt=&quot;0&quot; /&gt;&lt;em&gt;예시 그래프&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 예시 그래프에서 스패닝 트리를 그려보자. 스패닝 트리는 유일하지 않을 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/1.png&quot; alt=&quot;1&quot; /&gt;_올바른 스패닝 트리 1 _&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;올바른 스패닝 트리 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;스패닝 트리는 모든 정점이 연결되어 있거나, 사이클이 있으면 안된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;잘못된 스패닝 트리 1 (모든 정점이 연결되어 있지 않음)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;잘못된 스패닝 트리 2 (모든 정점이 연결되어 있지만 사이클이 존재)&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;최소-스패닝-트리&quot;&gt;최소 스패닝 트리&lt;/h1&gt;

&lt;p&gt;가중치가 있는 그래프에서, 스패닝 트리 중 가중치의 합이 가장 작은 트리를 최소 스패닝 트리라고 한다.&lt;/p&gt;

&lt;p&gt;최소 스패닝 트리를 찾는 알고리즘에는 크게 두 가지가 존재한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;크루스칼&lt;/li&gt;
  &lt;li&gt;프림&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;두 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;간선이 하나도 없는 상태&lt;/code&gt; 에서 시작해 하나씩 트리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치가 가장 작은 간선&lt;/code&gt;을 추가해 가는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그리디 알고리즘&lt;/code&gt; 으로, 접근 방법이 달라보이지만 같은 방법으로 증명할 수 있다는 특징도 있다.&lt;/p&gt;

&lt;h2 id=&quot;크루스칼-알고리즘&quot;&gt;크루스칼 알고리즘&lt;/h2&gt;

&lt;p&gt;크루스칼의 기본적인 아이디어는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치가 작은 간선이 최소 스패닝 트리에 포함될 가능성이 높다&lt;/code&gt; 이다.&lt;/p&gt;

&lt;p&gt;그래서&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 간선의 가중치를 오름차순으로 정렬한다&lt;/li&gt;
  &lt;li&gt;가중치가 작은 순서대로 스패닝 트리에 추가한다.&lt;/li&gt;
  &lt;li&gt;단, 스패닝 트리에 사이클이 생기지 않도록 한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 방식으로 모든 간선을 한 번씩 검사하고 나면 크루스칼 알고리즘은 종료된다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-동작-방식&quot;&gt;알고리즘 동작 방식&lt;/h3&gt;

&lt;p&gt;이제 예시를 들어, 한 번 직접 진행해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;크루스칼 알고리즘의 예시 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;우선 가중치들을 정렬하면 [1, 2, 3, 4, 5, 6, 7, 9] 가 될 것이다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가중치가 가장 작은 A - C (1) 을 선택해보자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;처음 뽑는 간선이다보니 당연히 사이클은 그려지지 않을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;가중치가 1인 A - C 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;두 번째로 작은 E - F (2) 를 선택하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;가중치가 2인 E - F 산텍&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;마찬가지로, C - D (3) 과 A - B (4) 를 선택해보자&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;가중치가 3인 C - D, 가중치가 4인 A - B 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이제 남은 간선중에 가중치가 가장 작은 B - C (5) 를 선택하려고 보니, A - B - C 간의 사이클이 발생한다.
마찬가지로 그 다음 가중치가 작은 B - D (6) 을 선택하면 A - B - D -C 간의 사이클이 발생한다.&lt;/li&gt;
  &lt;li&gt;사이클이 생기지 않는 선에서 가장 작은 가중치를 갖는 D - F (7) 을 연결한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;가중치가 7인 D - F 선택&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;C - E 도 마찬가지로 사이클이 생기기 때문에 선택하지 않는다.&lt;/li&gt;
  &lt;li&gt;모든 간선에 대해 검사를 완료했으므로 종료한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;사이클-검사-방법&quot;&gt;사이클 검사 방법&lt;/h3&gt;

&lt;p&gt;알고리즘 동작 방식을 봤을 때, 딱히 어려울 게 없어 보이는 단순한 방식으로 보인다.&lt;/p&gt;

&lt;p&gt;다만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사이클이 생기는지&lt;/code&gt; 확인하는 작업을 어떻게 하는지를 고민해봐야 할 것 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결국 스패닝 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 이므로 트리에 간선을 추가한 뒤에, 이 간선의 역방향 간선이 존재하는지를 DFS 로 탐색하면 어떨까?&lt;/p&gt;

&lt;p&gt;예를 들어 A - B (4) 를 스패닝 트리에 추가하고 모든 간선마다 DFS 를 수행한다.&lt;/p&gt;

&lt;p&gt;방문 기록을 저장해두면서 DFS 를 타고가다가, 이미 방문했던 곳을 방문한다면 사이클이 생긴 것이다.&lt;/p&gt;

&lt;p&gt;이 과정을 간선을 추가할 때 마다 진행하면 된다.&lt;/p&gt;

&lt;p&gt;이 방법은 구현하기에 매우 간단하겠지만 시간 복잡도를 생각해봤을 때, DFS 의 시간복잡도인 O(V+E) 에 E 를 곱한, O(E^2) 가 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Union-Find&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두 정점을 잇는 간선에서, 이 간선이 사이클을 만들어내는지 확인하려면 두 정점이 같은 그룹에 있는지 확인하면 된다. 그리고 같은 그룹이 아니라면, 간선을 추가하면서 같은 그룹으로 만들어주는 작업을 반복하면 사이클 검사를 쉽게 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 자료구조를 만족하는 Union-Find 를 활용하면 쉽게 사이클을 검사할 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;Union-Find 사이클 탐색 예시&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 가중치가 1인 A - C 를 검사해보자.&lt;/p&gt;

&lt;p&gt;초기화단계에서는 A부터 F까지 어디에도 연결되지 않은 상태이므로, 당연히 자기 자신을 부모노드로 가진 채 초기화되어있을 것이다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 A 와 C 는 같은 집합에 존재하지 않기 때문에 사이클이 생기지 않는다고 확신할 수 있다.&lt;/p&gt;

&lt;p&gt;이후에 C 의 부모 노드를 A 로 바꾸면서 같은 집합으로 만들어준다.&lt;/p&gt;

&lt;p&gt;이어서 E - F (2) 도 Union 하고 나서 C - D(3) 를 보자.&lt;/p&gt;

&lt;p&gt;C 의 부모노드는 이미 A 이고, D 의 부모노드는 자신(D) 이다.&lt;/p&gt;

&lt;p&gt;둘이 같은 집합이 아니므로 D의 부모노드를 A로 바꾼다.&lt;/p&gt;

&lt;p&gt;A - B 도 마찬가지로, B의 부모노드가 A 로 바뀐다.&lt;/p&gt;

&lt;p&gt;이제 가중치가 5인 B - C 를 추가할지 말지 결정해야한다.&lt;/p&gt;

&lt;p&gt;B와 C의 루트노드를 살펴보니 전부 다 A 인 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;따라서 사이클이 생길 수 있는 간선이므로 추가하지 않는다.&lt;/p&gt;

&lt;h3 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h3&gt;

&lt;p&gt;Union-Find 연산은 현실적으로 매우 짧은 시간(상수 시간)으로 봐도 되기 때문에 실제 트리를 만드는 for 문의 시간 복잡도는 O(E) 라고 봐도 좋다.&lt;/p&gt;

&lt;p&gt;간선 리스트의 정렬에 걸리는 시간은 O(ElogE) 이기 때문에 O(ElogE) 가 전체 시간 복잡도가 된다.&lt;/p&gt;

&lt;h3 id=&quot;증명&quot;&gt;증명&lt;/h3&gt;

&lt;p&gt;크루스칼 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 간선을 그래프에 추가할 때, 뒤에 오는 간선들에 대한 고려는 전혀 하지 않으므로&lt;/code&gt; 탐욕적 알고리즘으로 분류할 수 있다.&lt;/p&gt;

&lt;p&gt;따라서,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;탐욕적 선택 속성은 우리가 내리는 탐욕적인 선택으로 인해 손해를 볼 일이 없음을 증명해야한다.&lt;/li&gt;
  &lt;li&gt;항상 최적의 선택만을 내려도 전체 문제의 최적해를 얻을 수 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 두 가지의 증명을 함으로서 크루스칼 알고리즘의 정당성을 증명할 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;가장 짧은 간선을 선택해도 손해를 볼 일이 없다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 증명은 귀류법으로 할 수 있다.&lt;/p&gt;

&lt;p&gt;크루스칼 알고리즘이 선택한 간선 루트가 올바르지 않다고 가정을 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;예시 그래프&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;크루스칼 알고리즘은 A → B → C → D → F → E 를 최선으로 골랐는데, 실제로는 A → B → C → E → F → D 였다고 가정해보자.&lt;/p&gt;

&lt;p&gt;크루스칼은 C - D 간선을 선택했지만 실제로는 C - D 간선이 아니라 C - E 간선을 선택해야 최소 스패닝 트리라는 것이다.&lt;/p&gt;

&lt;p&gt;크루스칼은 항상 가중치의 최솟값부터 선택해나간다. 따라서 C - D 의 가중치가 C - E 보다 작기 때문에 크루스칼 알고리즘이 C - D 를 선택했을 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 만약에 C - E 간선을 제거하고, C - D 간선을 연결하면 어떻게 될까? 이 또한 스패닝 트리가 되는 것을 알 수 있다. 따라서 가중치가 더 작은 간선을 선택해서 스패닝트리를 만들 수 있으므로, 처음의 A → B → C → E → F → D 가 최소 스패닝 트리라는 가정에서 모순 된다.&lt;/p&gt;

&lt;p&gt;일반화를 시키자면, 실제 최소 스패닝트리 T 에 속하지 않으면서 크루스칼 알고리즘이 선택한 간선을 (u, v) 라고 하자. T 또한 스패닝 트리이므로 u 와 v 는 어떤 식으로든 연결이 되어 있을 것이다. 크루스칼 알고리즘은 최솟값부터 선택해나가므로 T에는 존재하지만 크루스칼이 선택하지 않은 간선 (a, b) 는 (u, v) 보다 무조건 가중치가 같거나 높을 수 밖에 없다. (a, b) 가 (u, v) 보다 가중치가 낮았다면 크루스칼은 (u, v) 가 아니라 (a, b) 를 선택했을 것이다.&lt;/p&gt;

&lt;p&gt;이제 T 에서 u 와 v 를 잇는 경로 상의 어떠한 간선 하나를 제거하고, (u, v) 간선을 선택해보자. 이 때 간선 하나를 없앴지만 (u, v) 간선이 생겼으므로 스패닝 트리가 유지됨을 알 수 있고, 같거나 더 짧은 간선을 선택하면서 스패닝트리를 유지할 수 있으므로 T가 최소 스패닝 트리라는 가정에 모순이 생긴다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;항상 최적의 선택(남은 간선 중에, 사이클이 생기지 않는 가장 짧은 간선을 선택)만을 내려도 전체 문제의 최적해를 얻을 수 있어야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이는, 매 단계마다 선택되는 간선이 항상 최적의 부분 문제 해를 만족한다는 점에서 최적 부분 구조가 성립함을 쉽게 알 수 있다.&lt;/p&gt;

&lt;p&gt;매 단계마다 선택하는 가장 짧은 간선은, 그 간선이 만드는 그래프 자체를 가장 짧은 경로로 갈 수 있게 한다. 따라서 항상 최적의 부분 문제 해를 만족하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;프림-알고리즘&quot;&gt;프림 알고리즘&lt;/h2&gt;

&lt;p&gt;크루스칼 알고리즘은 어느 간선이든 최솟값이면 선택하지만 프림 알고리즘은 현재 만들어진 트리에 이어진 간선만을 선택해나가면서 스패닝 트리를 만들게 된다.&lt;/p&gt;

&lt;p&gt;프림 알고리즘도 트리에 이어진 간선 중에서 최솟값을 선택하기 때문에 크루스칼 알고리즘과 비슷하기도 하다.&lt;/p&gt;

&lt;p&gt;그런데 이런 과정을 어딘가에서 많이 본 것 같다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;정점을 추가하면서, 정점에 연결된 간선 중에서 가장 짧은 간선을 선택해나가는 방식&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이 방식은 다익스트라 알고리즘과 상당히 유사해보인다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-동작-방식-1&quot;&gt;알고리즘 동작 방식&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;프림 알고리즘 예시 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프로 동작 방식을 한 번 살펴보자. 시작점은 A 라고 해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/13.png&quot; alt=&quot;13&quot; /&gt;&lt;em&gt;A - C 간선, 정점 C 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/14.png&quot; alt=&quot;14&quot; /&gt;&lt;em&gt;C - D 간선, 정점 D 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/15.png&quot; alt=&quot;15&quot; /&gt;&lt;em&gt;A - B 간선, 정점 B 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/16.png&quot; alt=&quot;16&quot; /&gt;&lt;em&gt;D - F 간선, 정점 F 추가&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 왜, 더 짧은 간선인 B - C(5), B - D(6) 을 선택하지 않았냐면 이미 정점 리스트에 들어가있는 C 와 D 를 잇는 간선이기 때문이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-20-스패닝_트리.md/17.png&quot; alt=&quot;17&quot; /&gt;&lt;em&gt;E - F 간선, 정점 E 추가&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;증명-1&quot;&gt;증명&lt;/h3&gt;

&lt;p&gt;프림 알고리즘은 크루스칼 알고리즘과 동일하게 간선의 최솟값을 사용하므로 증명이 크루스칼 알고리즘과 똑같다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">스패닝 트리</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)</title>
      <link href="https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)" rel="alternate" type="text/html" title="정점간의 최단 거리 구하기 (다익스트라, 벨만 포드, 플로이드)" />
      <published>2025-01-16T02:20:00+00:00</published>
      <updated>2025-01-16T02:20:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%A0%95%EC%A0%90%EA%B0%84%EC%9D%98_%EC%B5%9C%EB%8B%A8_%EA%B1%B0%EB%A6%AC_%EA%B5%AC%ED%95%98%EA%B8%B0_(%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC,_%EB%B2%A8%EB%A7%8C_%ED%8F%AC%EB%93%9C,_%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C)">&lt;p&gt;정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.&lt;/p&gt;

&lt;h1 id=&quot;다익스트라&quot;&gt;다익스트라&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;단일 시작점 최단 경로 알고리즘&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다익스트라 알고리즘은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;너비 우선 탐색과 유사&lt;/code&gt; 한 형태를 가진 알고리즘으로, 시작점에서 가까운 순서대로 정점을 방문한다. 다만 가중치(거리)가 있다보니 BFS 와 완전히 동일한 방식을 사용할 수는 없다.&lt;/p&gt;

&lt;h2 id=&quot;우선순위-큐&quot;&gt;우선순위 큐&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐&lt;/code&gt; 를 활용한다. 우선순위 큐에 대한 자바스크립트의 구현은 &lt;a href=&quot;/우선순위_큐&quot;&gt;여기&lt;/a&gt; 를 참고하면 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(정점의 번호, 정점까지의 거리)&lt;/code&gt; 를 우선순위 큐에 넣어서 정점까지의 거리를 기준으로 우선순위 큐를 사용한다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점에서 다른 정점까지의 거리를 저장하는 배열&lt;/code&gt; 에 저장하면 된다. (간단히 dist 라고 부르자)&lt;/p&gt;

&lt;p&gt;우선순위 큐에서 최단 경로의 정점을 하나씩 꺼내면서 해당 정점과 연결된 정점들을 우선순위 큐에 넣는 것을 반복한다.&lt;/p&gt;

&lt;p&gt;만약 v 에 아직 방문하지 않았고, 간선 (u, v) 를 검사한다고 하면 u 까지의 최단 거리에 간선 (u, v) 의 가중치를 더해서 v 까지의 거리를 구한다.&lt;/p&gt;

&lt;p&gt;만약 이 거리가 최단 거리라면 dist[v] 를 갱신하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(dist[v], v)&lt;/code&gt; 를 우선순위 큐에 다시 넣는다.&lt;/p&gt;

&lt;p&gt;여기서 주의해야할 것은 최단거리는 언제든지 갱신될 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;간선 (u, v) 를 탐색하면서 (dist[v], v) 를 우선순위 큐에 넣었는데 다른 정점을 돌면서 더 짧은 (dist[v], v) 를 우선순위 큐에 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 되면 우선순위 큐에 (dist[v], v) 가 여러 개 생길 것이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- 8 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 그래프에서 시작점이 A 라고 하자.  시작점을 탐색하면서 (20, D) 가 우선순위 큐에 들어가게 될 것이다.&lt;/p&gt;

&lt;p&gt;그러나 A, B, E 를 탐색하면서 (10 + 2 + 5, D) 도 우선 순위 큐에 들어가게 된다.&lt;/p&gt;

&lt;p&gt;이 경우에 (20, D) 는 우선순위 큐에서 pop 된다고 해도 무시되어야 한다.&lt;/p&gt;

&lt;p&gt;(20, D) 가 pop 되었다는 것은 이미 이전에 (17, D) 가 pop 되었다는 것이고 dist[D] 는 17 일 것이다.&lt;/p&gt;

&lt;p&gt;따라서 dist[D] 와의 비교를 통해서 더 짧은 경로가 이전에 이미 탐색되었는지를 확인하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;증명&quot;&gt;증명&lt;/h2&gt;

&lt;p&gt;다익스트라의 증명은 귀류법(어떤 명제가 참이라고 가정한 후, 모순을 이끌어내 그 가정이 거짓임을, 즉 처음의 명제가 거짓임을 증명하는 방법) 을 통해 가능하다.&lt;/p&gt;

&lt;p&gt;여기서는 다익스트라를 통해 최단거리를 구할 수 없다고 가정하고 모순을 이끌어내려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- ? ---- B
   |             |
   ?             ?
   |             |
   D ---- ? ---- E -- ? -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다시 위의 그래프를 활용해서 이야기해보자.&lt;/p&gt;

&lt;p&gt;시작점 A 부터 E 까지의 거리를 구하는 것이 목표이고, 실제로는 A - D - E 가 가장 짧다고 하자.&lt;/p&gt;

&lt;p&gt;여기서 다익스트라 알고리즘이 최단 거리를 제대로 구하지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;못한다&lt;/code&gt;고 가정하기 위해, 다익스트라 알고리즘이 A - B - E 가 가장 짧은 최단경로라는 결론을 내렸다고 가정해보자.&lt;/p&gt;

&lt;p&gt;도착점 E 에 도착한 순간, 어떤 정점은 이미 방문을 했을거고 또 어떤 정점은 우선순위 큐에 들어가 있는 상태일 수 있다.&lt;/p&gt;

&lt;p&gt;만약 D 를 방문하지 않은 상태라고 가정해보면, D 까지의 최단 거리는 dist[A] + w(A, D) 가 된다. 그런데 이미 방문한 정점 A 를 탐색하면서 D는 무조건 우선순위 큐에 (D, dist[A] + w(A, D)) 로 들어가게 되었을 것이다.&lt;/p&gt;

&lt;p&gt;A - B - E 로 진행하면서 E 또한 우선순위 큐에 들어가게 될텐데 여기서 이미 들어가있던 D 가 아닌 E 가 pop 되었다는것은 dist[E] 가 dist[D] 보다 작았기 때문이다.&lt;/p&gt;

&lt;p&gt;즉 dist[D] ≥ dist[E] 라는 소린데, 이는 D 를 거쳐서 A 에서 E 로 가는 것이 가장 짧은 경로라면 성립할 수가 없다.&lt;/p&gt;

&lt;h2 id=&quot;음수-가중치를-계산할-수-있는가&quot;&gt;음수 가중치를 계산할 수 있는가?&lt;/h2&gt;

&lt;p&gt;일반적으로 다익스트라 알고리즘은 음수 가중치가 있다면 정확한 최단 거리를 계산하지 못한다.&lt;/p&gt;

&lt;p&gt;음수 가중치가 있다는것은 이미 최단거리로 처리된 노드가 나중에 더 최단거리로 갱신될 가능성이 있다는 것이기 때문이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;text
Graph:
   A ---- 10 --- B
   |             |
   20            2
   |             |
   D ---- 5 ---- E -- -100 -- C

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다익스트라를 돌면서 E 의 최단 거리는 (10 + 2) 가 되겠지만 실제로는 10 + 2 - 100 이다.&lt;/p&gt;

&lt;p&gt;다시 말해서 이미 처리된 정점이 최단 거리라는 가정을 깨뜨릴 수 있다.&lt;/p&gt;

&lt;p&gt;만약 이미 처리된 정점이 최단 거리라는 가정을 버리고 (방문한 정점에 대한 기록을 하지 않고) 다익스트라를 작성한다면 음수 가중치를 계산할 수도 있다. 하지만, 이 경우에는 시간 복잡도가 정점의 갯수에 대해 지수함수로 증가할 수 있기 때문에 굳이 이런 식으로 다익스트라 알고리즘을 쓸 이유가 없다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;다익스트라의 시간 복잡도는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각 정점마다 인접한 간선들은 모두 검사&lt;/code&gt; 하는 작업과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/code&gt; 하는 작업으로 나눌 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;각-정점마다-인접한-간선들을-모두-검사&quot;&gt;각 정점마다 인접한 간선들을 모두 검사&lt;/h3&gt;

&lt;p&gt;정점의 갯수를 E, 간선의 갯수를 V 라고 할 때,&lt;/p&gt;

&lt;p&gt;각 정점마다 인접한 간선들을 모두 검사하는 작업은 정확히 모든 간선을 1번씩 검사하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(E)&lt;/code&gt; 의 시간이 걸리게 된다.&lt;/p&gt;

&lt;h3 id=&quot;우선순위-큐에-원소를-넣고-삭제&quot;&gt;우선순위 큐에 원소를 넣고 삭제&lt;/h3&gt;

&lt;p&gt;우선순위 큐에 원소를 넣고 삭제하는 작업에서 최악의 경우에는 그래프의 모든 간선이 검사될 때마다 dist 배열이 갱신되면서 동시에 우선순위 큐에 정점의 번호가 추가되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/0.png&quot; alt=&quot;0&quot; /&gt;_다익스트라 최악의 경우 _&lt;/p&gt;

&lt;p&gt;위의 그래프에서 왼쪽의 핑크색 1번이 시작점이라고 하자.&lt;/p&gt;

&lt;p&gt;1번에서 2, 3, 4 까지의 dist 배열은 각각 6, 10, 15로 갱신되면서 우선순위 큐에 (2, 6), (10, 3), (15, 4) 로 들어갈 것이다.&lt;/p&gt;

&lt;p&gt;그러고 나서 2번 정점을 탐색하면서 dist[3] 은 6 + 3 으로 갱신되고, 우선순위 큐에 (9, 3) 이 추가 된다.&lt;/p&gt;

&lt;p&gt;이제 3번 정점을 탐색하면서 dist[4] 도 10 + 3 으로 갱신되고, 우선순위 큐에 (13, 4) 로 갱신 된다.&lt;/p&gt;

&lt;p&gt;이처럼 최악의 시나리오에서는 각 간선마다 한 번씩 추가가 되고, 우선순위 큐에 원소를 추가하거나 삭제하는데 O(logE)의 시간이 걸리고 이를 O(E) 개의 원소에 대해 작업을 해야하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(ElogE)&lt;/code&gt; 가 된다.&lt;/p&gt;

&lt;h3 id=&quot;일반적인-시간-복잡도&quot;&gt;일반적인 시간 복잡도&lt;/h3&gt;

&lt;p&gt;위의 두 과정을 더하게 되면 O(E + ElogE) = O(ElogE) 가 되는데, 보통 그래프에서 간선의 개수 E 는 V^2 보다 작기 때문에 O(logE) = O(logV) 라고 볼 수 있다. 따라서 O(ElogV) 라고 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;다익스트라 알고리즘을 통해 최단 거리뿐만 아니라 최단 경로를 구하려면 정점에 도착하기 직전의 정점을 기록해서 역추적을 하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;벨만-포드&quot;&gt;벨만 포드&lt;/h1&gt;

&lt;p&gt;다익스트라 알고리즘과 똑같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일&lt;/code&gt; 시작점 최단 경로 알고리즘이지만, 음수 가중치가 있는 그래프에서도 최단 경로를 찾을 수 있다.&lt;/p&gt;

&lt;p&gt;또한 음수 사이클이 있어서 최단 거리를 제대로 구하지 못하는 경우도 알 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;벨만포드 알고리즘은 시작점에서 각 정점까지 가는 최단 거리의 상한을 적당히 예측한 뒤, 예측 값과 실제 최단 거리 사이의 오차를 반복적으로 줄여가는 방식이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;알고리즘-동작&quot;&gt;알고리즘 동작&lt;/h2&gt;

&lt;p&gt;시작점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;, 도착점 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d&lt;/code&gt; , dist[k] = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작점부터 k 까지의 최단 거리&lt;/code&gt; , w(u, v) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;= u와 v 사이의 간선 가중치&lt;/code&gt; 라고 하자. upper[k] 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;현재까지 계산된&lt;/code&gt;시작점부터 k 까지의 최단 거리이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 맨 처음에는 시작점부터 시작점사이의 거리가 0이라는 것을 제외하면, 아무것도 알고 있는 것이 없다. 따라서 upper[s] = 0 으로 초기화하고 나머지는 양의 무한대 혹은 매우 큰 수로 초기화한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;완화&quot;&gt;완화&lt;/h3&gt;

&lt;p&gt;이제부터 우리는 upper 배열의 값을 점차 실제 최단 거리에 가깝도록 줄여나갈 것이다. 그러려면 최단 거리의 특성을 이용해야 하는데, 아래의 특성을 살펴보자&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;dist[v] ≤ dist[u] + w(u, v)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;dist[v] 는 v 까지 최단 거리인데, 만약 u를 거쳐서 v 로 오는 거리가 더 짧다면, u를 거쳐오는 거리가 최단 거리여야한다. 그렇기때문에 dist[v] 가 최단 거리라는 가정에 위배된다.&lt;/p&gt;

&lt;p&gt;이번에는 upper[u] + w(u, v) &amp;lt; upper[v] 인 상황을 생각해보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;upper[v] 를 upper[u] + w(u, v) 로 줄이려고 하는 것이 이번 과정의 목표이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;u 까지의 최단 거리는 항상 upper[u] 보다 작거나 같을 것이다.&lt;/p&gt;

&lt;p&gt;여기서 upper[u] + w(u, v) 는 u를 거쳐 v 로 가는 경로 이므로 만약 upper[u] + w(u, v) 가 upper[v] 보다 작다는 것은, u를 거쳐서 v 로 가는 것이 현재까지 계산된 v로 가는 최단 거리보다 짧다는 것이다.&lt;/p&gt;

&lt;p&gt;즉 upper[v] 를 upper[u] + w(u, v) 로 갱신할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 과정을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완화&lt;/code&gt; 라고 하고 이를 계속 수행하면서 최단거리가 되도록 한다.&lt;/p&gt;

&lt;h3 id=&quot;완화를-얼마나-해야하는가&quot;&gt;완화를 얼마나 해야하는가?&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/1.png&quot; alt=&quot;1&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;최단거리는 결국, 어느 한 지점까지의 최단거리에서 간선을 더한 값으로 완화되어야 한다.&lt;/p&gt;

&lt;p&gt;무슨 이야기냐 하면 시작점 s 에서 연결된 정점 a 가 있다고 하자.&lt;/p&gt;

&lt;p&gt;모든 간선을 순회하면서 한 번씩 완화를 시도했다고 하자.&lt;/p&gt;

&lt;p&gt;이때 upper[a] 는 upper[s] + w(s, a) 로 완화될 수 있다. 그런데 upper[s] 는 시작점 s 부터 s 까지의 거리이므로 당연히 0이 된다.&lt;/p&gt;

&lt;p&gt;즉, upper[a] 는 w(s, a) 로 완화될 수 있다. w(s, a) 로 완화하고 나면, 시작점 s 부터 a 까지의 가는 경로중에 w(s, a) 보다 짧은 거리가 있을 수 있을까?&lt;/p&gt;

&lt;p&gt;없다. 위의 그래프에서 s 에서 b 로 가는 최단 거리가 s → b 말고 더 있을 수는 없다.&lt;/p&gt;

&lt;p&gt;여기서 만약 s → b → c → b 가 더 짧을 수도 있지 않을까 라는 생각이 들었다면 이는 음수 사이클이다. 이 경우에는 s→ b → c → b 보다 s → b → c → b → c → b 가 더 짧고 이를 무한반복하면 당연히 더 짧아진다.&lt;/p&gt;

&lt;p&gt;음수 사이클은 기본적으로 존재하는 순간 모든 그래프에서 최단 경로라는 말을 사용할 수가 없다.&lt;/p&gt;

&lt;p&gt;이는 조금 뒤에서 더 자세히 살펴보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그래서 전체 간선에 대한 완화를 몇 번이나 수행해야 하는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 그래프를 보면 전체 간선에 대한 완화를 1회 수행하면, a와 b 까지의 최단 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;2번 수행하면 c, 3번 수행하면 d 까지의 거리를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 s → a → b → c → d 의 모양을 가진 그래프라면 어떨까?&lt;/p&gt;

&lt;p&gt;총 4회에 거쳐 a, b, c, d 까지의 최단 거리가 완화될 것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서 정점의 갯수가 V 개 일때, 아무리 많이 해도 V - 1 번이면 모든 정점들까지의 거리가 최단 거리로 완화된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;음수-사이클&quot;&gt;음수 사이클&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/2.png&quot; alt=&quot;2&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 그래프를 한 번 살펴보자. A → B → C 경로를 살펴보면 A → B 는 1 이 필요한데 B → C → A 는 가중치의 합이 -3 이다. A → B → C → A 는 결국 -2 의 가중치를 갖는다.&lt;/p&gt;

&lt;p&gt;어떠한 사이클이 합이 음의 가중치를 가지는 순간, 이 사이클을 무한 반복 함으로써 가중치의 합도 음의 무한대를 가지게 할 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;다시 말해서, 정점의 개수를 V 라고 할 때, 완화가 V - 1 번 이후에도 계속 이루어진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이렇게 보면 음수 사이클을 판별하는 방법은 쉽다.&lt;/p&gt;

&lt;p&gt;V - 1 번까지 완화를 진행하고 V 번째 완화를 시도해보면 된다. 만약 완화가 이루어졌다면 음수 사이클이 존재하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;경로-추적-1&quot;&gt;경로 추적&lt;/h2&gt;

&lt;p&gt;벨만 포드의 경로 추적은 다익스트라의 경로 추적과 유사하다. 다익스트라처럼 역추적을 하면 되는데,&lt;/p&gt;

&lt;p&gt;각 정점을 마지막으로 완화시킨 간선들을 토대로 역추적하면 된다. (이 간선들은 항상 최단경로의 위에 있기 때문)&lt;/p&gt;

&lt;h2 id=&quot;경로-존재-유무-판별하기&quot;&gt;경로 존재 유무 판별하기&lt;/h2&gt;

&lt;p&gt;시작점 s 에서 u 까지의 경로가 있는지 판별하는 방법은 쉽게 생각하면 upper[u] 가 Infinity 가 아니면 경로가 있다라고 착각할 수 있다.&lt;/p&gt;

&lt;p&gt;경로가 있으면 무조건 완화가 이루어질 것이라고 생각할 수 있기 때문이다. 하지만 음수 사이클이 있다면 이야기가 조금 달라진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/3.png&quot; alt=&quot;3&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위처럼 시작점 s 가 다른 정점들과 간선이 없다고 해도, a ↔ b 사이의 음수 사이클을 통한 완화가 이루어질 수 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 경로의 존재 유무를 판별하려면 upper[u] 가 Infinity 인지 아닌지로 판별하는 것이 아닌, 적당히 큰 값 M 에 대해서 upper[u] &amp;lt; Infinity - M 인지를 확인해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;적당히-큰-값-m&quot;&gt;적당히 큰 값 M..?&lt;/h3&gt;

&lt;p&gt;M 은 그러면 어떻게 결정할 수 있을까?&lt;/p&gt;

&lt;p&gt;우리는 위에서 완화를 최대 V - 1 번 진행한다고 했다. 그렇기 때문에 음수 사이클을 돌면서 완화된다고 했을 때, 한 번의 완화에 가장 많이 완화되는 값은 가장 작은 가중치값의 2배를 넘지 않을 것이다.&lt;/p&gt;

&lt;p&gt;위의 그래프에서는 한 번의 완화당 -1 씩 (-2 + 1) 작아진다.&lt;/p&gt;

&lt;p&gt;따라서 (가장 작은 가중치 * 2) * (V - 1) 로 M 을 설정하면 될 것 같다.&lt;/p&gt;

&lt;h2 id=&quot;시간-복잡도-1&quot;&gt;시간 복잡도&lt;/h2&gt;

&lt;p&gt;벨만 포드 알고리즘은 모든 간선을 순회하는 작업을 정점의 갯수 - 1 번 만큼 진행한다. 음수 사이클을 판별하려면정점의 갯수만큼 진행하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;따라서 O(E * V) 가 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정점의 갯수 : V, 간선의 갯수 : E&lt;/p&gt;

&lt;h1 id=&quot;플로이드&quot;&gt;플로이드&lt;/h1&gt;

&lt;p&gt;다익스트라와 벨만 포드 알고리즘은 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한 시작점에서 다른 모든 정점까지의 거리&lt;/code&gt; 를 구하는 알고리즘이었다. 플로이드는 한 시작점이 아닌, 모든 정점에서 모든 정점까지의 거리를 구할 수 있는 알고리즘이다.&lt;/p&gt;

&lt;p&gt;사실 플로이드를 굳이 안쓰고 모든 정점에서 한 번씩 다익스트라 알고리즘을 수행해도 구할 수 있다. 음수 가중치가 있다면 모든 정점에서 벨만 포드 알고리즘을 쓸 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 이런 방법보다는 더 빠르게 수행할 수 있는 알고리즘이 플로이드 와샬 알고리즘이다.&lt;/p&gt;

&lt;p&gt;플로이드 알고리즘은 생각보다 간단하다.&lt;/p&gt;

&lt;p&gt;정점 u 에서 v 까지의 거리를 dist[u][v] 라고 정했을 때 3중 for 문을 돌면서 u → ? → v 로 갔을 때, 거리가 갱신되는지 살펴보는 것이다.&lt;/p&gt;

&lt;p&gt;그런데 플로이드 알고리즘의 프로토타입을 글로 읽고 이해하려니 꽤나 많은 생각을 거쳐야 했다.&lt;/p&gt;

&lt;h2 id=&quot;프로토타입&quot;&gt;프로토타입&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/4.png&quot; alt=&quot;4&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/5.png&quot; alt=&quot;5&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위의 표현식은 a 에서 출발하여 c, d 를 거쳐 b 로 가는 경로이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 그래프에서 정점들의 집합을 S 라고 하고, 임의의 점을 x 라고 하자.&lt;/p&gt;

&lt;p&gt;a 에서 f 로 가는 경로에서 x 를 경유하는 것과, 경유하지 않은 것을 나누어 나타내면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/6.png&quot; alt=&quot;6&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;기호가 너무 많아서 햇갈릴 수 있는데 a → f 의 경로는 x 를 경유해서 가는 것과 경유해서 가지 않는 것의 최소값이라는 의미일 뿐이다.&lt;/p&gt;

&lt;p&gt;여기서 이 점화식을 살짝 수정해서 더 보기 좋게 만들어보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/7.png&quot; alt=&quot;7&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 가지의 식을 활용해서 위의 식을 바꾸면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/8.png&quot; alt=&quot;8&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이 된다.&lt;/p&gt;

&lt;p&gt;이제서야 우리가 자주 보던 점화식같이 생겼다.&lt;/p&gt;

&lt;p&gt;여기서&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/9.png&quot; alt=&quot;9&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이렇게 두 식의 차이점에 대해서 한 번 생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/10.png&quot; alt=&quot;10&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;위의 식은 k 를 거치지 않고 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/11.png&quot; alt=&quot;11&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;반대로 위의 식은 k 까지 거쳐서 a 에서 k 까지 가는 경로를 의미한다.&lt;/p&gt;

&lt;p&gt;그런데 k 까지 가는데 k 를 거치든 안거치든 그게 다를 수 있나?&lt;/p&gt;

&lt;p&gt;도착점이 k 이므로 k를 거치는것과 안거치는것은 당연히 같다.&lt;/p&gt;

&lt;p&gt;따라서 위의 식이 같다라고 생각하게 되면 식은 더욱 간단해진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/upload/2025-01-16-정점간의_최단_거리_구하기_(다익스트라,_벨만_포드,_플로이드).md/12.png&quot; alt=&quot;12&quot; /&gt;&lt;em&gt;image.png&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이제 우리가 알던 플로이드 알고리즘인, 경유점 하나를 거쳐서 가는것과 안거쳐서 가는 것 중에서 더 짧은 것을 선택하는 식이 된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">정점간의 최단 거리를 구하는 알고리즘들에 대해서 한 번 알아보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">이분 탐색</title>
      <link href="https://hoeeeeeh.github.io/%EC%9D%B4%EB%B6%84_%ED%83%90%EC%83%89" rel="alternate" type="text/html" title="이분 탐색" />
      <published>2025-01-14T02:11:00+00:00</published>
      <updated>2025-01-14T02:11:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%9D%B4%EB%B6%84_%ED%83%90%EC%83%89</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%9D%B4%EB%B6%84_%ED%83%90%EC%83%89">&lt;h1 id=&quot;이분-탐색&quot;&gt;이분 탐색&lt;/h1&gt;

&lt;p&gt;알고리즘 문제에서 단골 문제로 등장하는 이분 탐색을 정리하려고 한다.&lt;/p&gt;

&lt;p&gt;단순히 Target 을 찾는 것부터, Target 이 들어갈 자리(lower bound, upper bound)를 찾는 방법에 대해서도 한 번 정리해보자.&lt;/p&gt;

&lt;h2 id=&quot;이분-탐색target과-동일한게-있을-때&quot;&gt;이분 탐색(Target과 동일한게 있을 때)&lt;/h2&gt;

&lt;p&gt;이분 탐색의 가장 기초적인 형태로, 찾고 싶은 Target 이 몇 번째 인덱스에 존재하는지 찾는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python
def simple_binary_search(target: int, arr: list):
    # 오름차순이라고 가정, 만약 arr 의 정렬이 보장되어 있지 않다면 정렬을 해야한다.
    arr.sort()

    start = 0
    end = len(arr) - 1

    while start &amp;lt;= end:
        mid = (start + end) // 2
        print(mid, arr[mid])

        if target &amp;gt; arr[mid]:
            start = mid + 1
        elif target &amp;lt; arr[mid]:
            end = mid - 1
        else:
            # target == arr[mid]
            return mid

    # target 을 찾지 못함
    return -



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이분 탐색은 말 그대로, 이등분하여 탐색하는 알고리즘이다. 로직을 자세히 보아도 이해하는데 크게 어려움은 없다.&lt;/p&gt;

&lt;p&gt;그렇다면 target 이상인 것 중에 가장 첫 번째 인덱스를 찾고 싶거나, target 보다 큰 것중에 가장 작은 인덱스를 찾는 방법을 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;lower-bound&quot;&gt;Lower Bound&lt;/h2&gt;

&lt;p&gt;(target &amp;lt;= arr[idx]) target 보다 크거나 같은 것 중에 가장 첫 번째 인덱스를 찾고 싶다면 어떻게 해야할까?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python
arr = [1, 3, 5, 5, 5, 7, 9]
target = 5

# 원하는 정답 = 2 (5, 5, 5의 인덱스 중에서 가장 작은 인덱스)
# 위의 simple_binary_search() 함수의 결과값 = 3

def lower_bound_bisect(target: int, arr: list):
    # 오름차순이라고 가정, 만약 arr 의 정렬이 보장되어 있지 않다면 정렬을 해야한다.
    arr.sort()

    start = 0
    end = len(arr)

    while start &amp;lt; end:
        mid = (start + end) // 2
        print(mid, arr[mid])

        if target &amp;gt;= arr[mid]:
            end = mid
        elif target &amp;lt; arr[mid]:
            start = mid + 1

        &quot;&quot;&quot;
        만약 target 보다 작다면, start 를 mid + 1 로 바꿔서 이분한 배열의 오른쪽만 다시 확인하게 하고
        만약 target 보다 크거나 같다면, mid 를 포함한 채로, 배열의 왼쪽을 다시 살펴본다.

        왜 mid - 1 이 아니라, mid 일까? -&amp;gt; 찾고 싶은 것이 `target 보다 크거나 같은 것` 이므로, target &amp;gt;= arr[mid] 를 만족하는 순간
        우리가 찾고자 하는 것이다. 그렇기 때문에 정답 범주에 넣어두어야 한다.
        &quot;&quot;&quot;
    return start



&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;upper-bound&quot;&gt;Upper Bound&lt;/h2&gt;

&lt;p&gt;이번에는 target 보다 큰 것 중에, 가장 작은 인덱스 값을 알아보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python
arr = [1, 3, 5, 5, 5, 7, 9]
target = 5

# 원하는 정답 = 5 (1, 3, 5, 5, 5까지는 target 보다 작거나 같은 값이고, 7부터 target 보다 큰 값이므로)

def upper_bound_bisect(target: int, arr: list):
    # 오름차순이라고 가정, 만약 arr 의 정렬이 보장되어 있지 않다면 정렬을 해야한다.
    arr.sort()

    start = 0
    end = len(arr)

    while start &amp;lt; end:
        mid = (start + end) // 2
        print(mid, arr[mid])

        if target &amp;gt; arr[mid]:
            end = mid
        elif target &amp;lt;= arr[mid]:
            start = mid + 1
        &quot;&quot;&quot;
        만약 target 보다 작거나 같다면, start 를 mid + 1 로 바꿔서 이분한 배열의 오른쪽만 다시 살펴보게 하고
        만약 target 보다 크다면, mid 를 포함한 채로 왼쪽을 다시 살펴보게 한다.

        왜 mid - 1 이 아니라, mid 일까? -&amp;gt; 찾고 싶은 것이 `target 보다 큰 것` 이므로, target &amp;gt; arr[mid] 를 만족하는 순간
        우리가 찾고자 하는 것이다. 그렇기 때문에 정답 범주에 넣어두어야 한다.
        &quot;&quot;&quot;
    return start


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;차이점&quot;&gt;차이점&lt;/h2&gt;

&lt;p&gt;단순 이분 탐색과 lower / upper bound 의 while 종료 조건 차이점을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while start &amp;lt;= end&lt;/code&gt; 와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while start &amp;lt; end&lt;/code&gt; 이 있는데, Lower/Upper 탐색은 1캰씩 움직이며 찾아나가는데 start &amp;lt;= end 로 하게 되면 소수점 버림으로 인해서 무한 루프에 빠질 수 있다.&lt;/p&gt;

&lt;p&gt;또한 Lower/Upper 의 return 은 mid 가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start&lt;/code&gt; 인데, 이는 당연하게도 Lower 과 Upper 이 각각 크거나 같은 것 중에 최소값, 큰 것 중에 최소값을 return 해야하기 때문이다.&lt;/p&gt;

&lt;p&gt;Lower/Upper 의 end 초기값도 조금 다른데, len(arr) - 1 이 아니라, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len(arr)&lt;/code&gt; 이다. 이는 조건을 만족하는 곳이 없으면 무조건 len(arr) 의 위치에 넣으면 되기 때문이다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">이분 탐색</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">우선순위 큐</title>
      <link href="https://hoeeeeeh.github.io/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84_%ED%81%90" rel="alternate" type="text/html" title="우선순위 큐" />
      <published>2025-01-14T02:11:00+00:00</published>
      <updated>2025-01-14T02:11:00+00:00</updated>
      <id>https://hoeeeeeh.github.io/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84_%ED%81%90</id>
      <content type="html" xml:base="https://hoeeeeeh.github.io/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84_%ED%81%90">&lt;p&gt;이번에 네이버 부스트 캠프 베이직 과정을 진행하면서 자바스크립트를 쓰게 되었는데, 평소에는 파이썬을 자주 사용했었기 때문에 자바스크립트로 파이썬을 대체해보려고 노력했다.&lt;/p&gt;

&lt;p&gt;다만 파이썬에는 여러가지 자료구조와 함수들이 잘 구현되어 있는데 자바스크립트를 써보니까 우선순위 큐가 내장 라이브러리에 없었다!&lt;/p&gt;

&lt;p&gt;이번 기회에 자바스크립트 공부 겸 힙과 우선순위 큐에 대해 다시 복습하고 직접 구현해보려고 한다.&lt;/p&gt;

&lt;h1 id=&quot;heap&quot;&gt;Heap&lt;/h1&gt;

&lt;p&gt;우선 순위 큐는 힙 자료구조를 사용하기 때문에 힙이 무엇인지 알고 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;힙(Heap)&lt;/code&gt; 는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최댓값 혹은 최솟값을 빠르게 찾아내는 연산을 위해&lt;/code&gt; 설계된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완전 이진 트리&lt;/code&gt; 자료구조이다.&lt;/p&gt;

&lt;p&gt;최댓값을 빠르게 찾고 부모노드의 키 값이 자식 노드의 키 값보다 항상 큰 힙을 최대 힙, 최솟값을 빠르게 찾고 부모노드의 키 값이 자식 노드의 키 값보다 항상 작은 힙을 최소 힙이라고 부른다.&lt;/p&gt;

&lt;p&gt;우선 순위 큐에서도 작을 수록 우선순위가 높은지, 클 수록 우선순위가 높은지에 따라 최대 힙, 최소 힙을 적절히 사용해야 한다.&lt;/p&gt;

&lt;p&gt;보통 최소 힙 라이브러리가 내장되어 있기 때문에, 만약 클 수록 우선순위가 높다면 데이터 전체에 -1 을 곱하는 등의 처리를 통해 최소 힙을 최대 힙처럼 사용할 수도 있다.&lt;/p&gt;

&lt;h1 id=&quot;우선-순위-큐&quot;&gt;우선 순위 큐&lt;/h1&gt;

&lt;p&gt;그렇다면 우선 순위 큐는 어떤 식으로 구현되어 있을까?&lt;/p&gt;

&lt;p&gt;최소 힙과 최대 힙은 거의 유사하기도 하고, 위에서 말한 것처럼 활용할 수도 있기 때문에 최소 힙 우선순위 큐를 한 번 살펴보려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class PriorityQueue {
  constructor() {
    this.heap = []; // 데이터를 담을 배열
  }

  enqueue(value) {
    // 1. 힙 자료구조에 value 를 넣고
    // 2. value 가 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; 아래의 bubbleUp 함수를 사용할 예정
  }

  dequeue() {
    // 1. 힙 자료구조의 루트 노드에 해당하는 값을 임시로 저장해두고
    // (pop 이 아님! pop(0)은 O(n) 의 시간복잡도를 가지기 떄문에 힙 자료구조를 사용하는 의미가 없어짐
    // 2. 맨 마지막 리프 노드에 해당하는 값을 루트 노드에 저장하고,
    // 3. 해당 루트 노드의 값이 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; 아래의 bubbleDown 함수를 사용할 예정
  }

  peek() {
    // 루트 노드를 pop 하는 것이 목적이 아닌, 그저 루트 노드를 참조하고자 할 때
    return this.heap.length &amp;gt; 0 ? this.heap[0] : null;
  }

  bubbleUp(index) {
    // index 번 째에 해당하는 노드의 값보다 작은 값이 있다면, index 노드를 위로 올려보내야 한다.
  }

  bubbleDown(index) {
    // index 번 째에 해당하는 노드의 값보다 큰 값이 있다면, index 노드를 아래로 내려보내야 한다.
  }

  swap(i, j) {
    // i, j 값 스왑
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;함수를 구현하기 전에 간략한 설명과 함께 하나씩 구현해보자.&lt;/p&gt;

&lt;h2 id=&quot;bubbleup&quot;&gt;bubbleUp&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
bubbleUp(index) {
  // index 번 째에 해당하는 노드의 값보다 작은 값이 있다면, index 노드를 위로 올려보내야 한다.
    while (index &amp;gt; 0) {
    const parentIndex = Math.floor((index - 1) / 2); // index 노드의 부모 노드 구하기.
    if (this.heap[parentIndex] &amp;lt;= this.heap[index]) break; // 최소 힙이므로 부모노드는 항상 자식 노드보다 작거나 같다!

    this.swap(index, parentIndex); // index 랑 부모노드랑 스왑
    index = parentIndex; // 부모노드로 올라간 index 부터 반복
  }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자식노드(index) 와 부모노드를 비교하는 bubbleUp 함수.&lt;/p&gt;

&lt;p&gt;bubbleUp 함수는 우리가 버블정렬을 하는 것 처럼, 두 값을 비교해서 위치를 바꾸는 함수이다.
최소 힙을 구현하려고 하므로 부모노드는 항상 자식 노드보다 작거나 같아야 한다.&lt;/p&gt;

&lt;p&gt;부모노드의 값을 구하는 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Math.floor((index - 1) / 2)&lt;/code&gt; 인데&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;부모노드(0) -&amp;gt; 자식 노드(1, 2)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;부모노드(1) -&amp;gt; 자식 노드(3, 4)


부모노드(n) -&amp;gt; 자식 노드(2n + 1, 2n + 2) 임을 알 수 있다.


따라서 자식 노드가 +1, +2(왼쪽, 오른쪽) 중에 어떤 쪽인지에 상관없이 부모노드를 구하는 방법이 위의 방법인 것이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;bubbledown&quot;&gt;bubbleDown&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
  bubbleDown(index) {
    // index 번 째에 해당하는 노드의 값보다 큰 값이 있다면, index 노드를 아래로 내려보내야 한다.
    while (true) {
      const leftChildIndex = 2 * index + 1; // 왼쪽 자식 노드
      const rightChildIndex = 2 * index + 2; // 오른쪽 자식 노드
      let smallestIndex = index; // 부모노드, 왼쪽 자식노드, 오른쪽 자식 노드 중에 가장 작은 값을 저장할 변수

      if (leftChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.heap[leftChildIndex] &amp;lt; this.heap[smallestIndex]) {
        // 만약 부모노드보다 왼쪽 자식 노드가 작다면 smallestIndex 를 왼쪽 자식 노드로 변경
        smallestIndex = leftChildIndex;
      }

      if (rightChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.heap[rightChildIndex] &amp;lt; this.heap[smallestIndex]) {
        // 만약 위의 if 문에서 왼쪽 자식 노드가 작았다면 smallestIndex 는 왼쪽 자식 노드,
        // 아니라면 부모 노드
        // 똑같이 오른쪽 자식 노드랑 비교
        smallestIndex = rightChildIndex;
      }
      // 만약 가장 작은 노드가 부모 노드라면 최소 힙의 조건을 만족하므로 break
      if (smallestIndex === index) break;

      // 자식 노드 중에 더 작은 노드(smallestIndex) 와 부모노드를 스왑
      this.swap(index, smallestIndex);

      //더 작은 노드의 위치에 index 노드를 두고 반복
      index = smallestIndex;
    }
  }


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bubbleDown 도 bubbleUp 와는 반대로 내려오는 것이기 때문에,&lt;/p&gt;

&lt;p&gt;index에 해당하는 노드가 제자리를 찾을 때까지 자식 노드와의 비교를 반복한다.&lt;/p&gt;

&lt;h2 id=&quot;enqueue-dequeue&quot;&gt;enqueue, dequeue&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
  enqueue(value) {
    // 1. 힙 자료구조에 value 를 넣고
    this.heap.push(value);
    // 2. value 가 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; 아래의 bubbleUp 함수를 사용할 예정
    this.bubbleUp(this.heap.length - 1);
  }

  dequeue() {
    if (this.heap.length === 0) return null;

    // 1. 힙 자료구조의 루트 노드(0번째 Index)에 해당하는 값을 임시로 저장해두고
    // (pop 이 아님! pop(0)은 O(n) 의 시간복잡도를 가지기 떄문에 힙 자료구조를 사용하는 의미가 없어짐
    const min = this.heap[0];
    // 2. 맨 마지막 리프 노드에 해당하는 값을 루트 노드에 저장하고,
    const last = this.heap.pop();
    if (this.heap.length &amp;gt; 0) {
      this.heap[0] = last;

      // 3. 해당 루트 노드의 값이 알맞은 자리를 찾아갈 수 있도록 한다. -&amp;gt; bubbleDown
      this.bubbleDown(0);
    }

    return min;
  }


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;추가&quot;&gt;추가&lt;/h1&gt;

&lt;h2 id=&quot;comparator&quot;&gt;Comparator&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
    constructor(comparator) {
        if(comparator) this.comparator = comparator;
        else this.comparator = (a, b) =&amp;gt; a - b;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선순위 큐에 어떤 타입의 비교 연산을 해야할지 모르기 때문에, comparator 도 받을 수 있도록 하면 더 좋다.&lt;/p&gt;

&lt;p&gt;이렇게 Comparator 를 추가 했을 때, bubbleUp 과 bubbleDown 의 비교 로직을 comparator 로 하면 된다.&lt;/p&gt;

&lt;h1 id=&quot;자바스크립트-코드&quot;&gt;자바스크립트 코드&lt;/h1&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javascript
class PriorityQueue {
    heap = [];
    constructor(comparator) {
        if(comparator) this.comparator = comparator;
        else this.comparator = (a, b) =&amp;gt; a - b;
    }

    enqueue(value){
        const index = this.heap.push(value) - 1;
        this.bubbleUp(index);
    }

    dequeue(){
        if(this.heap.length === 0) return undefined;
        const smallest = this.heap[0];
        const last = this.heap.pop();
        if(this.heap.length &amp;gt; 0){
            this.heap[0] = last;
            this.bubbleDown(0);
        }
        return smallest;

    }

    peek(){
        return this.heap[0];
    }

    get length(){
        return this.heap.length;
    }

    bubbleUp(_index){
        let index = _index;
        while(index &amp;gt; 0){
            const parentIdx = Math.floor((index - 1) / 2);
            if(this.comparator(this.heap[parentIdx], this.heap[index]) &amp;lt;= 0) break;
            this.swap(index, parentIdx);
            index = parentIdx;
        }
    }

    bubbleDown(_index){
        let index = _index;
        while(index &amp;lt; this.heap.length){
            let smallestIndex = index;
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;

            if(leftChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(this.heap[smallestIndex], this.heap[leftChildIndex]) &amp;gt; 0) {
                smallestIndex = leftChildIndex;
            }
            if(rightChildIndex &amp;lt; this.heap.length &amp;amp;&amp;amp; this.comparator(this.heap[smallestIndex], this.heap[rightChildIndex]) &amp;gt; 0) {
                smallestIndex = rightChildIndex;
            }

            if(smallestIndex === index) break;

            this.swap(index, smallestIndex);
            index = smallestIndex;
        }

    }

		// 위에서 봤던 swap 코드중에서 임시 배열을 만드는 것을 하고싶지 않을 때는 아래와 같이 작성하면 된다.
    swap(i, j){
        const store = this.heap[i];
        this.heap[i] = this.heap[j];
        this.heap[j] = store;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>[&quot;hoeeeeeh&quot;]</name>
        
        
      </author>

      

      
        <category term="Algorithm" />
      

      
        <summary type="html">이번에 네이버 부스트 캠프 베이직 과정을 진행하면서 자바스크립트를 쓰게 되었는데, 평소에는 파이썬을 자주 사용했었기 때문에 자바스크립트로 파이썬을 대체해보려고 노력했다.</summary>
      

      
      
    </entry>
  
</feed>
